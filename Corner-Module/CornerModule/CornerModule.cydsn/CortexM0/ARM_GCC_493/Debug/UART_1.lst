ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART_1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_1_initVar
  18              		.bss
  19              		.type	UART_1_initVar, %object
  20              		.size	UART_1_initVar, 1
  21              	UART_1_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_1_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_1_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_1_Start, %function
  29              	UART_1_Start:
  30              	.LFB2:
  31              		.file 1 ".\\Generated_Source\\PSoC4\\UART_1.c"
   1:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC4/UART_1.c **** * Version 2.30
   4:.\Generated_Source\PSoC4/UART_1.c **** *
   5:.\Generated_Source\PSoC4/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC4/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART_1.c **** *
   8:.\Generated_Source\PSoC4/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC4/UART_1.c **** *
  10:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART_1.c **** * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART_1.c **** 
  17:.\Generated_Source\PSoC4/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC4/UART_1.c **** #include "CyLib.h"
  19:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_INTERNAL_CLOCK_USED)
  20:.\Generated_Source\PSoC4/UART_1.c ****     #include "UART_1_IntClock.h"
  21:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  22:.\Generated_Source\PSoC4/UART_1.c **** 
  23:.\Generated_Source\PSoC4/UART_1.c **** 
  24:.\Generated_Source\PSoC4/UART_1.c **** /***************************************
  25:.\Generated_Source\PSoC4/UART_1.c **** * Global data allocation
  26:.\Generated_Source\PSoC4/UART_1.c **** ***************************************/
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 2


  27:.\Generated_Source\PSoC4/UART_1.c **** 
  28:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_initVar = 0u;
  29:.\Generated_Source\PSoC4/UART_1.c **** #if( UART_1_TX_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
  30:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TXBUFFERSIZE];
  31:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_TX_ENABLED */
  34:.\Generated_Source\PSoC4/UART_1.c **** #if( ( UART_1_RX_ENABLED || UART_1_HD_ENABLED ) && \
  35:.\Generated_Source\PSoC4/UART_1.c ****      (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
  36:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RXBUFFERSIZE];
  37:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferRead = 0u;
  38:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  39:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  40:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow = 0u;
  41:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  42:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RXADDRESSMODE;
  43:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  44:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End EnableHWAddress */
  45:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_RX_ENABLED */
  46:.\Generated_Source\PSoC4/UART_1.c **** 
  47:.\Generated_Source\PSoC4/UART_1.c **** 
  48:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  49:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Start
  50:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  51:.\Generated_Source\PSoC4/UART_1.c **** *
  52:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  53:.\Generated_Source\PSoC4/UART_1.c **** *  Initialize and Enable the UART component.
  54:.\Generated_Source\PSoC4/UART_1.c **** *  Enable the clock input to enable operation.
  55:.\Generated_Source\PSoC4/UART_1.c **** *
  56:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  57:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  58:.\Generated_Source\PSoC4/UART_1.c **** *
  59:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  60:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC4/UART_1.c **** *
  62:.\Generated_Source\PSoC4/UART_1.c **** * Global variables:
  63:.\Generated_Source\PSoC4/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  64:.\Generated_Source\PSoC4/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  65:.\Generated_Source\PSoC4/UART_1.c **** *  and set to one (1u) the first time UART_Start() is called. This allows for
  66:.\Generated_Source\PSoC4/UART_1.c **** *  component initialization without re-initialization in all subsequent calls
  67:.\Generated_Source\PSoC4/UART_1.c **** *  to the UART_1_Start() routine.
  68:.\Generated_Source\PSoC4/UART_1.c **** *
  69:.\Generated_Source\PSoC4/UART_1.c **** * Reentrant:
  70:.\Generated_Source\PSoC4/UART_1.c **** *  No.
  71:.\Generated_Source\PSoC4/UART_1.c **** *
  72:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  73:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Start(void) 
  74:.\Generated_Source\PSoC4/UART_1.c **** {
  32              		.loc 1 74 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  75:.\Generated_Source\PSoC4/UART_1.c ****     /* If not Initialized then initialize all required hardware and software */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 3


  76:.\Generated_Source\PSoC4/UART_1.c ****     if(UART_1_initVar == 0u)
  40              		.loc 1 76 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  77:.\Generated_Source\PSoC4/UART_1.c ****     {
  78:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_Init();
  45              		.loc 1 78 0
  46 000c FFF7FEFF 		bl	UART_1_Init
  79:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_initVar = 1u;
  47              		.loc 1 79 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  80:.\Generated_Source\PSoC4/UART_1.c ****     }
  81:.\Generated_Source\PSoC4/UART_1.c ****     UART_1_Enable();
  52              		.loc 1 81 0
  53 0016 FFF7FEFF 		bl	UART_1_Enable
  82:.\Generated_Source\PSoC4/UART_1.c **** }
  54              		.loc 1 82 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_1_initVar
  62              		.cfi_endproc
  63              	.LFE2:
  64              		.size	UART_1_Start, .-UART_1_Start
  65              		.section	.text.UART_1_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_1_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_1_Init, %function
  71              	UART_1_Init:
  72              	.LFB3:
  83:.\Generated_Source\PSoC4/UART_1.c **** 
  84:.\Generated_Source\PSoC4/UART_1.c **** 
  85:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  86:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Init
  87:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  88:.\Generated_Source\PSoC4/UART_1.c **** *
  89:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  90:.\Generated_Source\PSoC4/UART_1.c **** *  Initialize component's parameters to the parameters set by user in the
  91:.\Generated_Source\PSoC4/UART_1.c **** *  customizer of the component placed onto schematic. Usually called in
  92:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Start().
  93:.\Generated_Source\PSoC4/UART_1.c **** *
  94:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  95:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  96:.\Generated_Source\PSoC4/UART_1.c **** *
  97:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  98:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  99:.\Generated_Source\PSoC4/UART_1.c **** *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 4


 100:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 101:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Init(void) 
 102:.\Generated_Source\PSoC4/UART_1.c **** {
  73              		.loc 1 102 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 103:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 104:.\Generated_Source\PSoC4/UART_1.c **** 
 105:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 106:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the RX Interrupt. */
 107:.\Generated_Source\PSoC4/UART_1.c ****             (void)CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 108:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 109:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 110:.\Generated_Source\PSoC4/UART_1.c **** 
 111:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 112:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RXAddressMode);
 113:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RXHWADDRESS1);
 114:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RXHWADDRESS2);
 115:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 116:.\Generated_Source\PSoC4/UART_1.c **** 
 117:.\Generated_Source\PSoC4/UART_1.c ****         /* Init Count7 period */
 118:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
  81              		.loc 1 118 0
  82 0004 084B     		ldr	r3, .L6
  83 0006 7222     		mov	r2, #114
  84 0008 1A70     		strb	r2, [r3]
 119:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 120:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
  85              		.loc 1 120 0
  86 000a 084B     		ldr	r3, .L6+4
  87 000c 2022     		mov	r2, #32
  88 000e 1A70     		strb	r2, [r3]
 121:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 122:.\Generated_Source\PSoC4/UART_1.c **** 
 123:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 124:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 125:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the TX Interrupt. */
 126:.\Generated_Source\PSoC4/UART_1.c ****             (void)CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 127:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 128:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 129:.\Generated_Source\PSoC4/UART_1.c **** 
 130:.\Generated_Source\PSoC4/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 131:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXCLKGEN_DP)
 132:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  89              		.loc 1 132 0
  90 0010 074B     		ldr	r3, .L6+8
  91 0012 0722     		mov	r2, #7
  92 0014 1A70     		strb	r2, [r3]
 133:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = (UART_1_NUMBER_OF_DATA_BITS +
  93              		.loc 1 133 0
  94 0016 074B     		ldr	r3, .L6+12
  95 0018 4822     		mov	r2, #72
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 5


  96 001a 1A70     		strb	r2, [r3]
 134:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT;
 135:.\Generated_Source\PSoC4/UART_1.c ****         #else
 136:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 137:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 138:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 139:.\Generated_Source\PSoC4/UART_1.c **** 
 140:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 141:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 142:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 143:.\Generated_Source\PSoC4/UART_1.c ****         #else
 144:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  97              		.loc 1 144 0
  98 001c 064B     		ldr	r3, .L6+16
  99 001e 0022     		mov	r2, #0
 100 0020 1A70     		strb	r2, [r3]
 145:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 146:.\Generated_Source\PSoC4/UART_1.c **** 
 147:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 148:.\Generated_Source\PSoC4/UART_1.c **** 
 149:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 150:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_WriteControlRegister( \
 151:.\Generated_Source\PSoC4/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 152:.\Generated_Source\PSoC4/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 153:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 154:.\Generated_Source\PSoC4/UART_1.c **** }
 101              		.loc 1 154 0
 102 0022 BD46     		mov	sp, r7
 103              		@ sp needed
 104 0024 80BD     		pop	{r7, pc}
 105              	.L7:
 106 0026 C046     		.align	2
 107              	.L6:
 108 0028 82000F40 		.word	1074724994
 109 002c 83000F40 		.word	1074724995
 110 0030 23000F40 		.word	1074724899
 111 0034 33000F40 		.word	1074724915
 112 0038 80000F40 		.word	1074724992
 113              		.cfi_endproc
 114              	.LFE3:
 115              		.size	UART_1_Init, .-UART_1_Init
 116              		.section	.text.UART_1_Enable,"ax",%progbits
 117              		.align	2
 118              		.global	UART_1_Enable
 119              		.code	16
 120              		.thumb_func
 121              		.type	UART_1_Enable, %function
 122              	UART_1_Enable:
 123              	.LFB4:
 155:.\Generated_Source\PSoC4/UART_1.c **** 
 156:.\Generated_Source\PSoC4/UART_1.c **** 
 157:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 158:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Enable
 159:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 160:.\Generated_Source\PSoC4/UART_1.c **** *
 161:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 162:.\Generated_Source\PSoC4/UART_1.c **** *  Enables the UART block operation
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 6


 163:.\Generated_Source\PSoC4/UART_1.c **** *
 164:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 165:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 166:.\Generated_Source\PSoC4/UART_1.c **** *
 167:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 168:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 169:.\Generated_Source\PSoC4/UART_1.c **** *
 170:.\Generated_Source\PSoC4/UART_1.c **** * Global Variables:
 171:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 172:.\Generated_Source\PSoC4/UART_1.c **** *
 173:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 174:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Enable(void) 
 175:.\Generated_Source\PSoC4/UART_1.c **** {
 124              		.loc 1 175 0
 125              		.cfi_startproc
 126 0000 90B5     		push	{r4, r7, lr}
 127              		.cfi_def_cfa_offset 12
 128              		.cfi_offset 4, -12
 129              		.cfi_offset 7, -8
 130              		.cfi_offset 14, -4
 131 0002 83B0     		sub	sp, sp, #12
 132              		.cfi_def_cfa_offset 24
 133 0004 00AF     		add	r7, sp, #0
 134              		.cfi_def_cfa_register 7
 176:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 177:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 135              		.loc 1 177 0
 136 0006 FC1D     		add	r4, r7, #7
 137 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 138 000c 031C     		mov	r3, r0
 139 000e 2370     		strb	r3, [r4]
 178:.\Generated_Source\PSoC4/UART_1.c **** 
 179:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 180:.\Generated_Source\PSoC4/UART_1.c ****         /*RX Counter (Count7) Enable */
 181:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 140              		.loc 1 181 0
 141 0010 0F4A     		ldr	r2, .L9
 142 0012 0F4B     		ldr	r3, .L9
 143 0014 1B78     		ldrb	r3, [r3]
 144 0016 DBB2     		uxtb	r3, r3
 145 0018 2021     		mov	r1, #32
 146 001a 0B43     		orr	r3, r1
 147 001c DBB2     		uxtb	r3, r3
 148 001e 1370     		strb	r3, [r2]
 182:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the RX Interrupt. */
 183:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 149              		.loc 1 183 0
 150 0020 0C4A     		ldr	r2, .L9+4
 151 0022 0C4B     		ldr	r3, .L9+4
 152 0024 1B78     		ldrb	r3, [r3]
 153 0026 DBB2     		uxtb	r3, r3
 154 0028 1021     		mov	r1, #16
 155 002a 0B43     		orr	r3, r1
 156 002c DBB2     		uxtb	r3, r3
 157 002e 1370     		strb	r3, [r2]
 184:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 185:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 7


 186:.\Generated_Source\PSoC4/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 187:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 188:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 189:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 190:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 191:.\Generated_Source\PSoC4/UART_1.c **** 
 192:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 193:.\Generated_Source\PSoC4/UART_1.c ****         /*TX Counter (DP/Count7) Enable */
 194:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 195:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 196:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 197:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the TX Interrupt. */
 198:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 158              		.loc 1 198 0
 159 0030 094A     		ldr	r2, .L9+8
 160 0032 094B     		ldr	r3, .L9+8
 161 0034 1B78     		ldrb	r3, [r3]
 162 0036 DBB2     		uxtb	r3, r3
 163 0038 1021     		mov	r1, #16
 164 003a 0B43     		orr	r3, r1
 165 003c DBB2     		uxtb	r3, r3
 166 003e 1370     		strb	r3, [r2]
 199:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 200:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 201:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED*/
 202:.\Generated_Source\PSoC4/UART_1.c ****      #endif /* End UART_1_TX_ENABLED */
 203:.\Generated_Source\PSoC4/UART_1.c **** 
 204:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 205:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the clock. */
 206:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Start();
 207:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 208:.\Generated_Source\PSoC4/UART_1.c **** 
 209:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 167              		.loc 1 209 0
 168 0040 FB1D     		add	r3, r7, #7
 169 0042 1B78     		ldrb	r3, [r3]
 170 0044 181C     		mov	r0, r3
 171 0046 FFF7FEFF 		bl	CyExitCriticalSection
 210:.\Generated_Source\PSoC4/UART_1.c **** }
 172              		.loc 1 210 0
 173 004a BD46     		mov	sp, r7
 174 004c 03B0     		add	sp, sp, #12
 175              		@ sp needed
 176 004e 90BD     		pop	{r4, r7, pc}
 177              	.L10:
 178              		.align	2
 179              	.L9:
 180 0050 92000F40 		.word	1074725010
 181 0054 93000F40 		.word	1074725011
 182 0058 90000F40 		.word	1074725008
 183              		.cfi_endproc
 184              	.LFE4:
 185              		.size	UART_1_Enable, .-UART_1_Enable
 186              		.section	.text.UART_1_Stop,"ax",%progbits
 187              		.align	2
 188              		.global	UART_1_Stop
 189              		.code	16
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 8


 190              		.thumb_func
 191              		.type	UART_1_Stop, %function
 192              	UART_1_Stop:
 193              	.LFB5:
 211:.\Generated_Source\PSoC4/UART_1.c **** 
 212:.\Generated_Source\PSoC4/UART_1.c **** 
 213:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 214:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Stop
 215:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 216:.\Generated_Source\PSoC4/UART_1.c **** *
 217:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 218:.\Generated_Source\PSoC4/UART_1.c **** *  Disable the UART component
 219:.\Generated_Source\PSoC4/UART_1.c **** *
 220:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 221:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 222:.\Generated_Source\PSoC4/UART_1.c **** *
 223:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 224:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 225:.\Generated_Source\PSoC4/UART_1.c **** *
 226:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 227:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Stop(void) 
 228:.\Generated_Source\PSoC4/UART_1.c **** {
 194              		.loc 1 228 0
 195              		.cfi_startproc
 196 0000 90B5     		push	{r4, r7, lr}
 197              		.cfi_def_cfa_offset 12
 198              		.cfi_offset 4, -12
 199              		.cfi_offset 7, -8
 200              		.cfi_offset 14, -4
 201 0002 83B0     		sub	sp, sp, #12
 202              		.cfi_def_cfa_offset 24
 203 0004 00AF     		add	r7, sp, #0
 204              		.cfi_def_cfa_register 7
 229:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 230:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 205              		.loc 1 230 0
 206 0006 FC1D     		add	r4, r7, #7
 207 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 208 000c 031C     		mov	r3, r0
 209 000e 2370     		strb	r3, [r4]
 231:.\Generated_Source\PSoC4/UART_1.c **** 
 232:.\Generated_Source\PSoC4/UART_1.c ****     /* Write Bit Counter Disable */
 233:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 234:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 210              		.loc 1 234 0
 211 0010 0F4A     		ldr	r2, .L12
 212 0012 0F4B     		ldr	r3, .L12
 213 0014 1B78     		ldrb	r3, [r3]
 214 0016 DBB2     		uxtb	r3, r3
 215 0018 2021     		mov	r1, #32
 216 001a 8B43     		bic	r3, r1
 217 001c DBB2     		uxtb	r3, r3
 218 001e 1370     		strb	r3, [r2]
 235:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 236:.\Generated_Source\PSoC4/UART_1.c **** 
 237:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 238:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 9


 239:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 240:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 241:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_ENABLED */
 242:.\Generated_Source\PSoC4/UART_1.c **** 
 243:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 244:.\Generated_Source\PSoC4/UART_1.c ****         /* Disable the clock. */
 245:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Stop();
 246:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 247:.\Generated_Source\PSoC4/UART_1.c **** 
 248:.\Generated_Source\PSoC4/UART_1.c ****     /* Disable internal interrupt component */
 249:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 250:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8)~UART_1_INT_ENABLE;
 219              		.loc 1 250 0
 220 0020 0C4A     		ldr	r2, .L12+4
 221 0022 0C4B     		ldr	r3, .L12+4
 222 0024 1B78     		ldrb	r3, [r3]
 223 0026 DBB2     		uxtb	r3, r3
 224 0028 1021     		mov	r1, #16
 225 002a 8B43     		bic	r3, r1
 226 002c DBB2     		uxtb	r3, r3
 227 002e 1370     		strb	r3, [r2]
 251:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 252:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableRxInt();
 253:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 254:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 255:.\Generated_Source\PSoC4/UART_1.c **** 
 256:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 257:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8)~UART_1_INT_ENABLE;
 228              		.loc 1 257 0
 229 0030 094A     		ldr	r2, .L12+8
 230 0032 094B     		ldr	r3, .L12+8
 231 0034 1B78     		ldrb	r3, [r3]
 232 0036 DBB2     		uxtb	r3, r3
 233 0038 1021     		mov	r1, #16
 234 003a 8B43     		bic	r3, r1
 235 003c DBB2     		uxtb	r3, r3
 236 003e 1370     		strb	r3, [r2]
 258:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 259:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 260:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 261:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 262:.\Generated_Source\PSoC4/UART_1.c **** 
 263:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 237              		.loc 1 263 0
 238 0040 FB1D     		add	r3, r7, #7
 239 0042 1B78     		ldrb	r3, [r3]
 240 0044 181C     		mov	r0, r3
 241 0046 FFF7FEFF 		bl	CyExitCriticalSection
 264:.\Generated_Source\PSoC4/UART_1.c **** }
 242              		.loc 1 264 0
 243 004a BD46     		mov	sp, r7
 244 004c 03B0     		add	sp, sp, #12
 245              		@ sp needed
 246 004e 90BD     		pop	{r4, r7, pc}
 247              	.L13:
 248              		.align	2
 249              	.L12:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 10


 250 0050 92000F40 		.word	1074725010
 251 0054 93000F40 		.word	1074725011
 252 0058 90000F40 		.word	1074725008
 253              		.cfi_endproc
 254              	.LFE5:
 255              		.size	UART_1_Stop, .-UART_1_Stop
 256              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 257              		.align	2
 258              		.global	UART_1_ReadControlRegister
 259              		.code	16
 260              		.thumb_func
 261              		.type	UART_1_ReadControlRegister, %function
 262              	UART_1_ReadControlRegister:
 263              	.LFB6:
 265:.\Generated_Source\PSoC4/UART_1.c **** 
 266:.\Generated_Source\PSoC4/UART_1.c **** 
 267:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 268:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 269:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 270:.\Generated_Source\PSoC4/UART_1.c **** *
 271:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 272:.\Generated_Source\PSoC4/UART_1.c **** *  Read the current state of the control register
 273:.\Generated_Source\PSoC4/UART_1.c **** *
 274:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 275:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 276:.\Generated_Source\PSoC4/UART_1.c **** *
 277:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 278:.\Generated_Source\PSoC4/UART_1.c **** *  Current state of the control register.
 279:.\Generated_Source\PSoC4/UART_1.c **** *
 280:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 281:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 282:.\Generated_Source\PSoC4/UART_1.c **** {
 264              		.loc 1 282 0
 265              		.cfi_startproc
 266 0000 80B5     		push	{r7, lr}
 267              		.cfi_def_cfa_offset 8
 268              		.cfi_offset 7, -8
 269              		.cfi_offset 14, -4
 270 0002 00AF     		add	r7, sp, #0
 271              		.cfi_def_cfa_register 7
 283:.\Generated_Source\PSoC4/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 284:.\Generated_Source\PSoC4/UART_1.c ****         return(0u);
 272              		.loc 1 284 0
 273 0004 0023     		mov	r3, #0
 285:.\Generated_Source\PSoC4/UART_1.c ****     #else
 286:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_CONTROL_REG);
 287:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 288:.\Generated_Source\PSoC4/UART_1.c **** }
 274              		.loc 1 288 0
 275 0006 181C     		mov	r0, r3
 276 0008 BD46     		mov	sp, r7
 277              		@ sp needed
 278 000a 80BD     		pop	{r7, pc}
 279              		.cfi_endproc
 280              	.LFE6:
 281              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 282              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 11


 283              		.align	2
 284              		.global	UART_1_WriteControlRegister
 285              		.code	16
 286              		.thumb_func
 287              		.type	UART_1_WriteControlRegister, %function
 288              	UART_1_WriteControlRegister:
 289              	.LFB7:
 289:.\Generated_Source\PSoC4/UART_1.c **** 
 290:.\Generated_Source\PSoC4/UART_1.c **** 
 291:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 292:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 293:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 294:.\Generated_Source\PSoC4/UART_1.c **** *
 295:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 296:.\Generated_Source\PSoC4/UART_1.c **** *  Writes an 8-bit value into the control register
 297:.\Generated_Source\PSoC4/UART_1.c **** *
 298:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 299:.\Generated_Source\PSoC4/UART_1.c **** *  control:  control register value
 300:.\Generated_Source\PSoC4/UART_1.c **** *
 301:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 302:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 303:.\Generated_Source\PSoC4/UART_1.c **** *
 304:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 305:.\Generated_Source\PSoC4/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 306:.\Generated_Source\PSoC4/UART_1.c **** {
 290              		.loc 1 306 0
 291              		.cfi_startproc
 292 0000 80B5     		push	{r7, lr}
 293              		.cfi_def_cfa_offset 8
 294              		.cfi_offset 7, -8
 295              		.cfi_offset 14, -4
 296 0002 82B0     		sub	sp, sp, #8
 297              		.cfi_def_cfa_offset 16
 298 0004 00AF     		add	r7, sp, #0
 299              		.cfi_def_cfa_register 7
 300 0006 021C     		mov	r2, r0
 301 0008 FB1D     		add	r3, r7, #7
 302 000a 1A70     		strb	r2, [r3]
 307:.\Generated_Source\PSoC4/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 308:.\Generated_Source\PSoC4/UART_1.c ****         if(control != 0u) { }      /* release compiler warning */
 309:.\Generated_Source\PSoC4/UART_1.c ****     #else
 310:.\Generated_Source\PSoC4/UART_1.c ****        UART_1_CONTROL_REG = control;
 311:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 312:.\Generated_Source\PSoC4/UART_1.c **** }
 303              		.loc 1 312 0
 304 000c BD46     		mov	sp, r7
 305 000e 02B0     		add	sp, sp, #8
 306              		@ sp needed
 307 0010 80BD     		pop	{r7, pc}
 308              		.cfi_endproc
 309              	.LFE7:
 310              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 311 0012 C046     		.section	.text.UART_1_SetRxInterruptMode,"ax",%progbits
 312              		.align	2
 313              		.global	UART_1_SetRxInterruptMode
 314              		.code	16
 315              		.thumb_func
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 12


 316              		.type	UART_1_SetRxInterruptMode, %function
 317              	UART_1_SetRxInterruptMode:
 318              	.LFB8:
 313:.\Generated_Source\PSoC4/UART_1.c **** 
 314:.\Generated_Source\PSoC4/UART_1.c **** 
 315:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 316:.\Generated_Source\PSoC4/UART_1.c **** 
 317:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_INTERRUPT_ENABLED)
 318:.\Generated_Source\PSoC4/UART_1.c **** 
 319:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 320:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_EnableRxInt
 321:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 322:.\Generated_Source\PSoC4/UART_1.c ****         *
 323:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 324:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable RX interrupt generation
 325:.\Generated_Source\PSoC4/UART_1.c ****         *
 326:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 327:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 328:.\Generated_Source\PSoC4/UART_1.c ****         *
 329:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 330:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 331:.\Generated_Source\PSoC4/UART_1.c ****         *
 332:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 333:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 334:.\Generated_Source\PSoC4/UART_1.c ****         *
 335:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 336:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_EnableRxInt(void) 
 337:.\Generated_Source\PSoC4/UART_1.c ****         {
 338:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
 339:.\Generated_Source\PSoC4/UART_1.c ****         }
 340:.\Generated_Source\PSoC4/UART_1.c **** 
 341:.\Generated_Source\PSoC4/UART_1.c **** 
 342:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 343:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_DisableRxInt
 344:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 345:.\Generated_Source\PSoC4/UART_1.c ****         *
 346:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 347:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable RX interrupt generation
 348:.\Generated_Source\PSoC4/UART_1.c ****         *
 349:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 350:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 351:.\Generated_Source\PSoC4/UART_1.c ****         *
 352:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 353:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 354:.\Generated_Source\PSoC4/UART_1.c ****         *
 355:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 356:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 357:.\Generated_Source\PSoC4/UART_1.c ****         *
 358:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_DisableRxInt(void) 
 360:.\Generated_Source\PSoC4/UART_1.c ****         {
 361:.\Generated_Source\PSoC4/UART_1.c ****             CyIntDisable(UART_1_RX_VECT_NUM);
 362:.\Generated_Source\PSoC4/UART_1.c ****         }
 363:.\Generated_Source\PSoC4/UART_1.c **** 
 364:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 365:.\Generated_Source\PSoC4/UART_1.c **** 
 366:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 13


 367:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 368:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 369:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 370:.\Generated_Source\PSoC4/UART_1.c ****     *
 371:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 372:.\Generated_Source\PSoC4/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 373:.\Generated_Source\PSoC4/UART_1.c ****     *
 374:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 375:.\Generated_Source\PSoC4/UART_1.c ****     *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376:.\Generated_Source\PSoC4/UART_1.c ****     *           the header file)
 377:.\Generated_Source\PSoC4/UART_1.c ****     *
 378:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 379:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 380:.\Generated_Source\PSoC4/UART_1.c ****     *
 381:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 382:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 383:.\Generated_Source\PSoC4/UART_1.c ****     *
 384:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 385:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 386:.\Generated_Source\PSoC4/UART_1.c ****     {
 319              		.loc 1 386 0
 320              		.cfi_startproc
 321 0000 80B5     		push	{r7, lr}
 322              		.cfi_def_cfa_offset 8
 323              		.cfi_offset 7, -8
 324              		.cfi_offset 14, -4
 325 0002 82B0     		sub	sp, sp, #8
 326              		.cfi_def_cfa_offset 16
 327 0004 00AF     		add	r7, sp, #0
 328              		.cfi_def_cfa_register 7
 329 0006 021C     		mov	r2, r0
 330 0008 FB1D     		add	r3, r7, #7
 331 000a 1A70     		strb	r2, [r3]
 387:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 332              		.loc 1 387 0
 333 000c 034A     		ldr	r2, .L18
 334 000e FB1D     		add	r3, r7, #7
 335 0010 1B78     		ldrb	r3, [r3]
 336 0012 1370     		strb	r3, [r2]
 388:.\Generated_Source\PSoC4/UART_1.c ****     }
 337              		.loc 1 388 0
 338 0014 BD46     		mov	sp, r7
 339 0016 02B0     		add	sp, sp, #8
 340              		@ sp needed
 341 0018 80BD     		pop	{r7, pc}
 342              	.L19:
 343 001a C046     		.align	2
 344              	.L18:
 345 001c 83000F40 		.word	1074724995
 346              		.cfi_endproc
 347              	.LFE8:
 348              		.size	UART_1_SetRxInterruptMode, .-UART_1_SetRxInterruptMode
 349              		.section	.text.UART_1_ReadRxData,"ax",%progbits
 350              		.align	2
 351              		.global	UART_1_ReadRxData
 352              		.code	16
 353              		.thumb_func
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 14


 354              		.type	UART_1_ReadRxData, %function
 355              	UART_1_ReadRxData:
 356              	.LFB9:
 389:.\Generated_Source\PSoC4/UART_1.c **** 
 390:.\Generated_Source\PSoC4/UART_1.c **** 
 391:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 392:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxData
 393:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 394:.\Generated_Source\PSoC4/UART_1.c ****     *
 395:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 396:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns data in RX Data register without checking status register to
 397:.\Generated_Source\PSoC4/UART_1.c ****     *  determine if data is valid
 398:.\Generated_Source\PSoC4/UART_1.c ****     *
 399:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 400:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 401:.\Generated_Source\PSoC4/UART_1.c ****     *
 402:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 403:.\Generated_Source\PSoC4/UART_1.c ****     *  Received data from RX register
 404:.\Generated_Source\PSoC4/UART_1.c ****     *
 405:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 406:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 407:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 408:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 409:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 410:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 411:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 412:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 413:.\Generated_Source\PSoC4/UART_1.c ****     *
 414:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 415:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 416:.\Generated_Source\PSoC4/UART_1.c ****     *
 417:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 418:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 419:.\Generated_Source\PSoC4/UART_1.c ****     {
 357              		.loc 1 419 0
 358              		.cfi_startproc
 359 0000 80B5     		push	{r7, lr}
 360              		.cfi_def_cfa_offset 8
 361              		.cfi_offset 7, -8
 362              		.cfi_offset 14, -4
 363 0002 82B0     		sub	sp, sp, #8
 364              		.cfi_def_cfa_offset 16
 365 0004 00AF     		add	r7, sp, #0
 366              		.cfi_def_cfa_register 7
 420:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData;
 421:.\Generated_Source\PSoC4/UART_1.c **** 
 422:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 423:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferRead;
 424:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferWrite;
 425:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 426:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 427:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 428:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 429:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 430:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 431:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 432:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 15


 433:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 434:.\Generated_Source\PSoC4/UART_1.c ****             {
 435:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 436:.\Generated_Source\PSoC4/UART_1.c ****                 loc_rxBufferRead++;
 437:.\Generated_Source\PSoC4/UART_1.c **** 
 438:.\Generated_Source\PSoC4/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 439:.\Generated_Source\PSoC4/UART_1.c ****                 {
 440:.\Generated_Source\PSoC4/UART_1.c ****                     loc_rxBufferRead = 0u;
 441:.\Generated_Source\PSoC4/UART_1.c ****                 }
 442:.\Generated_Source\PSoC4/UART_1.c ****                 /* Update the real pointer */
 443:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 444:.\Generated_Source\PSoC4/UART_1.c **** 
 445:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect != 0u )
 446:.\Generated_Source\PSoC4/UART_1.c ****                 {
 447:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 448:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) && \
 449:.\Generated_Source\PSoC4/UART_1.c ****                          (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 450:.\Generated_Source\PSoC4/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 451:.\Generated_Source\PSoC4/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 452:.\Generated_Source\PSoC4/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 453:.\Generated_Source\PSoC4/UART_1.c ****                             {   /* In Half duplex mode return RX mask only in RX
 454:.\Generated_Source\PSoC4/UART_1.c ****                                 *  configuration set, otherwise
 455:.\Generated_Source\PSoC4/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 456:.\Generated_Source\PSoC4/UART_1.c ****                                 */
 457:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 458:.\Generated_Source\PSoC4/UART_1.c ****                             }
 459:.\Generated_Source\PSoC4/UART_1.c ****                         #else
 460:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 461:.\Generated_Source\PSoC4/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 462:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 463:.\Generated_Source\PSoC4/UART_1.c ****                 }
 464:.\Generated_Source\PSoC4/UART_1.c ****             }
 465:.\Generated_Source\PSoC4/UART_1.c ****             else
 466:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 467:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 468:.\Generated_Source\PSoC4/UART_1.c ****             }
 469:.\Generated_Source\PSoC4/UART_1.c **** 
 470:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 471:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 472:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 473:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 474:.\Generated_Source\PSoC4/UART_1.c **** 
 475:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 476:.\Generated_Source\PSoC4/UART_1.c **** 
 477:.\Generated_Source\PSoC4/UART_1.c ****             /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 367              		.loc 1 478 0
 368 0006 054A     		ldr	r2, .L22
 369 0008 FB1D     		add	r3, r7, #7
 370 000a 1278     		ldrb	r2, [r2]
 371 000c 1A70     		strb	r2, [r3]
 479:.\Generated_Source\PSoC4/UART_1.c **** 
 480:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 481:.\Generated_Source\PSoC4/UART_1.c **** 
 482:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 372              		.loc 1 482 0
 373 000e FB1D     		add	r3, r7, #7
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 16


 374 0010 1B78     		ldrb	r3, [r3]
 483:.\Generated_Source\PSoC4/UART_1.c ****     }
 375              		.loc 1 483 0
 376 0012 181C     		mov	r0, r3
 377 0014 BD46     		mov	sp, r7
 378 0016 02B0     		add	sp, sp, #8
 379              		@ sp needed
 380 0018 80BD     		pop	{r7, pc}
 381              	.L23:
 382 001a C046     		.align	2
 383              	.L22:
 384 001c 41000F40 		.word	1074724929
 385              		.cfi_endproc
 386              	.LFE9:
 387              		.size	UART_1_ReadRxData, .-UART_1_ReadRxData
 388              		.section	.text.UART_1_ReadRxStatus,"ax",%progbits
 389              		.align	2
 390              		.global	UART_1_ReadRxStatus
 391              		.code	16
 392              		.thumb_func
 393              		.type	UART_1_ReadRxStatus, %function
 394              	UART_1_ReadRxStatus:
 395              	.LFB10:
 484:.\Generated_Source\PSoC4/UART_1.c **** 
 485:.\Generated_Source\PSoC4/UART_1.c **** 
 486:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 487:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 488:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 489:.\Generated_Source\PSoC4/UART_1.c ****     *
 490:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 491:.\Generated_Source\PSoC4/UART_1.c ****     *  Read the current state of the status register
 492:.\Generated_Source\PSoC4/UART_1.c ****     *  And detect software buffer overflow.
 493:.\Generated_Source\PSoC4/UART_1.c ****     *
 494:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 495:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 496:.\Generated_Source\PSoC4/UART_1.c ****     *
 497:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 498:.\Generated_Source\PSoC4/UART_1.c ****     *  Current state of the status register.
 499:.\Generated_Source\PSoC4/UART_1.c ****     *
 500:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 501:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 502:.\Generated_Source\PSoC4/UART_1.c ****     *   It set to one in RX interrupt when there isn?t free space in
 503:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 504:.\Generated_Source\PSoC4/UART_1.c ****     *   and cleared to zero by this API as an
 505:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506:.\Generated_Source\PSoC4/UART_1.c ****     *   bits.
 507:.\Generated_Source\PSoC4/UART_1.c ****     *
 508:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 509:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 510:.\Generated_Source\PSoC4/UART_1.c ****     {
 396              		.loc 1 510 0
 397              		.cfi_startproc
 398 0000 80B5     		push	{r7, lr}
 399              		.cfi_def_cfa_offset 8
 400              		.cfi_offset 7, -8
 401              		.cfi_offset 14, -4
 402 0002 82B0     		sub	sp, sp, #8
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 17


 403              		.cfi_def_cfa_offset 16
 404 0004 00AF     		add	r7, sp, #0
 405              		.cfi_def_cfa_register 7
 511:.\Generated_Source\PSoC4/UART_1.c ****         uint8 status;
 512:.\Generated_Source\PSoC4/UART_1.c **** 
 513:.\Generated_Source\PSoC4/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 406              		.loc 1 513 0
 407 0006 064B     		ldr	r3, .L26
 408 0008 1B78     		ldrb	r3, [r3]
 409 000a DAB2     		uxtb	r2, r3
 410 000c FB1D     		add	r3, r7, #7
 411 000e 7F21     		mov	r1, #127
 412 0010 0A40     		and	r2, r1
 413 0012 1A70     		strb	r2, [r3]
 514:.\Generated_Source\PSoC4/UART_1.c **** 
 515:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 516:.\Generated_Source\PSoC4/UART_1.c ****             if( UART_1_rxBufferOverflow != 0u )
 517:.\Generated_Source\PSoC4/UART_1.c ****             {
 518:.\Generated_Source\PSoC4/UART_1.c ****                 status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 519:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferOverflow = 0u;
 520:.\Generated_Source\PSoC4/UART_1.c ****             }
 521:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE */
 522:.\Generated_Source\PSoC4/UART_1.c **** 
 523:.\Generated_Source\PSoC4/UART_1.c ****         return(status);
 414              		.loc 1 523 0
 415 0014 FB1D     		add	r3, r7, #7
 416 0016 1B78     		ldrb	r3, [r3]
 524:.\Generated_Source\PSoC4/UART_1.c ****     }
 417              		.loc 1 524 0
 418 0018 181C     		mov	r0, r3
 419 001a BD46     		mov	sp, r7
 420 001c 02B0     		add	sp, sp, #8
 421              		@ sp needed
 422 001e 80BD     		pop	{r7, pc}
 423              	.L27:
 424              		.align	2
 425              	.L26:
 426 0020 63000F40 		.word	1074724963
 427              		.cfi_endproc
 428              	.LFE10:
 429              		.size	UART_1_ReadRxStatus, .-UART_1_ReadRxStatus
 430              		.section	.text.UART_1_GetChar,"ax",%progbits
 431              		.align	2
 432              		.global	UART_1_GetChar
 433              		.code	16
 434              		.thumb_func
 435              		.type	UART_1_GetChar, %function
 436              	UART_1_GetChar:
 437              	.LFB11:
 525:.\Generated_Source\PSoC4/UART_1.c **** 
 526:.\Generated_Source\PSoC4/UART_1.c **** 
 527:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 528:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetChar
 529:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 530:.\Generated_Source\PSoC4/UART_1.c ****     *
 531:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 532:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads UART RX buffer immediately, if data is not available or an error
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 18


 533:.\Generated_Source\PSoC4/UART_1.c ****     *  condition exists, zero is returned; otherwise, character is read and
 534:.\Generated_Source\PSoC4/UART_1.c ****     *  returned.
 535:.\Generated_Source\PSoC4/UART_1.c ****     *
 536:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 537:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 538:.\Generated_Source\PSoC4/UART_1.c ****     *
 539:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 540:.\Generated_Source\PSoC4/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541:.\Generated_Source\PSoC4/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 542:.\Generated_Source\PSoC4/UART_1.c ****     *
 543:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 544:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 545:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 546:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 547:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 548:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 549:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 550:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 551:.\Generated_Source\PSoC4/UART_1.c ****     *
 552:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 553:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 554:.\Generated_Source\PSoC4/UART_1.c ****     *
 555:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 556:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetChar(void) 
 557:.\Generated_Source\PSoC4/UART_1.c ****     {
 438              		.loc 1 557 0
 439              		.cfi_startproc
 440 0000 80B5     		push	{r7, lr}
 441              		.cfi_def_cfa_offset 8
 442              		.cfi_offset 7, -8
 443              		.cfi_offset 14, -4
 444 0002 82B0     		sub	sp, sp, #8
 445              		.cfi_def_cfa_offset 16
 446 0004 00AF     		add	r7, sp, #0
 447              		.cfi_def_cfa_register 7
 558:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData = 0u;
 448              		.loc 1 558 0
 449 0006 FB1D     		add	r3, r7, #7
 450 0008 0022     		mov	r2, #0
 451 000a 1A70     		strb	r2, [r3]
 559:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxStatus;
 560:.\Generated_Source\PSoC4/UART_1.c **** 
 561:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 562:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferRead;
 563:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferWrite;
 564:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 565:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 566:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 567:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 568:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 569:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 570:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 571:.\Generated_Source\PSoC4/UART_1.c **** 
 572:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 573:.\Generated_Source\PSoC4/UART_1.c ****             {
 574:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 575:.\Generated_Source\PSoC4/UART_1.c ****                 loc_rxBufferRead++;
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 19


 576:.\Generated_Source\PSoC4/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 577:.\Generated_Source\PSoC4/UART_1.c ****                 {
 578:.\Generated_Source\PSoC4/UART_1.c ****                     loc_rxBufferRead = 0u;
 579:.\Generated_Source\PSoC4/UART_1.c ****                 }
 580:.\Generated_Source\PSoC4/UART_1.c ****                 /* Update the real pointer */
 581:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 582:.\Generated_Source\PSoC4/UART_1.c **** 
 583:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u )
 584:.\Generated_Source\PSoC4/UART_1.c ****                 {
 585:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 586:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 587:.\Generated_Source\PSoC4/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 588:.\Generated_Source\PSoC4/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 589:.\Generated_Source\PSoC4/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 590:.\Generated_Source\PSoC4/UART_1.c ****                             {   /* In Half duplex mode return RX mask only if
 591:.\Generated_Source\PSoC4/UART_1.c ****                                 *  RX configuration set, otherwise
 592:.\Generated_Source\PSoC4/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 593:.\Generated_Source\PSoC4/UART_1.c ****                                 */
 594:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 595:.\Generated_Source\PSoC4/UART_1.c ****                             }
 596:.\Generated_Source\PSoC4/UART_1.c ****                         #else
 597:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 598:.\Generated_Source\PSoC4/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 599:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 600:.\Generated_Source\PSoC4/UART_1.c ****                 }
 601:.\Generated_Source\PSoC4/UART_1.c **** 
 602:.\Generated_Source\PSoC4/UART_1.c ****             }
 603:.\Generated_Source\PSoC4/UART_1.c ****             else
 604:.\Generated_Source\PSoC4/UART_1.c ****             {   rxStatus = UART_1_RXSTATUS_REG;
 605:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 606:.\Generated_Source\PSoC4/UART_1.c ****                 {   /* Read received data from FIFO*/
 607:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = UART_1_RXDATA_REG;
 608:.\Generated_Source\PSoC4/UART_1.c ****                     /*Check status on error*/
 609:.\Generated_Source\PSoC4/UART_1.c ****                     if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 610:.\Generated_Source\PSoC4/UART_1.c ****                                    UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 611:.\Generated_Source\PSoC4/UART_1.c ****                     {
 612:.\Generated_Source\PSoC4/UART_1.c ****                         rxData = 0u;
 613:.\Generated_Source\PSoC4/UART_1.c ****                     }
 614:.\Generated_Source\PSoC4/UART_1.c ****                 }
 615:.\Generated_Source\PSoC4/UART_1.c ****             }
 616:.\Generated_Source\PSoC4/UART_1.c **** 
 617:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 618:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 619:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 620:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 621:.\Generated_Source\PSoC4/UART_1.c **** 
 622:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 623:.\Generated_Source\PSoC4/UART_1.c **** 
 624:.\Generated_Source\PSoC4/UART_1.c ****             rxStatus =UART_1_RXSTATUS_REG;
 452              		.loc 1 624 0
 453 000c 0D4A     		ldr	r2, .L31
 454 000e BB1D     		add	r3, r7, #6
 455 0010 1278     		ldrb	r2, [r2]
 456 0012 1A70     		strb	r2, [r3]
 625:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 457              		.loc 1 625 0
 458 0014 BB1D     		add	r3, r7, #6
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 20


 459 0016 1B78     		ldrb	r3, [r3]
 460 0018 2022     		mov	r2, #32
 461 001a 1340     		and	r3, r2
 462 001c 0BD0     		beq	.L29
 626:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Read received data from FIFO*/
 627:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 463              		.loc 1 627 0
 464 001e 0A4A     		ldr	r2, .L31+4
 465 0020 FB1D     		add	r3, r7, #7
 466 0022 1278     		ldrb	r2, [r2]
 467 0024 1A70     		strb	r2, [r3]
 628:.\Generated_Source\PSoC4/UART_1.c ****                 /*Check status on error*/
 629:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 630:.\Generated_Source\PSoC4/UART_1.c ****                                UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 468              		.loc 1 630 0
 469 0026 BB1D     		add	r3, r7, #6
 470 0028 1B78     		ldrb	r3, [r3]
 471 002a 1E22     		mov	r2, #30
 472 002c 1340     		and	r3, r2
 629:.\Generated_Source\PSoC4/UART_1.c ****                                UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 473              		.loc 1 629 0
 474 002e 02D0     		beq	.L29
 631:.\Generated_Source\PSoC4/UART_1.c ****                 {
 632:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = 0u;
 475              		.loc 1 632 0
 476 0030 FB1D     		add	r3, r7, #7
 477 0032 0022     		mov	r2, #0
 478 0034 1A70     		strb	r2, [r3]
 479              	.L29:
 633:.\Generated_Source\PSoC4/UART_1.c ****                 }
 634:.\Generated_Source\PSoC4/UART_1.c ****             }
 635:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 636:.\Generated_Source\PSoC4/UART_1.c **** 
 637:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 480              		.loc 1 637 0
 481 0036 FB1D     		add	r3, r7, #7
 482 0038 1B78     		ldrb	r3, [r3]
 638:.\Generated_Source\PSoC4/UART_1.c ****     }
 483              		.loc 1 638 0
 484 003a 181C     		mov	r0, r3
 485 003c BD46     		mov	sp, r7
 486 003e 02B0     		add	sp, sp, #8
 487              		@ sp needed
 488 0040 80BD     		pop	{r7, pc}
 489              	.L32:
 490 0042 C046     		.align	2
 491              	.L31:
 492 0044 63000F40 		.word	1074724963
 493 0048 41000F40 		.word	1074724929
 494              		.cfi_endproc
 495              	.LFE11:
 496              		.size	UART_1_GetChar, .-UART_1_GetChar
 497              		.section	.text.UART_1_GetByte,"ax",%progbits
 498              		.align	2
 499              		.global	UART_1_GetByte
 500              		.code	16
 501              		.thumb_func
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 21


 502              		.type	UART_1_GetByte, %function
 503              	UART_1_GetByte:
 504              	.LFB12:
 639:.\Generated_Source\PSoC4/UART_1.c **** 
 640:.\Generated_Source\PSoC4/UART_1.c **** 
 641:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 642:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetByte
 643:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 644:.\Generated_Source\PSoC4/UART_1.c ****     *
 645:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 646:.\Generated_Source\PSoC4/UART_1.c ****     *  Grab the next available byte of data from the recieve FIFO
 647:.\Generated_Source\PSoC4/UART_1.c ****     *
 648:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 649:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 650:.\Generated_Source\PSoC4/UART_1.c ****     *
 651:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 652:.\Generated_Source\PSoC4/UART_1.c ****     *  MSB contains Status Register and LSB contains UART RX data
 653:.\Generated_Source\PSoC4/UART_1.c ****     *
 654:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 655:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 656:.\Generated_Source\PSoC4/UART_1.c ****     *
 657:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 658:.\Generated_Source\PSoC4/UART_1.c ****     uint16 UART_1_GetByte(void) 
 659:.\Generated_Source\PSoC4/UART_1.c ****     {
 505              		.loc 1 659 0
 506              		.cfi_startproc
 507 0000 98B5     		push	{r3, r4, r7, lr}
 508              		.cfi_def_cfa_offset 16
 509              		.cfi_offset 3, -16
 510              		.cfi_offset 4, -12
 511              		.cfi_offset 7, -8
 512              		.cfi_offset 14, -4
 513 0002 00AF     		add	r7, sp, #0
 514              		.cfi_def_cfa_register 7
 660:.\Generated_Source\PSoC4/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 515              		.loc 1 660 0
 516 0004 FFF7FEFF 		bl	UART_1_ReadRxStatus
 517 0008 031C     		mov	r3, r0
 518 000a 1B02     		lsl	r3, r3, #8
 519 000c 9CB2     		uxth	r4, r3
 520 000e FFF7FEFF 		bl	UART_1_ReadRxData
 521 0012 031C     		mov	r3, r0
 522 0014 9BB2     		uxth	r3, r3
 523 0016 221C     		add	r2, r4, #0
 524 0018 1343     		orr	r3, r2
 525 001a 9BB2     		uxth	r3, r3
 526 001c 9BB2     		uxth	r3, r3
 661:.\Generated_Source\PSoC4/UART_1.c ****     }
 527              		.loc 1 661 0
 528 001e 181C     		mov	r0, r3
 529 0020 BD46     		mov	sp, r7
 530              		@ sp needed
 531 0022 98BD     		pop	{r3, r4, r7, pc}
 532              		.cfi_endproc
 533              	.LFE12:
 534              		.size	UART_1_GetByte, .-UART_1_GetByte
 535              		.section	.text.UART_1_GetRxBufferSize,"ax",%progbits
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 22


 536              		.align	2
 537              		.global	UART_1_GetRxBufferSize
 538              		.code	16
 539              		.thumb_func
 540              		.type	UART_1_GetRxBufferSize, %function
 541              	UART_1_GetRxBufferSize:
 542              	.LFB13:
 662:.\Generated_Source\PSoC4/UART_1.c **** 
 663:.\Generated_Source\PSoC4/UART_1.c **** 
 664:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 665:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 666:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 667:.\Generated_Source\PSoC4/UART_1.c ****     *
 668:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 669:.\Generated_Source\PSoC4/UART_1.c ****     *  Determine the amount of bytes left in the RX buffer and return the count in
 670:.\Generated_Source\PSoC4/UART_1.c ****     *  bytes
 671:.\Generated_Source\PSoC4/UART_1.c ****     *
 672:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 673:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 674:.\Generated_Source\PSoC4/UART_1.c ****     *
 675:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 676:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8: Integer count of the number of bytes left
 677:.\Generated_Source\PSoC4/UART_1.c ****     *  in the RX buffer
 678:.\Generated_Source\PSoC4/UART_1.c ****     *
 679:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 680:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 681:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 682:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 683:.\Generated_Source\PSoC4/UART_1.c ****     *
 684:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 685:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 686:.\Generated_Source\PSoC4/UART_1.c ****     *
 687:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 688:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 689:.\Generated_Source\PSoC4/UART_1.c ****     *
 690:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 691:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 692:.\Generated_Source\PSoC4/UART_1.c ****                                                             
 693:.\Generated_Source\PSoC4/UART_1.c ****     {
 543              		.loc 1 693 0
 544              		.cfi_startproc
 545 0000 80B5     		push	{r7, lr}
 546              		.cfi_def_cfa_offset 8
 547              		.cfi_offset 7, -8
 548              		.cfi_offset 14, -4
 549 0002 82B0     		sub	sp, sp, #8
 550              		.cfi_def_cfa_offset 16
 551 0004 00AF     		add	r7, sp, #0
 552              		.cfi_def_cfa_register 7
 694:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
 695:.\Generated_Source\PSoC4/UART_1.c **** 
 696:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 697:.\Generated_Source\PSoC4/UART_1.c **** 
 698:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 699:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 700:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 701:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 23


 702:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 703:.\Generated_Source\PSoC4/UART_1.c **** 
 704:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC4/UART_1.c ****             {
 706:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u)
 707:.\Generated_Source\PSoC4/UART_1.c ****                 {
 708:.\Generated_Source\PSoC4/UART_1.c ****                     size = UART_1_RXBUFFERSIZE;
 709:.\Generated_Source\PSoC4/UART_1.c ****                 }
 710:.\Generated_Source\PSoC4/UART_1.c ****                 else
 711:.\Generated_Source\PSoC4/UART_1.c ****                 {
 712:.\Generated_Source\PSoC4/UART_1.c ****                     size = 0u;
 713:.\Generated_Source\PSoC4/UART_1.c ****                 }
 714:.\Generated_Source\PSoC4/UART_1.c ****             }
 715:.\Generated_Source\PSoC4/UART_1.c ****             else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 716:.\Generated_Source\PSoC4/UART_1.c ****             {
 717:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 718:.\Generated_Source\PSoC4/UART_1.c ****             }
 719:.\Generated_Source\PSoC4/UART_1.c ****             else
 720:.\Generated_Source\PSoC4/UART_1.c ****             {
 721:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_RXBUFFERSIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 722:.\Generated_Source\PSoC4/UART_1.c ****             }
 723:.\Generated_Source\PSoC4/UART_1.c **** 
 724:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 725:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 726:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 727:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 728:.\Generated_Source\PSoC4/UART_1.c **** 
 729:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 730:.\Generated_Source\PSoC4/UART_1.c **** 
 731:.\Generated_Source\PSoC4/UART_1.c ****             /* We can only know if there is data in the fifo. */
 732:.\Generated_Source\PSoC4/UART_1.c ****             size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 553              		.loc 1 732 0
 554 0006 094B     		ldr	r3, .L39
 555 0008 1B78     		ldrb	r3, [r3]
 556 000a DBB2     		uxtb	r3, r3
 557 000c 1A1C     		mov	r2, r3
 558 000e 2023     		mov	r3, #32
 559 0010 1340     		and	r3, r2
 560 0012 01D0     		beq	.L36
 561              		.loc 1 732 0 is_stmt 0 discriminator 1
 562 0014 0122     		mov	r2, #1
 563 0016 00E0     		b	.L37
 564              	.L36:
 565              		.loc 1 732 0 discriminator 2
 566 0018 0022     		mov	r2, #0
 567              	.L37:
 568              		.loc 1 732 0 discriminator 4
 569 001a FB1D     		add	r3, r7, #7
 570 001c 1A70     		strb	r2, [r3]
 733:.\Generated_Source\PSoC4/UART_1.c **** 
 734:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 735:.\Generated_Source\PSoC4/UART_1.c **** 
 736:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 571              		.loc 1 736 0 is_stmt 1 discriminator 4
 572 001e FB1D     		add	r3, r7, #7
 573 0020 1B78     		ldrb	r3, [r3]
 737:.\Generated_Source\PSoC4/UART_1.c ****     }
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 24


 574              		.loc 1 737 0 discriminator 4
 575 0022 181C     		mov	r0, r3
 576 0024 BD46     		mov	sp, r7
 577 0026 02B0     		add	sp, sp, #8
 578              		@ sp needed
 579 0028 80BD     		pop	{r7, pc}
 580              	.L40:
 581 002a C046     		.align	2
 582              	.L39:
 583 002c 63000F40 		.word	1074724963
 584              		.cfi_endproc
 585              	.LFE13:
 586              		.size	UART_1_GetRxBufferSize, .-UART_1_GetRxBufferSize
 587              		.section	.text.UART_1_ClearRxBuffer,"ax",%progbits
 588              		.align	2
 589              		.global	UART_1_ClearRxBuffer
 590              		.code	16
 591              		.thumb_func
 592              		.type	UART_1_ClearRxBuffer, %function
 593              	UART_1_ClearRxBuffer:
 594              	.LFB14:
 738:.\Generated_Source\PSoC4/UART_1.c **** 
 739:.\Generated_Source\PSoC4/UART_1.c **** 
 740:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 741:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 742:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 743:.\Generated_Source\PSoC4/UART_1.c ****     *
 744:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 745:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears hardware RX FIFO.
 747:.\Generated_Source\PSoC4/UART_1.c ****     *
 748:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 749:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 750:.\Generated_Source\PSoC4/UART_1.c ****     *
 751:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 752:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 753:.\Generated_Source\PSoC4/UART_1.c ****     *
 754:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 755:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 756:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 757:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 758:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 759:.\Generated_Source\PSoC4/UART_1.c ****     *
 760:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 761:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 762:.\Generated_Source\PSoC4/UART_1.c ****     *
 763:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 764:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 765:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 766:.\Generated_Source\PSoC4/UART_1.c ****     *  have remained in the RAM.
 767:.\Generated_Source\PSoC4/UART_1.c ****     *
 768:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
 769:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 770:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 771:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 772:.\Generated_Source\PSoC4/UART_1.c ****     {
 595              		.loc 1 772 0
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 25


 596              		.cfi_startproc
 597 0000 90B5     		push	{r4, r7, lr}
 598              		.cfi_def_cfa_offset 12
 599              		.cfi_offset 4, -12
 600              		.cfi_offset 7, -8
 601              		.cfi_offset 14, -4
 602 0002 83B0     		sub	sp, sp, #12
 603              		.cfi_def_cfa_offset 24
 604 0004 00AF     		add	r7, sp, #0
 605              		.cfi_def_cfa_register 7
 773:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
 774:.\Generated_Source\PSoC4/UART_1.c **** 
 775:.\Generated_Source\PSoC4/UART_1.c ****         /* clear the HW FIFO */
 776:.\Generated_Source\PSoC4/UART_1.c ****         /* Enter critical section */
 777:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 606              		.loc 1 777 0
 607 0006 FC1D     		add	r4, r7, #7
 608 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 609 000c 031C     		mov	r3, r0
 610 000e 2370     		strb	r3, [r4]
 778:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |=  UART_1_RX_FIFO_CLR;
 611              		.loc 1 778 0
 612 0010 0B4A     		ldr	r2, .L42
 613 0012 0B4B     		ldr	r3, .L42
 614 0014 1B78     		ldrb	r3, [r3]
 615 0016 DBB2     		uxtb	r3, r3
 616 0018 0121     		mov	r1, #1
 617 001a 0B43     		orr	r3, r1
 618 001c DBB2     		uxtb	r3, r3
 619 001e 1370     		strb	r3, [r2]
 779:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8)~UART_1_RX_FIFO_CLR;
 620              		.loc 1 779 0
 621 0020 074A     		ldr	r2, .L42
 622 0022 074B     		ldr	r3, .L42
 623 0024 1B78     		ldrb	r3, [r3]
 624 0026 DBB2     		uxtb	r3, r3
 625 0028 0121     		mov	r1, #1
 626 002a 8B43     		bic	r3, r1
 627 002c DBB2     		uxtb	r3, r3
 628 002e 1370     		strb	r3, [r2]
 780:.\Generated_Source\PSoC4/UART_1.c ****         /* Exit critical section */
 781:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 629              		.loc 1 781 0
 630 0030 FB1D     		add	r3, r7, #7
 631 0032 1B78     		ldrb	r3, [r3]
 632 0034 181C     		mov	r0, r3
 633 0036 FFF7FEFF 		bl	CyExitCriticalSection
 782:.\Generated_Source\PSoC4/UART_1.c **** 
 783:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 784:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 785:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 786:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 787:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 788:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 789:.\Generated_Source\PSoC4/UART_1.c **** 
 790:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = 0u;
 791:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferWrite = 0u;
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 26


 792:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferLoopDetect = 0u;
 793:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 794:.\Generated_Source\PSoC4/UART_1.c **** 
 795:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 796:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 797:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 798:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 799:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 800:.\Generated_Source\PSoC4/UART_1.c **** 
 801:.\Generated_Source\PSoC4/UART_1.c ****     }
 634              		.loc 1 801 0
 635 003a BD46     		mov	sp, r7
 636 003c 03B0     		add	sp, sp, #12
 637              		@ sp needed
 638 003e 90BD     		pop	{r4, r7, pc}
 639              	.L43:
 640              		.align	2
 641              	.L42:
 642 0040 91000F40 		.word	1074725009
 643              		.cfi_endproc
 644              	.LFE14:
 645              		.size	UART_1_ClearRxBuffer, .-UART_1_ClearRxBuffer
 646              		.section	.text.UART_1_SetRxAddressMode,"ax",%progbits
 647              		.align	2
 648              		.global	UART_1_SetRxAddressMode
 649              		.code	16
 650              		.thumb_func
 651              		.type	UART_1_SetRxAddressMode, %function
 652              	UART_1_SetRxAddressMode:
 653              	.LFB15:
 802:.\Generated_Source\PSoC4/UART_1.c **** 
 803:.\Generated_Source\PSoC4/UART_1.c **** 
 804:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 805:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 806:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 807:.\Generated_Source\PSoC4/UART_1.c ****     *
 808:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 809:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the receive addressing mode
 810:.\Generated_Source\PSoC4/UART_1.c ****     *
 811:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 812:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 813:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 815:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 817:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 819:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 821:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 822:.\Generated_Source\PSoC4/UART_1.c ****     *
 823:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 824:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 825:.\Generated_Source\PSoC4/UART_1.c ****     *
 826:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 827:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 828:.\Generated_Source\PSoC4/UART_1.c ****     *   the farther usage in RX ISR.
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 27


 829:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 830:.\Generated_Source\PSoC4/UART_1.c ****     *
 831:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 832:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 833:.\Generated_Source\PSoC4/UART_1.c ****                                                         
 834:.\Generated_Source\PSoC4/UART_1.c ****     {
 654              		.loc 1 834 0
 655              		.cfi_startproc
 656 0000 80B5     		push	{r7, lr}
 657              		.cfi_def_cfa_offset 8
 658              		.cfi_offset 7, -8
 659              		.cfi_offset 14, -4
 660 0002 82B0     		sub	sp, sp, #8
 661              		.cfi_def_cfa_offset 16
 662 0004 00AF     		add	r7, sp, #0
 663              		.cfi_def_cfa_register 7
 664 0006 021C     		mov	r2, r0
 665 0008 FB1D     		add	r3, r7, #7
 666 000a 1A70     		strb	r2, [r3]
 835:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 836:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 837:.\Generated_Source\PSoC4/UART_1.c ****                 if(addressMode != 0u) { }     /* release compiler warning */
 838:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 839:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 tmpCtrl;
 840:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 841:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 842:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 843:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 844:.\Generated_Source\PSoC4/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 845:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 846:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 847:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 848:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 849:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 850:.\Generated_Source\PSoC4/UART_1.c ****             if(addressMode != 0u) { }     /* release compiler warning */
 851:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 852:.\Generated_Source\PSoC4/UART_1.c ****     }
 667              		.loc 1 852 0
 668 000c BD46     		mov	sp, r7
 669 000e 02B0     		add	sp, sp, #8
 670              		@ sp needed
 671 0010 80BD     		pop	{r7, pc}
 672              		.cfi_endproc
 673              	.LFE15:
 674              		.size	UART_1_SetRxAddressMode, .-UART_1_SetRxAddressMode
 675 0012 C046     		.section	.text.UART_1_SetRxAddress1,"ax",%progbits
 676              		.align	2
 677              		.global	UART_1_SetRxAddress1
 678              		.code	16
 679              		.thumb_func
 680              		.type	UART_1_SetRxAddress1, %function
 681              	UART_1_SetRxAddress1:
 682              	.LFB16:
 853:.\Generated_Source\PSoC4/UART_1.c **** 
 854:.\Generated_Source\PSoC4/UART_1.c **** 
 855:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 856:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 28


 857:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 858:.\Generated_Source\PSoC4/UART_1.c ****     *
 859:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 860:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the first hardware address compare value
 861:.\Generated_Source\PSoC4/UART_1.c ****     *
 862:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 863:.\Generated_Source\PSoC4/UART_1.c ****     *  address
 864:.\Generated_Source\PSoC4/UART_1.c ****     *
 865:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 866:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 867:.\Generated_Source\PSoC4/UART_1.c ****     *
 868:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 869:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 870:.\Generated_Source\PSoC4/UART_1.c **** 
 871:.\Generated_Source\PSoC4/UART_1.c ****     {
 683              		.loc 1 871 0
 684              		.cfi_startproc
 685 0000 80B5     		push	{r7, lr}
 686              		.cfi_def_cfa_offset 8
 687              		.cfi_offset 7, -8
 688              		.cfi_offset 14, -4
 689 0002 82B0     		sub	sp, sp, #8
 690              		.cfi_def_cfa_offset 16
 691 0004 00AF     		add	r7, sp, #0
 692              		.cfi_def_cfa_register 7
 693 0006 021C     		mov	r2, r0
 694 0008 FB1D     		add	r3, r7, #7
 695 000a 1A70     		strb	r2, [r3]
 872:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 696              		.loc 1 872 0
 697 000c 034A     		ldr	r2, .L46
 698 000e FB1D     		add	r3, r7, #7
 699 0010 1B78     		ldrb	r3, [r3]
 700 0012 1370     		strb	r3, [r2]
 873:.\Generated_Source\PSoC4/UART_1.c ****     }
 701              		.loc 1 873 0
 702 0014 BD46     		mov	sp, r7
 703 0016 02B0     		add	sp, sp, #8
 704              		@ sp needed
 705 0018 80BD     		pop	{r7, pc}
 706              	.L47:
 707 001a C046     		.align	2
 708              	.L46:
 709 001c 21000F40 		.word	1074724897
 710              		.cfi_endproc
 711              	.LFE16:
 712              		.size	UART_1_SetRxAddress1, .-UART_1_SetRxAddress1
 713              		.section	.text.UART_1_SetRxAddress2,"ax",%progbits
 714              		.align	2
 715              		.global	UART_1_SetRxAddress2
 716              		.code	16
 717              		.thumb_func
 718              		.type	UART_1_SetRxAddress2, %function
 719              	UART_1_SetRxAddress2:
 720              	.LFB17:
 874:.\Generated_Source\PSoC4/UART_1.c **** 
 875:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 29


 876:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 877:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 878:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 879:.\Generated_Source\PSoC4/UART_1.c ****     *
 880:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 881:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the second hardware address compare value
 882:.\Generated_Source\PSoC4/UART_1.c ****     *
 883:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 884:.\Generated_Source\PSoC4/UART_1.c ****     *  address
 885:.\Generated_Source\PSoC4/UART_1.c ****     *
 886:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 887:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 888:.\Generated_Source\PSoC4/UART_1.c ****     *
 889:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 890:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 891:.\Generated_Source\PSoC4/UART_1.c ****     {
 721              		.loc 1 891 0
 722              		.cfi_startproc
 723 0000 80B5     		push	{r7, lr}
 724              		.cfi_def_cfa_offset 8
 725              		.cfi_offset 7, -8
 726              		.cfi_offset 14, -4
 727 0002 82B0     		sub	sp, sp, #8
 728              		.cfi_def_cfa_offset 16
 729 0004 00AF     		add	r7, sp, #0
 730              		.cfi_def_cfa_register 7
 731 0006 021C     		mov	r2, r0
 732 0008 FB1D     		add	r3, r7, #7
 733 000a 1A70     		strb	r2, [r3]
 892:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 734              		.loc 1 892 0
 735 000c 034A     		ldr	r2, .L49
 736 000e FB1D     		add	r3, r7, #7
 737 0010 1B78     		ldrb	r3, [r3]
 738 0012 1370     		strb	r3, [r2]
 893:.\Generated_Source\PSoC4/UART_1.c ****     }
 739              		.loc 1 893 0
 740 0014 BD46     		mov	sp, r7
 741 0016 02B0     		add	sp, sp, #8
 742              		@ sp needed
 743 0018 80BD     		pop	{r7, pc}
 744              	.L50:
 745 001a C046     		.align	2
 746              	.L49:
 747 001c 31000F40 		.word	1074724913
 748              		.cfi_endproc
 749              	.LFE17:
 750              		.size	UART_1_SetRxAddress2, .-UART_1_SetRxAddress2
 751              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 752              		.align	2
 753              		.global	UART_1_SetTxInterruptMode
 754              		.code	16
 755              		.thumb_func
 756              		.type	UART_1_SetTxInterruptMode, %function
 757              	UART_1_SetTxInterruptMode:
 758              	.LFB18:
 894:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 30


 895:.\Generated_Source\PSoC4/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 896:.\Generated_Source\PSoC4/UART_1.c **** 
 897:.\Generated_Source\PSoC4/UART_1.c **** 
 898:.\Generated_Source\PSoC4/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 899:.\Generated_Source\PSoC4/UART_1.c **** 
 900:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_INTERRUPT_ENABLED)
 901:.\Generated_Source\PSoC4/UART_1.c **** 
 902:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 903:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_EnableTxInt
 904:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 905:.\Generated_Source\PSoC4/UART_1.c ****         *
 906:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 907:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable TX interrupt generation
 908:.\Generated_Source\PSoC4/UART_1.c ****         *
 909:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 910:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 911:.\Generated_Source\PSoC4/UART_1.c ****         *
 912:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 913:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 914:.\Generated_Source\PSoC4/UART_1.c ****         *
 915:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 916:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 917:.\Generated_Source\PSoC4/UART_1.c ****         *
 918:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 919:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_EnableTxInt(void) 
 920:.\Generated_Source\PSoC4/UART_1.c ****         {
 921:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 922:.\Generated_Source\PSoC4/UART_1.c ****         }
 923:.\Generated_Source\PSoC4/UART_1.c **** 
 924:.\Generated_Source\PSoC4/UART_1.c **** 
 925:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 926:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_DisableTxInt
 927:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 928:.\Generated_Source\PSoC4/UART_1.c ****         *
 929:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 930:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable TX interrupt generation
 931:.\Generated_Source\PSoC4/UART_1.c ****         *
 932:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 933:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 934:.\Generated_Source\PSoC4/UART_1.c ****         *
 935:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 936:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 937:.\Generated_Source\PSoC4/UART_1.c ****         *
 938:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 939:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 940:.\Generated_Source\PSoC4/UART_1.c ****         *
 941:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_DisableTxInt(void) 
 943:.\Generated_Source\PSoC4/UART_1.c ****         {
 944:.\Generated_Source\PSoC4/UART_1.c ****             CyIntDisable(UART_1_TX_VECT_NUM);
 945:.\Generated_Source\PSoC4/UART_1.c ****         }
 946:.\Generated_Source\PSoC4/UART_1.c **** 
 947:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_INTERRUPT_ENABLED */
 948:.\Generated_Source\PSoC4/UART_1.c **** 
 949:.\Generated_Source\PSoC4/UART_1.c **** 
 950:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 951:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 31


 952:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 953:.\Generated_Source\PSoC4/UART_1.c ****     *
 954:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 955:.\Generated_Source\PSoC4/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 956:.\Generated_Source\PSoC4/UART_1.c ****     *
 957:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 958:.\Generated_Source\PSoC4/UART_1.c ****     *  intSrc: An or'd combination of the desired status bit masks (defined in
 959:.\Generated_Source\PSoC4/UART_1.c ****     *          the header file)
 960:.\Generated_Source\PSoC4/UART_1.c ****     *
 961:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 962:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 963:.\Generated_Source\PSoC4/UART_1.c ****     *
 964:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 965:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 966:.\Generated_Source\PSoC4/UART_1.c ****     *
 967:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 968:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 969:.\Generated_Source\PSoC4/UART_1.c ****     {
 759              		.loc 1 969 0
 760              		.cfi_startproc
 761 0000 80B5     		push	{r7, lr}
 762              		.cfi_def_cfa_offset 8
 763              		.cfi_offset 7, -8
 764              		.cfi_offset 14, -4
 765 0002 82B0     		sub	sp, sp, #8
 766              		.cfi_def_cfa_offset 16
 767 0004 00AF     		add	r7, sp, #0
 768              		.cfi_def_cfa_register 7
 769 0006 021C     		mov	r2, r0
 770 0008 FB1D     		add	r3, r7, #7
 771 000a 1A70     		strb	r2, [r3]
 970:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 772              		.loc 1 970 0
 773 000c 034A     		ldr	r2, .L52
 774 000e FB1D     		add	r3, r7, #7
 775 0010 1B78     		ldrb	r3, [r3]
 776 0012 1370     		strb	r3, [r2]
 971:.\Generated_Source\PSoC4/UART_1.c ****     }
 777              		.loc 1 971 0
 778 0014 BD46     		mov	sp, r7
 779 0016 02B0     		add	sp, sp, #8
 780              		@ sp needed
 781 0018 80BD     		pop	{r7, pc}
 782              	.L53:
 783 001a C046     		.align	2
 784              	.L52:
 785 001c 80000F40 		.word	1074724992
 786              		.cfi_endproc
 787              	.LFE18:
 788              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 789              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 790              		.align	2
 791              		.global	UART_1_WriteTxData
 792              		.code	16
 793              		.thumb_func
 794              		.type	UART_1_WriteTxData, %function
 795              	UART_1_WriteTxData:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 32


 796              	.LFB19:
 972:.\Generated_Source\PSoC4/UART_1.c **** 
 973:.\Generated_Source\PSoC4/UART_1.c **** 
 974:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 975:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_WriteTxData
 976:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 977:.\Generated_Source\PSoC4/UART_1.c ****     *
 978:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 979:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980:.\Generated_Source\PSoC4/UART_1.c ****     *  bus is available. WriteTxData sends a byte without checking for buffer room
 981:.\Generated_Source\PSoC4/UART_1.c ****     *  or status. It is up to the user to separately check status.
 982:.\Generated_Source\PSoC4/UART_1.c ****     *
 983:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 984:.\Generated_Source\PSoC4/UART_1.c ****     *  TXDataByte: byte of data to place in the transmit FIFO
 985:.\Generated_Source\PSoC4/UART_1.c ****     *
 986:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 987:.\Generated_Source\PSoC4/UART_1.c ****     * void
 988:.\Generated_Source\PSoC4/UART_1.c ****     *
 989:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 990:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 991:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 992:.\Generated_Source\PSoC4/UART_1.c ****     *    incremented after each byte saved to buffer.
 993:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 994:.\Generated_Source\PSoC4/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 995:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 996:.\Generated_Source\PSoC4/UART_1.c ****     *    initialized.
 997:.\Generated_Source\PSoC4/UART_1.c ****     *
 998:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 999:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1000:.\Generated_Source\PSoC4/UART_1.c ****     *
1001:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1002:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
1003:.\Generated_Source\PSoC4/UART_1.c ****     {
 797              		.loc 1 1003 0
 798              		.cfi_startproc
 799 0000 80B5     		push	{r7, lr}
 800              		.cfi_def_cfa_offset 8
 801              		.cfi_offset 7, -8
 802              		.cfi_offset 14, -4
 803 0002 82B0     		sub	sp, sp, #8
 804              		.cfi_def_cfa_offset 16
 805 0004 00AF     		add	r7, sp, #0
 806              		.cfi_def_cfa_register 7
 807 0006 021C     		mov	r2, r0
 808 0008 FB1D     		add	r3, r7, #7
 809 000a 1A70     		strb	r2, [r3]
1004:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1005:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 810              		.loc 1 1005 0
 811 000c 054B     		ldr	r3, .L56
 812 000e 1B78     		ldrb	r3, [r3]
 813 0010 002B     		cmp	r3, #0
 814 0012 03D0     		beq	.L54
1006:.\Generated_Source\PSoC4/UART_1.c ****         {
1007:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1008:.\Generated_Source\PSoC4/UART_1.c **** 
1009:.\Generated_Source\PSoC4/UART_1.c ****                 /* Disable Tx interrupt. */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 33


1010:.\Generated_Source\PSoC4/UART_1.c ****                 /* Protect variables that could change on interrupt. */
1011:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1012:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_DisableTxInt();
1013:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1014:.\Generated_Source\PSoC4/UART_1.c **** 
1015:.\Generated_Source\PSoC4/UART_1.c ****                 if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
1016:.\Generated_Source\PSoC4/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1017:.\Generated_Source\PSoC4/UART_1.c ****                 {
1018:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add directly to the FIFO. */
1019:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1020:.\Generated_Source\PSoC4/UART_1.c ****                 }
1021:.\Generated_Source\PSoC4/UART_1.c ****                 else
1022:.\Generated_Source\PSoC4/UART_1.c ****                 {
1023:.\Generated_Source\PSoC4/UART_1.c ****                     if(UART_1_txBufferWrite >= UART_1_TXBUFFERSIZE)
1024:.\Generated_Source\PSoC4/UART_1.c ****                     {
1025:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_txBufferWrite = 0u;
1026:.\Generated_Source\PSoC4/UART_1.c ****                     }
1027:.\Generated_Source\PSoC4/UART_1.c **** 
1028:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
1029:.\Generated_Source\PSoC4/UART_1.c **** 
1030:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add to the software buffer. */
1031:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite++;
1032:.\Generated_Source\PSoC4/UART_1.c **** 
1033:.\Generated_Source\PSoC4/UART_1.c ****                 }
1034:.\Generated_Source\PSoC4/UART_1.c **** 
1035:.\Generated_Source\PSoC4/UART_1.c ****                 /* Enable Tx interrupt. */
1036:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1037:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_EnableTxInt();
1038:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1039:.\Generated_Source\PSoC4/UART_1.c **** 
1040:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1041:.\Generated_Source\PSoC4/UART_1.c **** 
1042:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
1043:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 815              		.loc 1 1043 0
 816 0014 044A     		ldr	r2, .L56+4
 817 0016 FB1D     		add	r3, r7, #7
 818 0018 1B78     		ldrb	r3, [r3]
 819 001a 1370     		strb	r3, [r2]
 820              	.L54:
1044:.\Generated_Source\PSoC4/UART_1.c **** 
1045:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1046:.\Generated_Source\PSoC4/UART_1.c ****         }
1047:.\Generated_Source\PSoC4/UART_1.c ****     }
 821              		.loc 1 1047 0
 822 001c BD46     		mov	sp, r7
 823 001e 02B0     		add	sp, sp, #8
 824              		@ sp needed
 825 0020 80BD     		pop	{r7, pc}
 826              	.L57:
 827 0022 C046     		.align	2
 828              	.L56:
 829 0024 00000000 		.word	UART_1_initVar
 830 0028 40000F40 		.word	1074724928
 831              		.cfi_endproc
 832              	.LFE19:
 833              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 34


 834              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 835              		.align	2
 836              		.global	UART_1_ReadTxStatus
 837              		.code	16
 838              		.thumb_func
 839              		.type	UART_1_ReadTxStatus, %function
 840              	UART_1_ReadTxStatus:
 841              	.LFB20:
1048:.\Generated_Source\PSoC4/UART_1.c **** 
1049:.\Generated_Source\PSoC4/UART_1.c **** 
1050:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1051:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
1052:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1053:.\Generated_Source\PSoC4/UART_1.c ****     *
1054:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1055:.\Generated_Source\PSoC4/UART_1.c ****     *  Read the status register for the component
1056:.\Generated_Source\PSoC4/UART_1.c ****     *
1057:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1058:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1059:.\Generated_Source\PSoC4/UART_1.c ****     *
1060:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1061:.\Generated_Source\PSoC4/UART_1.c ****     *  Contents of the status register
1062:.\Generated_Source\PSoC4/UART_1.c ****     *
1063:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1064:.\Generated_Source\PSoC4/UART_1.c ****     *  This function reads the status register which is clear on read. It is up to
1065:.\Generated_Source\PSoC4/UART_1.c ****     *  the user to handle all bits in this return value accordingly, even if the bit
1066:.\Generated_Source\PSoC4/UART_1.c ****     *  was not enabled as an interrupt source the event happened and must be handled
1067:.\Generated_Source\PSoC4/UART_1.c ****     *  accordingly.
1068:.\Generated_Source\PSoC4/UART_1.c ****     *
1069:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1070:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1071:.\Generated_Source\PSoC4/UART_1.c ****     {
 842              		.loc 1 1071 0
 843              		.cfi_startproc
 844 0000 80B5     		push	{r7, lr}
 845              		.cfi_def_cfa_offset 8
 846              		.cfi_offset 7, -8
 847              		.cfi_offset 14, -4
 848 0002 00AF     		add	r7, sp, #0
 849              		.cfi_def_cfa_register 7
1072:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 850              		.loc 1 1072 0
 851 0004 024B     		ldr	r3, .L60
 852 0006 1B78     		ldrb	r3, [r3]
 853 0008 DBB2     		uxtb	r3, r3
1073:.\Generated_Source\PSoC4/UART_1.c ****     }
 854              		.loc 1 1073 0
 855 000a 181C     		mov	r0, r3
 856 000c BD46     		mov	sp, r7
 857              		@ sp needed
 858 000e 80BD     		pop	{r7, pc}
 859              	.L61:
 860              		.align	2
 861              	.L60:
 862 0010 60000F40 		.word	1074724960
 863              		.cfi_endproc
 864              	.LFE20:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 35


 865              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 866              		.section	.text.UART_1_PutChar,"ax",%progbits
 867              		.align	2
 868              		.global	UART_1_PutChar
 869              		.code	16
 870              		.thumb_func
 871              		.type	UART_1_PutChar, %function
 872              	UART_1_PutChar:
 873              	.LFB21:
1074:.\Generated_Source\PSoC4/UART_1.c **** 
1075:.\Generated_Source\PSoC4/UART_1.c **** 
1076:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1077:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutChar
1078:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1079:.\Generated_Source\PSoC4/UART_1.c ****     *
1080:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1081:.\Generated_Source\PSoC4/UART_1.c ****     *  Wait to send byte until TX register or buffer has room.
1082:.\Generated_Source\PSoC4/UART_1.c ****     *
1083:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1084:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: The 8-bit data value to send across the UART.
1085:.\Generated_Source\PSoC4/UART_1.c ****     *
1086:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1087:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1088:.\Generated_Source\PSoC4/UART_1.c ****     *
1089:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1090:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1091:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1092:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1093:.\Generated_Source\PSoC4/UART_1.c ****     *     saved to buffer.
1094:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1095:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer.
1096:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1097:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1098:.\Generated_Source\PSoC4/UART_1.c ****     *
1099:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1100:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1101:.\Generated_Source\PSoC4/UART_1.c ****     *
1102:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1103:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1104:.\Generated_Source\PSoC4/UART_1.c ****     *
1105:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1106:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1107:.\Generated_Source\PSoC4/UART_1.c ****     {
 874              		.loc 1 1107 0
 875              		.cfi_startproc
 876 0000 80B5     		push	{r7, lr}
 877              		.cfi_def_cfa_offset 8
 878              		.cfi_offset 7, -8
 879              		.cfi_offset 14, -4
 880 0002 82B0     		sub	sp, sp, #8
 881              		.cfi_def_cfa_offset 16
 882 0004 00AF     		add	r7, sp, #0
 883              		.cfi_def_cfa_register 7
 884 0006 021C     		mov	r2, r0
 885 0008 FB1D     		add	r3, r7, #7
 886 000a 1A70     		strb	r2, [r3]
1108:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 36


1109:.\Generated_Source\PSoC4/UART_1.c ****                 /* The temporary output pointer is used since it takes two instructions
1110:.\Generated_Source\PSoC4/UART_1.c ****                 *  to increment with a wrap, and we can't risk doing that with the real
1111:.\Generated_Source\PSoC4/UART_1.c ****                 *  pointer and getting an interrupt in between instructions.
1112:.\Generated_Source\PSoC4/UART_1.c ****                 */
1113:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 loc_txBufferWrite;
1114:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 loc_txBufferRead;
1115:.\Generated_Source\PSoC4/UART_1.c **** 
1116:.\Generated_Source\PSoC4/UART_1.c ****                 do{
1117:.\Generated_Source\PSoC4/UART_1.c ****                     /* Block if software buffer is full, so we don't overwrite. */
1118:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1119:.\Generated_Source\PSoC4/UART_1.c ****                         /* Disable TX interrupt to protect variables that could change on interrupt
1120:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1121:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1122:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferWrite = UART_1_txBufferWrite;
1123:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferRead = UART_1_txBufferRead;
1124:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1125:.\Generated_Source\PSoC4/UART_1.c ****                         /* Enable interrupt to continue transmission */
1126:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1127:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1128:.\Generated_Source\PSoC4/UART_1.c ****                 }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBuffe
1129:.\Generated_Source\PSoC4/UART_1.c ****                                         ((loc_txBufferWrite - loc_txBufferRead) ==
1130:.\Generated_Source\PSoC4/UART_1.c ****                                         (uint8)(UART_1_TXBUFFERSIZE - 1u)) );
1131:.\Generated_Source\PSoC4/UART_1.c **** 
1132:.\Generated_Source\PSoC4/UART_1.c ****                 if( (loc_txBufferRead == loc_txBufferWrite) &&
1133:.\Generated_Source\PSoC4/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1134:.\Generated_Source\PSoC4/UART_1.c ****                 {
1135:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add directly to the FIFO. */
1136:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1137:.\Generated_Source\PSoC4/UART_1.c ****                 }
1138:.\Generated_Source\PSoC4/UART_1.c ****                 else
1139:.\Generated_Source\PSoC4/UART_1.c ****                 {
1140:.\Generated_Source\PSoC4/UART_1.c ****                     if(loc_txBufferWrite >= UART_1_TXBUFFERSIZE)
1141:.\Generated_Source\PSoC4/UART_1.c ****                     {
1142:.\Generated_Source\PSoC4/UART_1.c ****                         loc_txBufferWrite = 0u;
1143:.\Generated_Source\PSoC4/UART_1.c ****                     }
1144:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add to the software buffer. */
1145:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBuffer[loc_txBufferWrite] = txDataByte;
1146:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferWrite++;
1147:.\Generated_Source\PSoC4/UART_1.c **** 
1148:.\Generated_Source\PSoC4/UART_1.c ****                     /* Finally, update the real output pointer */
1149:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1150:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1151:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1152:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite = loc_txBufferWrite;
1153:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1154:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1155:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1156:.\Generated_Source\PSoC4/UART_1.c ****                 }
1157:.\Generated_Source\PSoC4/UART_1.c **** 
1158:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1159:.\Generated_Source\PSoC4/UART_1.c **** 
1160:.\Generated_Source\PSoC4/UART_1.c ****                 while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 887              		.loc 1 1160 0
 888 000c C046     		mov	r8, r8
 889              	.L63:
 890              		.loc 1 1160 0 is_stmt 0 discriminator 1
 891 000e 074B     		ldr	r3, .L64
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 37


 892 0010 1B78     		ldrb	r3, [r3]
 893 0012 DBB2     		uxtb	r3, r3
 894 0014 1A1C     		mov	r2, r3
 895 0016 0423     		mov	r3, #4
 896 0018 1340     		and	r3, r2
 897 001a F8D1     		bne	.L63
1161:.\Generated_Source\PSoC4/UART_1.c ****                 {
1162:.\Generated_Source\PSoC4/UART_1.c ****                     ; /* Wait for room in the FIFO. */
1163:.\Generated_Source\PSoC4/UART_1.c ****                 }
1164:.\Generated_Source\PSoC4/UART_1.c **** 
1165:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
1166:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 898              		.loc 1 1166 0 is_stmt 1
 899 001c 044A     		ldr	r2, .L64+4
 900 001e FB1D     		add	r3, r7, #7
 901 0020 1B78     		ldrb	r3, [r3]
 902 0022 1370     		strb	r3, [r2]
1167:.\Generated_Source\PSoC4/UART_1.c **** 
1168:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1169:.\Generated_Source\PSoC4/UART_1.c ****     }
 903              		.loc 1 1169 0
 904 0024 BD46     		mov	sp, r7
 905 0026 02B0     		add	sp, sp, #8
 906              		@ sp needed
 907 0028 80BD     		pop	{r7, pc}
 908              	.L65:
 909 002a C046     		.align	2
 910              	.L64:
 911 002c 60000F40 		.word	1074724960
 912 0030 40000F40 		.word	1074724928
 913              		.cfi_endproc
 914              	.LFE21:
 915              		.size	UART_1_PutChar, .-UART_1_PutChar
 916              		.section	.text.UART_1_PutString,"ax",%progbits
 917              		.align	2
 918              		.global	UART_1_PutString
 919              		.code	16
 920              		.thumb_func
 921              		.type	UART_1_PutString, %function
 922              	UART_1_PutString:
 923              	.LFB22:
1170:.\Generated_Source\PSoC4/UART_1.c **** 
1171:.\Generated_Source\PSoC4/UART_1.c **** 
1172:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1173:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutString
1174:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1175:.\Generated_Source\PSoC4/UART_1.c ****     *
1176:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1177:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178:.\Generated_Source\PSoC4/UART_1.c ****     *
1179:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1180:.\Generated_Source\PSoC4/UART_1.c ****     *  string: char pointer to character string of Data to Send.
1181:.\Generated_Source\PSoC4/UART_1.c ****     *
1182:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1183:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1184:.\Generated_Source\PSoC4/UART_1.c ****     *
1185:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 38


1186:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1187:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1188:.\Generated_Source\PSoC4/UART_1.c ****     *
1189:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1190:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1191:.\Generated_Source\PSoC4/UART_1.c ****     *
1192:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1193:.\Generated_Source\PSoC4/UART_1.c ****     *  This function will block if there is not enough memory to place the whole
1194:.\Generated_Source\PSoC4/UART_1.c ****     *  string, it will block until the entire string has been written to the
1195:.\Generated_Source\PSoC4/UART_1.c ****     *  transmit buffer.
1196:.\Generated_Source\PSoC4/UART_1.c ****     *
1197:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1198:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1199:.\Generated_Source\PSoC4/UART_1.c ****     {
 924              		.loc 1 1199 0
 925              		.cfi_startproc
 926 0000 80B5     		push	{r7, lr}
 927              		.cfi_def_cfa_offset 8
 928              		.cfi_offset 7, -8
 929              		.cfi_offset 14, -4
 930 0002 84B0     		sub	sp, sp, #16
 931              		.cfi_def_cfa_offset 24
 932 0004 00AF     		add	r7, sp, #0
 933              		.cfi_def_cfa_register 7
 934 0006 7860     		str	r0, [r7, #4]
1200:.\Generated_Source\PSoC4/UART_1.c ****         uint16 buf_index = 0u;
 935              		.loc 1 1200 0
 936 0008 0E23     		mov	r3, #14
 937 000a FB18     		add	r3, r7, r3
 938 000c 0022     		mov	r2, #0
 939 000e 1A80     		strh	r2, [r3]
1201:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1202:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 940              		.loc 1 1202 0
 941 0010 0F4B     		ldr	r3, .L70
 942 0012 1B78     		ldrb	r3, [r3]
 943 0014 002B     		cmp	r3, #0
 944 0016 18D0     		beq	.L66
1203:.\Generated_Source\PSoC4/UART_1.c ****         {
1204:.\Generated_Source\PSoC4/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent*/
1205:.\Generated_Source\PSoC4/UART_1.c ****             while(string[buf_index] != (char8)0)
 945              		.loc 1 1205 0
 946 0018 0FE0     		b	.L68
 947              	.L69:
1206:.\Generated_Source\PSoC4/UART_1.c ****             {
1207:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar((uint8)string[buf_index]);
 948              		.loc 1 1207 0
 949 001a 0E23     		mov	r3, #14
 950 001c FB18     		add	r3, r7, r3
 951 001e 1B88     		ldrh	r3, [r3]
 952 0020 7A68     		ldr	r2, [r7, #4]
 953 0022 D318     		add	r3, r2, r3
 954 0024 1B78     		ldrb	r3, [r3]
 955 0026 181C     		mov	r0, r3
 956 0028 FFF7FEFF 		bl	UART_1_PutChar
1208:.\Generated_Source\PSoC4/UART_1.c ****                 buf_index++;
 957              		.loc 1 1208 0
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 39


 958 002c 0E23     		mov	r3, #14
 959 002e FB18     		add	r3, r7, r3
 960 0030 1A88     		ldrh	r2, [r3]
 961 0032 0E23     		mov	r3, #14
 962 0034 FB18     		add	r3, r7, r3
 963 0036 0132     		add	r2, r2, #1
 964 0038 1A80     		strh	r2, [r3]
 965              	.L68:
1205:.\Generated_Source\PSoC4/UART_1.c ****             {
 966              		.loc 1 1205 0
 967 003a 0E23     		mov	r3, #14
 968 003c FB18     		add	r3, r7, r3
 969 003e 1B88     		ldrh	r3, [r3]
 970 0040 7A68     		ldr	r2, [r7, #4]
 971 0042 D318     		add	r3, r2, r3
 972 0044 1B78     		ldrb	r3, [r3]
 973 0046 002B     		cmp	r3, #0
 974 0048 E7D1     		bne	.L69
 975              	.L66:
1209:.\Generated_Source\PSoC4/UART_1.c ****             }
1210:.\Generated_Source\PSoC4/UART_1.c ****         }
1211:.\Generated_Source\PSoC4/UART_1.c ****     }
 976              		.loc 1 1211 0
 977 004a BD46     		mov	sp, r7
 978 004c 04B0     		add	sp, sp, #16
 979              		@ sp needed
 980 004e 80BD     		pop	{r7, pc}
 981              	.L71:
 982              		.align	2
 983              	.L70:
 984 0050 00000000 		.word	UART_1_initVar
 985              		.cfi_endproc
 986              	.LFE22:
 987              		.size	UART_1_PutString, .-UART_1_PutString
 988              		.section	.text.UART_1_PutArray,"ax",%progbits
 989              		.align	2
 990              		.global	UART_1_PutArray
 991              		.code	16
 992              		.thumb_func
 993              		.type	UART_1_PutArray, %function
 994              	UART_1_PutArray:
 995              	.LFB23:
1212:.\Generated_Source\PSoC4/UART_1.c **** 
1213:.\Generated_Source\PSoC4/UART_1.c **** 
1214:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1215:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutArray
1216:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1217:.\Generated_Source\PSoC4/UART_1.c ****     *
1218:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1219:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220:.\Generated_Source\PSoC4/UART_1.c ****     *
1221:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1222:.\Generated_Source\PSoC4/UART_1.c ****     *  string: Address of the memory array residing in RAM or ROM.
1223:.\Generated_Source\PSoC4/UART_1.c ****     *  byteCount: Number of Bytes to be transmitted.
1224:.\Generated_Source\PSoC4/UART_1.c ****     *
1225:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1226:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 40


1227:.\Generated_Source\PSoC4/UART_1.c ****     *
1228:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1229:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1230:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1231:.\Generated_Source\PSoC4/UART_1.c ****     *
1232:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1233:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1234:.\Generated_Source\PSoC4/UART_1.c ****     *
1235:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1236:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1237:.\Generated_Source\PSoC4/UART_1.c ****                                                                     
1238:.\Generated_Source\PSoC4/UART_1.c ****     {
 996              		.loc 1 1238 0
 997              		.cfi_startproc
 998 0000 80B5     		push	{r7, lr}
 999              		.cfi_def_cfa_offset 8
 1000              		.cfi_offset 7, -8
 1001              		.cfi_offset 14, -4
 1002 0002 84B0     		sub	sp, sp, #16
 1003              		.cfi_def_cfa_offset 24
 1004 0004 00AF     		add	r7, sp, #0
 1005              		.cfi_def_cfa_register 7
 1006 0006 7860     		str	r0, [r7, #4]
 1007 0008 0A1C     		mov	r2, r1
 1008 000a FB1C     		add	r3, r7, #3
 1009 000c 1A70     		strb	r2, [r3]
1239:.\Generated_Source\PSoC4/UART_1.c ****         uint8 buf_index = 0u;
 1010              		.loc 1 1239 0
 1011 000e 0F23     		mov	r3, #15
 1012 0010 FB18     		add	r3, r7, r3
 1013 0012 0022     		mov	r2, #0
 1014 0014 1A70     		strb	r2, [r3]
1240:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1241:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1015              		.loc 1 1241 0
 1016 0016 0F4B     		ldr	r3, .L75
 1017 0018 1B78     		ldrb	r3, [r3]
 1018 001a 002B     		cmp	r3, #0
 1019 001c 16D0     		beq	.L72
 1020              	.L74:
1242:.\Generated_Source\PSoC4/UART_1.c ****         {
1243:.\Generated_Source\PSoC4/UART_1.c ****             do
1244:.\Generated_Source\PSoC4/UART_1.c ****             {
1245:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar(string[buf_index]);
 1021              		.loc 1 1245 0 discriminator 1
 1022 001e 0F23     		mov	r3, #15
 1023 0020 FB18     		add	r3, r7, r3
 1024 0022 1B78     		ldrb	r3, [r3]
 1025 0024 7A68     		ldr	r2, [r7, #4]
 1026 0026 D318     		add	r3, r2, r3
 1027 0028 1B78     		ldrb	r3, [r3]
 1028 002a 181C     		mov	r0, r3
 1029 002c FFF7FEFF 		bl	UART_1_PutChar
1246:.\Generated_Source\PSoC4/UART_1.c ****                 buf_index++;
 1030              		.loc 1 1246 0 discriminator 1
 1031 0030 0F23     		mov	r3, #15
 1032 0032 FB18     		add	r3, r7, r3
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 41


 1033 0034 1A78     		ldrb	r2, [r3]
 1034 0036 0F23     		mov	r3, #15
 1035 0038 FB18     		add	r3, r7, r3
 1036 003a 0132     		add	r2, r2, #1
 1037 003c 1A70     		strb	r2, [r3]
1247:.\Generated_Source\PSoC4/UART_1.c ****             }while(buf_index < byteCount);
 1038              		.loc 1 1247 0 discriminator 1
 1039 003e 0F23     		mov	r3, #15
 1040 0040 FA18     		add	r2, r7, r3
 1041 0042 FB1C     		add	r3, r7, #3
 1042 0044 1278     		ldrb	r2, [r2]
 1043 0046 1B78     		ldrb	r3, [r3]
 1044 0048 9A42     		cmp	r2, r3
 1045 004a E8D3     		bcc	.L74
 1046              	.L72:
1248:.\Generated_Source\PSoC4/UART_1.c ****         }
1249:.\Generated_Source\PSoC4/UART_1.c ****     }
 1047              		.loc 1 1249 0
 1048 004c BD46     		mov	sp, r7
 1049 004e 04B0     		add	sp, sp, #16
 1050              		@ sp needed
 1051 0050 80BD     		pop	{r7, pc}
 1052              	.L76:
 1053 0052 C046     		.align	2
 1054              	.L75:
 1055 0054 00000000 		.word	UART_1_initVar
 1056              		.cfi_endproc
 1057              	.LFE23:
 1058              		.size	UART_1_PutArray, .-UART_1_PutArray
 1059              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 1060              		.align	2
 1061              		.global	UART_1_PutCRLF
 1062              		.code	16
 1063              		.thumb_func
 1064              		.type	UART_1_PutCRLF, %function
 1065              	UART_1_PutCRLF:
 1066              	.LFB24:
1250:.\Generated_Source\PSoC4/UART_1.c **** 
1251:.\Generated_Source\PSoC4/UART_1.c **** 
1252:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1253:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutCRLF
1254:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1255:.\Generated_Source\PSoC4/UART_1.c ****     *
1256:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1257:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a character and then carriage return and line feed.
1258:.\Generated_Source\PSoC4/UART_1.c ****     *
1259:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1260:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: uint8 Character to send.
1261:.\Generated_Source\PSoC4/UART_1.c ****     *
1262:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1263:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1264:.\Generated_Source\PSoC4/UART_1.c ****     *
1265:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1266:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1267:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1268:.\Generated_Source\PSoC4/UART_1.c ****     *
1269:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 42


1270:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1271:.\Generated_Source\PSoC4/UART_1.c ****     *
1272:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1274:.\Generated_Source\PSoC4/UART_1.c ****     {
 1067              		.loc 1 1274 0
 1068              		.cfi_startproc
 1069 0000 80B5     		push	{r7, lr}
 1070              		.cfi_def_cfa_offset 8
 1071              		.cfi_offset 7, -8
 1072              		.cfi_offset 14, -4
 1073 0002 82B0     		sub	sp, sp, #8
 1074              		.cfi_def_cfa_offset 16
 1075 0004 00AF     		add	r7, sp, #0
 1076              		.cfi_def_cfa_register 7
 1077 0006 021C     		mov	r2, r0
 1078 0008 FB1D     		add	r3, r7, #7
 1079 000a 1A70     		strb	r2, [r3]
1275:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1276:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1080              		.loc 1 1276 0
 1081 000c 084B     		ldr	r3, .L79
 1082 000e 1B78     		ldrb	r3, [r3]
 1083 0010 002B     		cmp	r3, #0
 1084 0012 0AD0     		beq	.L77
1277:.\Generated_Source\PSoC4/UART_1.c ****         {
1278:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(txDataByte);
 1085              		.loc 1 1278 0
 1086 0014 FB1D     		add	r3, r7, #7
 1087 0016 1B78     		ldrb	r3, [r3]
 1088 0018 181C     		mov	r0, r3
 1089 001a FFF7FEFF 		bl	UART_1_PutChar
1279:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Du);
 1090              		.loc 1 1279 0
 1091 001e 0D20     		mov	r0, #13
 1092 0020 FFF7FEFF 		bl	UART_1_PutChar
1280:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Au);
 1093              		.loc 1 1280 0
 1094 0024 0A20     		mov	r0, #10
 1095 0026 FFF7FEFF 		bl	UART_1_PutChar
 1096              	.L77:
1281:.\Generated_Source\PSoC4/UART_1.c ****         }
1282:.\Generated_Source\PSoC4/UART_1.c ****     }
 1097              		.loc 1 1282 0
 1098 002a BD46     		mov	sp, r7
 1099 002c 02B0     		add	sp, sp, #8
 1100              		@ sp needed
 1101 002e 80BD     		pop	{r7, pc}
 1102              	.L80:
 1103              		.align	2
 1104              	.L79:
 1105 0030 00000000 		.word	UART_1_initVar
 1106              		.cfi_endproc
 1107              	.LFE24:
 1108              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 1109              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 1110              		.align	2
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 43


 1111              		.global	UART_1_GetTxBufferSize
 1112              		.code	16
 1113              		.thumb_func
 1114              		.type	UART_1_GetTxBufferSize, %function
 1115              	UART_1_GetTxBufferSize:
 1116              	.LFB25:
1283:.\Generated_Source\PSoC4/UART_1.c **** 
1284:.\Generated_Source\PSoC4/UART_1.c **** 
1285:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1286:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1287:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1288:.\Generated_Source\PSoC4/UART_1.c ****     *
1289:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1290:.\Generated_Source\PSoC4/UART_1.c ****     *  Determine the amount of space left in the TX buffer and return the count in
1291:.\Generated_Source\PSoC4/UART_1.c ****     *  bytes
1292:.\Generated_Source\PSoC4/UART_1.c ****     *
1293:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1294:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1295:.\Generated_Source\PSoC4/UART_1.c ****     *
1296:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1297:.\Generated_Source\PSoC4/UART_1.c ****     *  Integer count of the number of bytes left in the TX buffer
1298:.\Generated_Source\PSoC4/UART_1.c ****     *
1299:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1300:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1301:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1302:.\Generated_Source\PSoC4/UART_1.c ****     *
1303:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1304:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1305:.\Generated_Source\PSoC4/UART_1.c ****     *
1306:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1307:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1308:.\Generated_Source\PSoC4/UART_1.c ****     *
1309:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1310:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1311:.\Generated_Source\PSoC4/UART_1.c ****                                                             
1312:.\Generated_Source\PSoC4/UART_1.c ****     {
 1117              		.loc 1 1312 0
 1118              		.cfi_startproc
 1119 0000 80B5     		push	{r7, lr}
 1120              		.cfi_def_cfa_offset 8
 1121              		.cfi_offset 7, -8
 1122              		.cfi_offset 14, -4
 1123 0002 82B0     		sub	sp, sp, #8
 1124              		.cfi_def_cfa_offset 16
 1125 0004 00AF     		add	r7, sp, #0
 1126              		.cfi_def_cfa_register 7
1313:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
1314:.\Generated_Source\PSoC4/UART_1.c **** 
1315:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1316:.\Generated_Source\PSoC4/UART_1.c **** 
1317:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Tx interrupt. */
1318:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
1319:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1320:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableTxInt();
1321:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1322:.\Generated_Source\PSoC4/UART_1.c **** 
1323:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_txBufferRead == UART_1_txBufferWrite)
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 44


1324:.\Generated_Source\PSoC4/UART_1.c ****             {
1325:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
1326:.\Generated_Source\PSoC4/UART_1.c ****             }
1327:.\Generated_Source\PSoC4/UART_1.c ****             else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1328:.\Generated_Source\PSoC4/UART_1.c ****             {
1329:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1330:.\Generated_Source\PSoC4/UART_1.c ****             }
1331:.\Generated_Source\PSoC4/UART_1.c ****             else
1332:.\Generated_Source\PSoC4/UART_1.c ****             {
1333:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_TXBUFFERSIZE - UART_1_txBufferRead) + UART_1_txBufferWrite;
1334:.\Generated_Source\PSoC4/UART_1.c ****             }
1335:.\Generated_Source\PSoC4/UART_1.c **** 
1336:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Tx interrupt. */
1337:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1338:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableTxInt();
1339:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1340:.\Generated_Source\PSoC4/UART_1.c **** 
1341:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1342:.\Generated_Source\PSoC4/UART_1.c **** 
1343:.\Generated_Source\PSoC4/UART_1.c ****             size = UART_1_TXSTATUS_REG;
 1127              		.loc 1 1343 0
 1128 0006 0F4A     		ldr	r2, .L86
 1129 0008 FB1D     		add	r3, r7, #7
 1130 000a 1278     		ldrb	r2, [r2]
 1131 000c 1A70     		strb	r2, [r3]
1344:.\Generated_Source\PSoC4/UART_1.c **** 
1345:.\Generated_Source\PSoC4/UART_1.c ****             /* Is the fifo is full. */
1346:.\Generated_Source\PSoC4/UART_1.c ****             if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 1132              		.loc 1 1346 0
 1133 000e FB1D     		add	r3, r7, #7
 1134 0010 1B78     		ldrb	r3, [r3]
 1135 0012 0422     		mov	r2, #4
 1136 0014 1340     		and	r3, r2
 1137 0016 03D0     		beq	.L82
1347:.\Generated_Source\PSoC4/UART_1.c ****             {
1348:.\Generated_Source\PSoC4/UART_1.c ****                 size = UART_1_FIFO_LENGTH;
 1138              		.loc 1 1348 0
 1139 0018 FB1D     		add	r3, r7, #7
 1140 001a 0422     		mov	r2, #4
 1141 001c 1A70     		strb	r2, [r3]
 1142 001e 0BE0     		b	.L83
 1143              	.L82:
1349:.\Generated_Source\PSoC4/UART_1.c ****             }
1350:.\Generated_Source\PSoC4/UART_1.c ****             else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 1144              		.loc 1 1350 0
 1145 0020 FB1D     		add	r3, r7, #7
 1146 0022 1B78     		ldrb	r3, [r3]
 1147 0024 0222     		mov	r2, #2
 1148 0026 1340     		and	r3, r2
 1149 0028 03D0     		beq	.L84
1351:.\Generated_Source\PSoC4/UART_1.c ****             {
1352:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
 1150              		.loc 1 1352 0
 1151 002a FB1D     		add	r3, r7, #7
 1152 002c 0022     		mov	r2, #0
 1153 002e 1A70     		strb	r2, [r3]
 1154 0030 02E0     		b	.L83
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 45


 1155              	.L84:
1353:.\Generated_Source\PSoC4/UART_1.c ****             }
1354:.\Generated_Source\PSoC4/UART_1.c ****             else
1355:.\Generated_Source\PSoC4/UART_1.c ****             {
1356:.\Generated_Source\PSoC4/UART_1.c ****                 /* We only know there is data in the fifo. */
1357:.\Generated_Source\PSoC4/UART_1.c ****                 size = 1u;
 1156              		.loc 1 1357 0
 1157 0032 FB1D     		add	r3, r7, #7
 1158 0034 0122     		mov	r2, #1
 1159 0036 1A70     		strb	r2, [r3]
 1160              	.L83:
1358:.\Generated_Source\PSoC4/UART_1.c ****             }
1359:.\Generated_Source\PSoC4/UART_1.c **** 
1360:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1361:.\Generated_Source\PSoC4/UART_1.c **** 
1362:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 1161              		.loc 1 1362 0
 1162 0038 FB1D     		add	r3, r7, #7
 1163 003a 1B78     		ldrb	r3, [r3]
1363:.\Generated_Source\PSoC4/UART_1.c ****     }
 1164              		.loc 1 1363 0
 1165 003c 181C     		mov	r0, r3
 1166 003e BD46     		mov	sp, r7
 1167 0040 02B0     		add	sp, sp, #8
 1168              		@ sp needed
 1169 0042 80BD     		pop	{r7, pc}
 1170              	.L87:
 1171              		.align	2
 1172              	.L86:
 1173 0044 60000F40 		.word	1074724960
 1174              		.cfi_endproc
 1175              	.LFE25:
 1176              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 1177              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 1178              		.align	2
 1179              		.global	UART_1_ClearTxBuffer
 1180              		.code	16
 1181              		.thumb_func
 1182              		.type	UART_1_ClearTxBuffer, %function
 1183              	UART_1_ClearTxBuffer:
 1184              	.LFB26:
1364:.\Generated_Source\PSoC4/UART_1.c **** 
1365:.\Generated_Source\PSoC4/UART_1.c **** 
1366:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1367:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1368:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1369:.\Generated_Source\PSoC4/UART_1.c ****     *
1370:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1371:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373:.\Generated_Source\PSoC4/UART_1.c ****     *
1374:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1375:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1376:.\Generated_Source\PSoC4/UART_1.c ****     *
1377:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1378:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1379:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 46


1380:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1381:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1382:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1383:.\Generated_Source\PSoC4/UART_1.c ****     *
1384:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1385:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1386:.\Generated_Source\PSoC4/UART_1.c ****     *
1387:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1388:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1389:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1390:.\Generated_Source\PSoC4/UART_1.c ****     *  remained in the RAM.
1391:.\Generated_Source\PSoC4/UART_1.c ****     *
1392:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1393:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM buffer will be lost when overwritten.
1394:.\Generated_Source\PSoC4/UART_1.c ****     *
1395:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1396:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1397:.\Generated_Source\PSoC4/UART_1.c ****     {
 1185              		.loc 1 1397 0
 1186              		.cfi_startproc
 1187 0000 90B5     		push	{r4, r7, lr}
 1188              		.cfi_def_cfa_offset 12
 1189              		.cfi_offset 4, -12
 1190              		.cfi_offset 7, -8
 1191              		.cfi_offset 14, -4
 1192 0002 83B0     		sub	sp, sp, #12
 1193              		.cfi_def_cfa_offset 24
 1194 0004 00AF     		add	r7, sp, #0
 1195              		.cfi_def_cfa_register 7
1398:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
1399:.\Generated_Source\PSoC4/UART_1.c **** 
1400:.\Generated_Source\PSoC4/UART_1.c ****         /* Enter critical section */
1401:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 1196              		.loc 1 1401 0
 1197 0006 FC1D     		add	r4, r7, #7
 1198 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 1199 000c 031C     		mov	r3, r0
 1200 000e 2370     		strb	r3, [r4]
1402:.\Generated_Source\PSoC4/UART_1.c ****         /* clear the HW FIFO */
1403:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |=  UART_1_TX_FIFO_CLR;
 1201              		.loc 1 1403 0
 1202 0010 0B4A     		ldr	r2, .L89
 1203 0012 0B4B     		ldr	r3, .L89
 1204 0014 1B78     		ldrb	r3, [r3]
 1205 0016 DBB2     		uxtb	r3, r3
 1206 0018 0121     		mov	r1, #1
 1207 001a 0B43     		orr	r3, r1
 1208 001c DBB2     		uxtb	r3, r3
 1209 001e 1370     		strb	r3, [r2]
1404:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8)~UART_1_TX_FIFO_CLR;
 1210              		.loc 1 1404 0
 1211 0020 074A     		ldr	r2, .L89
 1212 0022 074B     		ldr	r3, .L89
 1213 0024 1B78     		ldrb	r3, [r3]
 1214 0026 DBB2     		uxtb	r3, r3
 1215 0028 0121     		mov	r1, #1
 1216 002a 8B43     		bic	r3, r1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 47


 1217 002c DBB2     		uxtb	r3, r3
 1218 002e 1370     		strb	r3, [r2]
1405:.\Generated_Source\PSoC4/UART_1.c ****         /* Exit critical section */
1406:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 1219              		.loc 1 1406 0
 1220 0030 FB1D     		add	r3, r7, #7
 1221 0032 1B78     		ldrb	r3, [r3]
 1222 0034 181C     		mov	r0, r3
 1223 0036 FFF7FEFF 		bl	CyExitCriticalSection
1407:.\Generated_Source\PSoC4/UART_1.c **** 
1408:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1409:.\Generated_Source\PSoC4/UART_1.c **** 
1410:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Tx interrupt. */
1411:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
1412:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1413:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableTxInt();
1414:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1415:.\Generated_Source\PSoC4/UART_1.c **** 
1416:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferRead = 0u;
1417:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferWrite = 0u;
1418:.\Generated_Source\PSoC4/UART_1.c **** 
1419:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Tx interrupt. */
1420:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1421:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableTxInt();
1422:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1423:.\Generated_Source\PSoC4/UART_1.c **** 
1424:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1425:.\Generated_Source\PSoC4/UART_1.c ****     }
 1224              		.loc 1 1425 0
 1225 003a BD46     		mov	sp, r7
 1226 003c 03B0     		add	sp, sp, #12
 1227              		@ sp needed
 1228 003e 90BD     		pop	{r4, r7, pc}
 1229              	.L90:
 1230              		.align	2
 1231              	.L89:
 1232 0040 90000F40 		.word	1074725008
 1233              		.cfi_endproc
 1234              	.LFE26:
 1235              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 1236              		.section	.text.UART_1_SendBreak,"ax",%progbits
 1237              		.align	2
 1238              		.global	UART_1_SendBreak
 1239              		.code	16
 1240              		.thumb_func
 1241              		.type	UART_1_SendBreak, %function
 1242              	UART_1_SendBreak:
 1243              	.LFB27:
1426:.\Generated_Source\PSoC4/UART_1.c **** 
1427:.\Generated_Source\PSoC4/UART_1.c **** 
1428:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1429:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SendBreak
1430:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1431:.\Generated_Source\PSoC4/UART_1.c ****     *
1432:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1433:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Break command to the UART
1434:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 48


1435:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1436:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8 retMode:  Wait mode,
1437:.\Generated_Source\PSoC4/UART_1.c ****     *   0 - Initialize registers for Break, sends the Break signal and return
1438:.\Generated_Source\PSoC4/UART_1.c ****     *       imediately.
1439:.\Generated_Source\PSoC4/UART_1.c ****     *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440:.\Generated_Source\PSoC4/UART_1.c ****     *       transmission mode then return.
1441:.\Generated_Source\PSoC4/UART_1.c ****     *   2 - Reinitialize registers to normal transmission mode then return.
1442:.\Generated_Source\PSoC4/UART_1.c ****     *   3 - both steps: 0 and 1
1443:.\Generated_Source\PSoC4/UART_1.c ****     *       init registers for Break, send Break signal
1444:.\Generated_Source\PSoC4/UART_1.c ****     *       wait until Break sending is complete, reinit registers to normal
1445:.\Generated_Source\PSoC4/UART_1.c ****     *       transmission mode then return.
1446:.\Generated_Source\PSoC4/UART_1.c ****     *
1447:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1448:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1449:.\Generated_Source\PSoC4/UART_1.c ****     *
1450:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1451:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1452:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1453:.\Generated_Source\PSoC4/UART_1.c ****     *  tx_period - static variable, used for keeping TX period configuration.
1454:.\Generated_Source\PSoC4/UART_1.c ****     *
1455:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1456:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1457:.\Generated_Source\PSoC4/UART_1.c ****     *
1458:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1459:.\Generated_Source\PSoC4/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1460:.\Generated_Source\PSoC4/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1461:.\Generated_Source\PSoC4/UART_1.c ****     *  operation.
1462:.\Generated_Source\PSoC4/UART_1.c ****     *  Trere are 3 variants for this API usage:
1463:.\Generated_Source\PSoC4/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1464:.\Generated_Source\PSoC4/UART_1.c ****     *     configuration returning. Funcition will block CPU untill transmition
1465:.\Generated_Source\PSoC4/UART_1.c ****     *     complete.
1466:.\Generated_Source\PSoC4/UART_1.c ****     *  2) User may want to use bloking time if UART configured to the low speed
1467:.\Generated_Source\PSoC4/UART_1.c ****     *     operation
1468:.\Generated_Source\PSoC4/UART_1.c ****     *     Emample for this case:
1469:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1470:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1471:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1472:.\Generated_Source\PSoC4/UART_1.c ****     *  3) Same to 2) but user may want to init and use the interrupt for complete
1473:.\Generated_Source\PSoC4/UART_1.c ****     *     break operation.
1474:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1475:.\Generated_Source\PSoC4/UART_1.c ****     *     Init TX interrupt whith "TX - On TX Complete" parameter
1476:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1477:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1478:.\Generated_Source\PSoC4/UART_1.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1479:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1480:.\Generated_Source\PSoC4/UART_1.c ****     *
1481:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1482:.\Generated_Source\PSoC4/UART_1.c ****     *   Uses static variable to keep registers configuration.
1483:.\Generated_Source\PSoC4/UART_1.c ****     *
1484:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1485:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1486:.\Generated_Source\PSoC4/UART_1.c ****     {
 1244              		.loc 1 1486 0
 1245              		.cfi_startproc
 1246 0000 80B5     		push	{r7, lr}
 1247              		.cfi_def_cfa_offset 8
 1248              		.cfi_offset 7, -8
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 49


 1249              		.cfi_offset 14, -4
 1250 0002 84B0     		sub	sp, sp, #16
 1251              		.cfi_def_cfa_offset 24
 1252 0004 00AF     		add	r7, sp, #0
 1253              		.cfi_def_cfa_register 7
 1254 0006 021C     		mov	r2, r0
 1255 0008 FB1D     		add	r3, r7, #7
 1256 000a 1A70     		strb	r2, [r3]
1487:.\Generated_Source\PSoC4/UART_1.c **** 
1488:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1489:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1257              		.loc 1 1489 0
 1258 000c 254B     		ldr	r3, .L99
 1259 000e 1B78     		ldrb	r3, [r3]
 1260 0010 002B     		cmp	r3, #0
 1261 0012 43D0     		beq	.L91
 1262              	.LBB2:
1490:.\Generated_Source\PSoC4/UART_1.c ****         {
1491:.\Generated_Source\PSoC4/UART_1.c ****             /*Set the Counter to 13-bits and transmit a 00 byte*/
1492:.\Generated_Source\PSoC4/UART_1.c ****             /*When that is done then reset the counter value back*/
1493:.\Generated_Source\PSoC4/UART_1.c ****             uint8 tmpStat;
1494:.\Generated_Source\PSoC4/UART_1.c **** 
1495:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1496:.\Generated_Source\PSoC4/UART_1.c **** 
1497:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
1498:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT ) )
1499:.\Generated_Source\PSoC4/UART_1.c ****                 {
1500:.\Generated_Source\PSoC4/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
1501:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1502:.\Generated_Source\PSoC4/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1503:.\Generated_Source\PSoC4/UART_1.c ****                     /* Send zeros*/
1504:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
1505:.\Generated_Source\PSoC4/UART_1.c **** 
1506:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit starts*/
1507:.\Generated_Source\PSoC4/UART_1.c ****                     {
1508:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1509:.\Generated_Source\PSoC4/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1510:.\Generated_Source\PSoC4/UART_1.c ****                 }
1511:.\Generated_Source\PSoC4/UART_1.c **** 
1512:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1513:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1514:.\Generated_Source\PSoC4/UART_1.c ****                 {
1515:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit complete*/
1516:.\Generated_Source\PSoC4/UART_1.c ****                     {
1517:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1518:.\Generated_Source\PSoC4/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1519:.\Generated_Source\PSoC4/UART_1.c ****                 }
1520:.\Generated_Source\PSoC4/UART_1.c **** 
1521:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1522:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_REINIT) ||
1523:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1524:.\Generated_Source\PSoC4/UART_1.c ****                 {
1525:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1526:.\Generated_Source\PSoC4/UART_1.c ****                                                   (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1527:.\Generated_Source\PSoC4/UART_1.c ****                 }
1528:.\Generated_Source\PSoC4/UART_1.c **** 
1529:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_HD_ENABLED Full Duplex mode */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 50


1530:.\Generated_Source\PSoC4/UART_1.c **** 
1531:.\Generated_Source\PSoC4/UART_1.c ****                 static uint8 tx_period;
1532:.\Generated_Source\PSoC4/UART_1.c **** 
1533:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
 1263              		.loc 1 1533 0
 1264 0014 FB1D     		add	r3, r7, #7
 1265 0016 1B78     		ldrb	r3, [r3]
 1266 0018 002B     		cmp	r3, #0
 1267 001a 03D0     		beq	.L93
 1268              		.loc 1 1533 0 is_stmt 0 discriminator 1
 1269 001c FB1D     		add	r3, r7, #7
 1270 001e 1B78     		ldrb	r3, [r3]
 1271 0020 032B     		cmp	r3, #3
 1272 0022 15D1     		bne	.L94
 1273              	.L93:
1534:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1535:.\Generated_Source\PSoC4/UART_1.c ****                 {
1536:.\Generated_Source\PSoC4/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex 
1537:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1538:.\Generated_Source\PSoC4/UART_1.c ****                                         (UART_1_PARITY_TYPE_SW != 0u) )
1539:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1540:.\Generated_Source\PSoC4/UART_1.c ****                                                               UART_1_CTRL_HD_SEND_BREAK);
1541:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1542:.\Generated_Source\PSoC4/UART_1.c **** 
1543:.\Generated_Source\PSoC4/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1544:.\Generated_Source\PSoC4/UART_1.c ****                         tx_period = UART_1_TXBITCLKTX_COMPLETE_REG;
 1274              		.loc 1 1544 0 is_stmt 1
 1275 0024 204B     		ldr	r3, .L99+4
 1276 0026 1B78     		ldrb	r3, [r3]
 1277 0028 DAB2     		uxtb	r2, r3
 1278 002a 204B     		ldr	r3, .L99+8
 1279 002c 1A70     		strb	r2, [r3]
1545:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 1280              		.loc 1 1545 0
 1281 002e 1E4B     		ldr	r3, .L99+4
 1282 0030 6722     		mov	r2, #103
 1283 0032 1A70     		strb	r2, [r3]
1546:.\Generated_Source\PSoC4/UART_1.c ****                     #else
1547:.\Generated_Source\PSoC4/UART_1.c ****                         tx_period = UART_1_TXBITCTR_PERIOD_REG;
1548:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1549:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1550:.\Generated_Source\PSoC4/UART_1.c **** 
1551:.\Generated_Source\PSoC4/UART_1.c ****                     /* Send zeros*/
1552:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
 1284              		.loc 1 1552 0
 1285 0034 1E4B     		ldr	r3, .L99+12
 1286 0036 0022     		mov	r2, #0
 1287 0038 1A70     		strb	r2, [r3]
 1288              	.L95:
1553:.\Generated_Source\PSoC4/UART_1.c **** 
1554:.\Generated_Source\PSoC4/UART_1.c ****                     do /* wait until transmit starts */
1555:.\Generated_Source\PSoC4/UART_1.c ****                     {
1556:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 1289              		.loc 1 1556 0 discriminator 1
 1290 003a 1E4A     		ldr	r2, .L99+16
 1291 003c 0F23     		mov	r3, #15
 1292 003e FB18     		add	r3, r7, r3
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 51


 1293 0040 1278     		ldrb	r2, [r2]
 1294 0042 1A70     		strb	r2, [r3]
1557:.\Generated_Source\PSoC4/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 1295              		.loc 1 1557 0 discriminator 1
 1296 0044 0F23     		mov	r3, #15
 1297 0046 FB18     		add	r3, r7, r3
 1298 0048 1B78     		ldrb	r3, [r3]
 1299 004a 0222     		mov	r2, #2
 1300 004c 1340     		and	r3, r2
 1301 004e F4D1     		bne	.L95
 1302              	.L94:
1558:.\Generated_Source\PSoC4/UART_1.c ****                 }
1559:.\Generated_Source\PSoC4/UART_1.c **** 
1560:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1303              		.loc 1 1560 0
 1304 0050 FB1D     		add	r3, r7, #7
 1305 0052 1B78     		ldrb	r3, [r3]
 1306 0054 012B     		cmp	r3, #1
 1307 0056 03D0     		beq	.L96
 1308              		.loc 1 1560 0 is_stmt 0 discriminator 1
 1309 0058 FB1D     		add	r3, r7, #7
 1310 005a 1B78     		ldrb	r3, [r3]
 1311 005c 032B     		cmp	r3, #3
 1312 005e 0DD1     		bne	.L97
 1313              	.L96:
1561:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1562:.\Generated_Source\PSoC4/UART_1.c ****                 {
1563:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit complete*/
1564:.\Generated_Source\PSoC4/UART_1.c ****                     {
1565:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 1314              		.loc 1 1565 0 is_stmt 1 discriminator 1
 1315 0060 144A     		ldr	r2, .L99+16
 1316 0062 0F23     		mov	r3, #15
 1317 0064 FB18     		add	r3, r7, r3
 1318 0066 1278     		ldrb	r2, [r2]
 1319 0068 1A70     		strb	r2, [r3]
1566:.\Generated_Source\PSoC4/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 1320              		.loc 1 1566 0 discriminator 1
 1321 006a 0F23     		mov	r3, #15
 1322 006c FB18     		add	r3, r7, r3
 1323 006e 1B78     		ldrb	r3, [r3]
 1324 0070 DB43     		mvn	r3, r3
 1325 0072 DBB2     		uxtb	r3, r3
 1326 0074 1A1C     		mov	r2, r3
 1327 0076 0123     		mov	r3, #1
 1328 0078 1340     		and	r3, r2
 1329 007a F1D1     		bne	.L96
 1330              	.L97:
1567:.\Generated_Source\PSoC4/UART_1.c ****                 }
1568:.\Generated_Source\PSoC4/UART_1.c **** 
1569:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1331              		.loc 1 1569 0
 1332 007c FB1D     		add	r3, r7, #7
 1333 007e 1B78     		ldrb	r3, [r3]
 1334 0080 012B     		cmp	r3, #1
 1335 0082 07D0     		beq	.L98
 1336              		.loc 1 1569 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 52


 1337 0084 FB1D     		add	r3, r7, #7
 1338 0086 1B78     		ldrb	r3, [r3]
 1339 0088 022B     		cmp	r3, #2
 1340 008a 03D0     		beq	.L98
1570:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_REINIT) ||
 1341              		.loc 1 1570 0 is_stmt 1
 1342 008c FB1D     		add	r3, r7, #7
 1343 008e 1B78     		ldrb	r3, [r3]
 1344 0090 032B     		cmp	r3, #3
 1345 0092 03D1     		bne	.L91
 1346              	.L98:
1571:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1572:.\Generated_Source\PSoC4/UART_1.c ****                 {
1573:.\Generated_Source\PSoC4/UART_1.c **** 
1574:.\Generated_Source\PSoC4/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1575:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = tx_period;
 1347              		.loc 1 1575 0
 1348 0094 044A     		ldr	r2, .L99+4
 1349 0096 054B     		ldr	r3, .L99+8
 1350 0098 1B78     		ldrb	r3, [r3]
 1351 009a 1370     		strb	r3, [r2]
 1352              	.L91:
 1353              	.LBE2:
1576:.\Generated_Source\PSoC4/UART_1.c ****                     #else
1577:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = tx_period;
1578:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1579:.\Generated_Source\PSoC4/UART_1.c **** 
1580:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1581:.\Generated_Source\PSoC4/UART_1.c ****                          (UART_1_PARITY_TYPE_SW != 0u) )
1582:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1583:.\Generated_Source\PSoC4/UART_1.c ****                                                       (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1584:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != NONE */
1585:.\Generated_Source\PSoC4/UART_1.c ****                 }
1586:.\Generated_Source\PSoC4/UART_1.c ****             #endif    /* End UART_1_HD_ENABLED */
1587:.\Generated_Source\PSoC4/UART_1.c ****         }
1588:.\Generated_Source\PSoC4/UART_1.c ****     }
 1354              		.loc 1 1588 0
 1355 009c BD46     		mov	sp, r7
 1356 009e 04B0     		add	sp, sp, #16
 1357              		@ sp needed
 1358 00a0 80BD     		pop	{r7, pc}
 1359              	.L100:
 1360 00a2 C046     		.align	2
 1361              	.L99:
 1362 00a4 00000000 		.word	UART_1_initVar
 1363 00a8 33000F40 		.word	1074724915
 1364 00ac 01000000 		.word	tx_period.4844
 1365 00b0 40000F40 		.word	1074724928
 1366 00b4 60000F40 		.word	1074724960
 1367              		.cfi_endproc
 1368              	.LFE27:
 1369              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 1370              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 1371              		.align	2
 1372              		.global	UART_1_SetTxAddressMode
 1373              		.code	16
 1374              		.thumb_func
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 53


 1375              		.type	UART_1_SetTxAddressMode, %function
 1376              	UART_1_SetTxAddressMode:
 1377              	.LFB28:
1589:.\Generated_Source\PSoC4/UART_1.c **** 
1590:.\Generated_Source\PSoC4/UART_1.c **** 
1591:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1592:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1593:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1594:.\Generated_Source\PSoC4/UART_1.c ****     *
1595:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1596:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the transmit addressing mode
1597:.\Generated_Source\PSoC4/UART_1.c ****     *
1598:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1599:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: 0 -> Space
1600:.\Generated_Source\PSoC4/UART_1.c ****     *               1 -> Mark
1601:.\Generated_Source\PSoC4/UART_1.c ****     *
1602:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1603:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1604:.\Generated_Source\PSoC4/UART_1.c ****     *
1605:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1606:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1607:.\Generated_Source\PSoC4/UART_1.c ****     {
 1378              		.loc 1 1607 0
 1379              		.cfi_startproc
 1380 0000 80B5     		push	{r7, lr}
 1381              		.cfi_def_cfa_offset 8
 1382              		.cfi_offset 7, -8
 1383              		.cfi_offset 14, -4
 1384 0002 82B0     		sub	sp, sp, #8
 1385              		.cfi_def_cfa_offset 16
 1386 0004 00AF     		add	r7, sp, #0
 1387              		.cfi_def_cfa_register 7
 1388 0006 021C     		mov	r2, r0
 1389 0008 FB1D     		add	r3, r7, #7
 1390 000a 1A70     		strb	r2, [r3]
1608:.\Generated_Source\PSoC4/UART_1.c ****         /* Mark/Space sending enable*/
1609:.\Generated_Source\PSoC4/UART_1.c ****         if(addressMode != 0u)
1610:.\Generated_Source\PSoC4/UART_1.c ****         {
1611:.\Generated_Source\PSoC4/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1612:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1613:.\Generated_Source\PSoC4/UART_1.c ****                                                       UART_1_CTRL_MARK);
1614:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1615:.\Generated_Source\PSoC4/UART_1.c ****         }
1616:.\Generated_Source\PSoC4/UART_1.c ****         else
1617:.\Generated_Source\PSoC4/UART_1.c ****         {
1618:.\Generated_Source\PSoC4/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1619:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1620:.\Generated_Source\PSoC4/UART_1.c ****                                                     (uint8)~UART_1_CTRL_MARK);
1621:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1622:.\Generated_Source\PSoC4/UART_1.c ****         }
1623:.\Generated_Source\PSoC4/UART_1.c ****     }
 1391              		.loc 1 1623 0
 1392 000c BD46     		mov	sp, r7
 1393 000e 02B0     		add	sp, sp, #8
 1394              		@ sp needed
 1395 0010 80BD     		pop	{r7, pc}
 1396              		.cfi_endproc
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 54


 1397              	.LFE28:
 1398              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 1399 0012 C046     		.bss
 1400              	tx_period.4844:
 1401 0001 00       		.space	1
 1402              		.text
 1403              	.Letext0:
 1404              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 1405              		.section	.debug_info,"",%progbits
 1406              	.Ldebug_info0:
 1407 0000 FC040000 		.4byte	0x4fc
 1408 0004 0400     		.2byte	0x4
 1409 0006 00000000 		.4byte	.Ldebug_abbrev0
 1410 000a 04       		.byte	0x4
 1411 000b 01       		.uleb128 0x1
 1412 000c BF030000 		.4byte	.LASF60
 1413 0010 01       		.byte	0x1
 1414 0011 4B010000 		.4byte	.LASF61
 1415 0015 C0000000 		.4byte	.LASF62
 1416 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1417 001d 00000000 		.4byte	0
 1418 0021 00000000 		.4byte	.Ldebug_line0
 1419 0025 02       		.uleb128 0x2
 1420 0026 01       		.byte	0x1
 1421 0027 06       		.byte	0x6
 1422 0028 9C000000 		.4byte	.LASF0
 1423 002c 02       		.uleb128 0x2
 1424 002d 01       		.byte	0x1
 1425 002e 08       		.byte	0x8
 1426 002f 25030000 		.4byte	.LASF1
 1427 0033 02       		.uleb128 0x2
 1428 0034 02       		.byte	0x2
 1429 0035 05       		.byte	0x5
 1430 0036 33030000 		.4byte	.LASF2
 1431 003a 02       		.uleb128 0x2
 1432 003b 02       		.byte	0x2
 1433 003c 07       		.byte	0x7
 1434 003d E3010000 		.4byte	.LASF3
 1435 0041 02       		.uleb128 0x2
 1436 0042 04       		.byte	0x4
 1437 0043 05       		.byte	0x5
 1438 0044 B7000000 		.4byte	.LASF4
 1439 0048 02       		.uleb128 0x2
 1440 0049 04       		.byte	0x4
 1441 004a 07       		.byte	0x7
 1442 004b CC010000 		.4byte	.LASF5
 1443 004f 02       		.uleb128 0x2
 1444 0050 08       		.byte	0x8
 1445 0051 05       		.byte	0x5
 1446 0052 8E000000 		.4byte	.LASF6
 1447 0056 02       		.uleb128 0x2
 1448 0057 08       		.byte	0x8
 1449 0058 07       		.byte	0x7
 1450 0059 60000000 		.4byte	.LASF7
 1451 005d 03       		.uleb128 0x3
 1452 005e 04       		.byte	0x4
 1453 005f 05       		.byte	0x5
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 55


 1454 0060 696E7400 		.ascii	"int\000"
 1455 0064 02       		.uleb128 0x2
 1456 0065 04       		.byte	0x4
 1457 0066 07       		.byte	0x7
 1458 0067 AB010000 		.4byte	.LASF8
 1459 006b 04       		.uleb128 0x4
 1460 006c 32010000 		.4byte	.LASF9
 1461 0070 02       		.byte	0x2
 1462 0071 A1       		.byte	0xa1
 1463 0072 2C000000 		.4byte	0x2c
 1464 0076 04       		.uleb128 0x4
 1465 0077 00000000 		.4byte	.LASF10
 1466 007b 02       		.byte	0x2
 1467 007c A2       		.byte	0xa2
 1468 007d 3A000000 		.4byte	0x3a
 1469 0081 02       		.uleb128 0x2
 1470 0082 04       		.byte	0x4
 1471 0083 04       		.byte	0x4
 1472 0084 DC020000 		.4byte	.LASF11
 1473 0088 02       		.uleb128 0x2
 1474 0089 08       		.byte	0x8
 1475 008a 04       		.byte	0x4
 1476 008b 38010000 		.4byte	.LASF12
 1477 008f 04       		.uleb128 0x4
 1478 0090 95030000 		.4byte	.LASF13
 1479 0094 02       		.byte	0x2
 1480 0095 B2       		.byte	0xb2
 1481 0096 9A000000 		.4byte	0x9a
 1482 009a 02       		.uleb128 0x2
 1483 009b 01       		.byte	0x1
 1484 009c 08       		.byte	0x8
 1485 009d 90030000 		.4byte	.LASF14
 1486 00a1 05       		.uleb128 0x5
 1487 00a2 20030000 		.4byte	.LASF15
 1488 00a6 02       		.byte	0x2
 1489 00a7 4B01     		.2byte	0x14b
 1490 00a9 AD000000 		.4byte	0xad
 1491 00ad 06       		.uleb128 0x6
 1492 00ae 6B000000 		.4byte	0x6b
 1493 00b2 02       		.uleb128 0x2
 1494 00b3 04       		.byte	0x4
 1495 00b4 07       		.byte	0x7
 1496 00b5 7E020000 		.4byte	.LASF16
 1497 00b9 07       		.uleb128 0x7
 1498 00ba 25010000 		.4byte	.LASF17
 1499 00be 01       		.byte	0x1
 1500 00bf 49       		.byte	0x49
 1501 00c0 00000000 		.4byte	.LFB2
 1502 00c4 24000000 		.4byte	.LFE2-.LFB2
 1503 00c8 01       		.uleb128 0x1
 1504 00c9 9C       		.byte	0x9c
 1505 00ca 08       		.uleb128 0x8
 1506 00cb 9B030000 		.4byte	.LASF18
 1507 00cf 01       		.byte	0x1
 1508 00d0 65       		.byte	0x65
 1509 00d1 00000000 		.4byte	.LFB3
 1510 00d5 3C000000 		.4byte	.LFE3-.LFB3
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 56


 1511 00d9 01       		.uleb128 0x1
 1512 00da 9C       		.byte	0x9c
 1513 00db 09       		.uleb128 0x9
 1514 00dc F6010000 		.4byte	.LASF19
 1515 00e0 01       		.byte	0x1
 1516 00e1 AE       		.byte	0xae
 1517 00e2 00000000 		.4byte	.LFB4
 1518 00e6 5C000000 		.4byte	.LFE4-.LFB4
 1519 00ea 01       		.uleb128 0x1
 1520 00eb 9C       		.byte	0x9c
 1521 00ec FF000000 		.4byte	0xff
 1522 00f0 0A       		.uleb128 0xa
 1523 00f1 A7030000 		.4byte	.LASF21
 1524 00f5 01       		.byte	0x1
 1525 00f6 B0       		.byte	0xb0
 1526 00f7 6B000000 		.4byte	0x6b
 1527 00fb 02       		.uleb128 0x2
 1528 00fc 91       		.byte	0x91
 1529 00fd 6F       		.sleb128 -17
 1530 00fe 00       		.byte	0
 1531 00ff 09       		.uleb128 0x9
 1532 0100 48020000 		.4byte	.LASF20
 1533 0104 01       		.byte	0x1
 1534 0105 E3       		.byte	0xe3
 1535 0106 00000000 		.4byte	.LFB5
 1536 010a 5C000000 		.4byte	.LFE5-.LFB5
 1537 010e 01       		.uleb128 0x1
 1538 010f 9C       		.byte	0x9c
 1539 0110 23010000 		.4byte	0x123
 1540 0114 0A       		.uleb128 0xa
 1541 0115 A7030000 		.4byte	.LASF21
 1542 0119 01       		.byte	0x1
 1543 011a E5       		.byte	0xe5
 1544 011b 6B000000 		.4byte	0x6b
 1545 011f 02       		.uleb128 0x2
 1546 0120 91       		.byte	0x91
 1547 0121 6F       		.sleb128 -17
 1548 0122 00       		.byte	0
 1549 0123 0B       		.uleb128 0xb
 1550 0124 2D020000 		.4byte	.LASF32
 1551 0128 01       		.byte	0x1
 1552 0129 1901     		.2byte	0x119
 1553 012b 6B000000 		.4byte	0x6b
 1554 012f 00000000 		.4byte	.LFB6
 1555 0133 0C000000 		.4byte	.LFE6-.LFB6
 1556 0137 01       		.uleb128 0x1
 1557 0138 9C       		.byte	0x9c
 1558 0139 0C       		.uleb128 0xc
 1559 013a 3D030000 		.4byte	.LASF22
 1560 013e 01       		.byte	0x1
 1561 013f 3101     		.2byte	0x131
 1562 0141 00000000 		.4byte	.LFB7
 1563 0145 12000000 		.4byte	.LFE7-.LFB7
 1564 0149 01       		.uleb128 0x1
 1565 014a 9C       		.byte	0x9c
 1566 014b 5F010000 		.4byte	0x15f
 1567 014f 0D       		.uleb128 0xd
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 57


 1568 0150 81010000 		.4byte	.LASF24
 1569 0154 01       		.byte	0x1
 1570 0155 3101     		.2byte	0x131
 1571 0157 6B000000 		.4byte	0x6b
 1572 015b 02       		.uleb128 0x2
 1573 015c 91       		.byte	0x91
 1574 015d 77       		.sleb128 -9
 1575 015e 00       		.byte	0
 1576 015f 0C       		.uleb128 0xc
 1577 0160 89010000 		.4byte	.LASF23
 1578 0164 01       		.byte	0x1
 1579 0165 8101     		.2byte	0x181
 1580 0167 00000000 		.4byte	.LFB8
 1581 016b 20000000 		.4byte	.LFE8-.LFB8
 1582 016f 01       		.uleb128 0x1
 1583 0170 9C       		.byte	0x9c
 1584 0171 85010000 		.4byte	0x185
 1585 0175 0D       		.uleb128 0xd
 1586 0176 26020000 		.4byte	.LASF25
 1587 017a 01       		.byte	0x1
 1588 017b 8101     		.2byte	0x181
 1589 017d 6B000000 		.4byte	0x6b
 1590 0181 02       		.uleb128 0x2
 1591 0182 91       		.byte	0x91
 1592 0183 77       		.sleb128 -9
 1593 0184 00       		.byte	0
 1594 0185 0E       		.uleb128 0xe
 1595 0186 4E000000 		.4byte	.LASF27
 1596 018a 01       		.byte	0x1
 1597 018b A201     		.2byte	0x1a2
 1598 018d 6B000000 		.4byte	0x6b
 1599 0191 00000000 		.4byte	.LFB9
 1600 0195 20000000 		.4byte	.LFE9-.LFB9
 1601 0199 01       		.uleb128 0x1
 1602 019a 9C       		.byte	0x9c
 1603 019b AF010000 		.4byte	0x1af
 1604 019f 0F       		.uleb128 0xf
 1605 01a0 89030000 		.4byte	.LASF26
 1606 01a4 01       		.byte	0x1
 1607 01a5 A401     		.2byte	0x1a4
 1608 01a7 6B000000 		.4byte	0x6b
 1609 01ab 02       		.uleb128 0x2
 1610 01ac 91       		.byte	0x91
 1611 01ad 77       		.sleb128 -9
 1612 01ae 00       		.byte	0
 1613 01af 0E       		.uleb128 0xe
 1614 01b0 6D010000 		.4byte	.LASF28
 1615 01b4 01       		.byte	0x1
 1616 01b5 FD01     		.2byte	0x1fd
 1617 01b7 6B000000 		.4byte	0x6b
 1618 01bb 00000000 		.4byte	.LFB10
 1619 01bf 24000000 		.4byte	.LFE10-.LFB10
 1620 01c3 01       		.uleb128 0x1
 1621 01c4 9C       		.byte	0x9c
 1622 01c5 D9010000 		.4byte	0x1d9
 1623 01c9 0F       		.uleb128 0xf
 1624 01ca B8030000 		.4byte	.LASF29
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 58


 1625 01ce 01       		.byte	0x1
 1626 01cf FF01     		.2byte	0x1ff
 1627 01d1 6B000000 		.4byte	0x6b
 1628 01d5 02       		.uleb128 0x2
 1629 01d6 91       		.byte	0x91
 1630 01d7 77       		.sleb128 -9
 1631 01d8 00       		.byte	0
 1632 01d9 0E       		.uleb128 0xe
 1633 01da 4D040000 		.4byte	.LASF30
 1634 01de 01       		.byte	0x1
 1635 01df 2C02     		.2byte	0x22c
 1636 01e1 6B000000 		.4byte	0x6b
 1637 01e5 00000000 		.4byte	.LFB11
 1638 01e9 4C000000 		.4byte	.LFE11-.LFB11
 1639 01ed 01       		.uleb128 0x1
 1640 01ee 9C       		.byte	0x9c
 1641 01ef 12020000 		.4byte	0x212
 1642 01f3 0F       		.uleb128 0xf
 1643 01f4 89030000 		.4byte	.LASF26
 1644 01f8 01       		.byte	0x1
 1645 01f9 2E02     		.2byte	0x22e
 1646 01fb 6B000000 		.4byte	0x6b
 1647 01ff 02       		.uleb128 0x2
 1648 0200 91       		.byte	0x91
 1649 0201 77       		.sleb128 -9
 1650 0202 0F       		.uleb128 0xf
 1651 0203 B9020000 		.4byte	.LASF31
 1652 0207 01       		.byte	0x1
 1653 0208 2F02     		.2byte	0x22f
 1654 020a 6B000000 		.4byte	0x6b
 1655 020e 02       		.uleb128 0x2
 1656 020f 91       		.byte	0x91
 1657 0210 76       		.sleb128 -10
 1658 0211 00       		.byte	0
 1659 0212 10       		.uleb128 0x10
 1660 0213 54020000 		.4byte	.LASF33
 1661 0217 01       		.byte	0x1
 1662 0218 9202     		.2byte	0x292
 1663 021a 76000000 		.4byte	0x76
 1664 021e 00000000 		.4byte	.LFB12
 1665 0222 24000000 		.4byte	.LFE12-.LFB12
 1666 0226 01       		.uleb128 0x1
 1667 0227 9C       		.byte	0x9c
 1668 0228 0E       		.uleb128 0xe
 1669 0229 72030000 		.4byte	.LASF34
 1670 022d 01       		.byte	0x1
 1671 022e B302     		.2byte	0x2b3
 1672 0230 6B000000 		.4byte	0x6b
 1673 0234 00000000 		.4byte	.LFB13
 1674 0238 30000000 		.4byte	.LFE13-.LFB13
 1675 023c 01       		.uleb128 0x1
 1676 023d 9C       		.byte	0x9c
 1677 023e 52020000 		.4byte	0x252
 1678 0242 0F       		.uleb128 0xf
 1679 0243 DE010000 		.4byte	.LASF35
 1680 0247 01       		.byte	0x1
 1681 0248 B602     		.2byte	0x2b6
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 59


 1682 024a 6B000000 		.4byte	0x6b
 1683 024e 02       		.uleb128 0x2
 1684 024f 91       		.byte	0x91
 1685 0250 77       		.sleb128 -9
 1686 0251 00       		.byte	0
 1687 0252 11       		.uleb128 0x11
 1688 0253 F3020000 		.4byte	.LASF36
 1689 0257 01       		.byte	0x1
 1690 0258 0303     		.2byte	0x303
 1691 025a 00000000 		.4byte	.LFB14
 1692 025e 44000000 		.4byte	.LFE14-.LFB14
 1693 0262 01       		.uleb128 0x1
 1694 0263 9C       		.byte	0x9c
 1695 0264 78020000 		.4byte	0x278
 1696 0268 0F       		.uleb128 0xf
 1697 0269 A7030000 		.4byte	.LASF21
 1698 026d 01       		.byte	0x1
 1699 026e 0503     		.2byte	0x305
 1700 0270 6B000000 		.4byte	0x6b
 1701 0274 02       		.uleb128 0x2
 1702 0275 91       		.byte	0x91
 1703 0276 6F       		.sleb128 -17
 1704 0277 00       		.byte	0
 1705 0278 0C       		.uleb128 0xc
 1706 0279 08030000 		.4byte	.LASF37
 1707 027d 01       		.byte	0x1
 1708 027e 4003     		.2byte	0x340
 1709 0280 00000000 		.4byte	.LFB15
 1710 0284 12000000 		.4byte	.LFE15-.LFB15
 1711 0288 01       		.uleb128 0x1
 1712 0289 9C       		.byte	0x9c
 1713 028a 9E020000 		.4byte	0x29e
 1714 028e 0D       		.uleb128 0xd
 1715 028f 3F010000 		.4byte	.LASF38
 1716 0293 01       		.byte	0x1
 1717 0294 4003     		.2byte	0x340
 1718 0296 6B000000 		.4byte	0x6b
 1719 029a 02       		.uleb128 0x2
 1720 029b 91       		.byte	0x91
 1721 029c 77       		.sleb128 -9
 1722 029d 00       		.byte	0
 1723 029e 0C       		.uleb128 0xc
 1724 029f 87020000 		.4byte	.LASF39
 1725 02a3 01       		.byte	0x1
 1726 02a4 6503     		.2byte	0x365
 1727 02a6 00000000 		.4byte	.LFB16
 1728 02aa 20000000 		.4byte	.LFE16-.LFB16
 1729 02ae 01       		.uleb128 0x1
 1730 02af 9C       		.byte	0x9c
 1731 02b0 C4020000 		.4byte	0x2c4
 1732 02b4 0D       		.uleb128 0xd
 1733 02b5 B1020000 		.4byte	.LASF40
 1734 02b9 01       		.byte	0x1
 1735 02ba 6503     		.2byte	0x365
 1736 02bc 6B000000 		.4byte	0x6b
 1737 02c0 02       		.uleb128 0x2
 1738 02c1 91       		.byte	0x91
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 60


 1739 02c2 77       		.sleb128 -9
 1740 02c3 00       		.byte	0
 1741 02c4 0C       		.uleb128 0xc
 1742 02c5 9C020000 		.4byte	.LASF41
 1743 02c9 01       		.byte	0x1
 1744 02ca 7A03     		.2byte	0x37a
 1745 02cc 00000000 		.4byte	.LFB17
 1746 02d0 20000000 		.4byte	.LFE17-.LFB17
 1747 02d4 01       		.uleb128 0x1
 1748 02d5 9C       		.byte	0x9c
 1749 02d6 EA020000 		.4byte	0x2ea
 1750 02da 0D       		.uleb128 0xd
 1751 02db B1020000 		.4byte	.LASF40
 1752 02df 01       		.byte	0x1
 1753 02e0 7A03     		.2byte	0x37a
 1754 02e2 6B000000 		.4byte	0x6b
 1755 02e6 02       		.uleb128 0x2
 1756 02e7 91       		.byte	0x91
 1757 02e8 77       		.sleb128 -9
 1758 02e9 00       		.byte	0
 1759 02ea 0C       		.uleb128 0xc
 1760 02eb C2020000 		.4byte	.LASF42
 1761 02ef 01       		.byte	0x1
 1762 02f0 C803     		.2byte	0x3c8
 1763 02f2 00000000 		.4byte	.LFB18
 1764 02f6 20000000 		.4byte	.LFE18-.LFB18
 1765 02fa 01       		.uleb128 0x1
 1766 02fb 9C       		.byte	0x9c
 1767 02fc 10030000 		.4byte	0x310
 1768 0300 0D       		.uleb128 0xd
 1769 0301 26020000 		.4byte	.LASF25
 1770 0305 01       		.byte	0x1
 1771 0306 C803     		.2byte	0x3c8
 1772 0308 6B000000 		.4byte	0x6b
 1773 030c 02       		.uleb128 0x2
 1774 030d 91       		.byte	0x91
 1775 030e 77       		.sleb128 -9
 1776 030f 00       		.byte	0
 1777 0310 0C       		.uleb128 0xc
 1778 0311 63020000 		.4byte	.LASF43
 1779 0315 01       		.byte	0x1
 1780 0316 EA03     		.2byte	0x3ea
 1781 0318 00000000 		.4byte	.LFB19
 1782 031c 2C000000 		.4byte	.LFE19-.LFB19
 1783 0320 01       		.uleb128 0x1
 1784 0321 9C       		.byte	0x9c
 1785 0322 36030000 		.4byte	0x336
 1786 0326 0D       		.uleb128 0xd
 1787 0327 1C000000 		.4byte	.LASF44
 1788 032b 01       		.byte	0x1
 1789 032c EA03     		.2byte	0x3ea
 1790 032e 6B000000 		.4byte	0x6b
 1791 0332 02       		.uleb128 0x2
 1792 0333 91       		.byte	0x91
 1793 0334 77       		.sleb128 -9
 1794 0335 00       		.byte	0
 1795 0336 0B       		.uleb128 0xb
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 61


 1796 0337 B8010000 		.4byte	.LASF45
 1797 033b 01       		.byte	0x1
 1798 033c 2E04     		.2byte	0x42e
 1799 033e 6B000000 		.4byte	0x6b
 1800 0342 00000000 		.4byte	.LFB20
 1801 0346 14000000 		.4byte	.LFE20-.LFB20
 1802 034a 01       		.uleb128 0x1
 1803 034b 9C       		.byte	0x9c
 1804 034c 0C       		.uleb128 0xc
 1805 034d 27000000 		.4byte	.LASF46
 1806 0351 01       		.byte	0x1
 1807 0352 5204     		.2byte	0x452
 1808 0354 00000000 		.4byte	.LFB21
 1809 0358 34000000 		.4byte	.LFE21-.LFB21
 1810 035c 01       		.uleb128 0x1
 1811 035d 9C       		.byte	0x9c
 1812 035e 72030000 		.4byte	0x372
 1813 0362 0D       		.uleb128 0xd
 1814 0363 1C000000 		.4byte	.LASF44
 1815 0367 01       		.byte	0x1
 1816 0368 5204     		.2byte	0x452
 1817 036a 6B000000 		.4byte	0x6b
 1818 036e 02       		.uleb128 0x2
 1819 036f 91       		.byte	0x91
 1820 0370 77       		.sleb128 -9
 1821 0371 00       		.byte	0
 1822 0372 11       		.uleb128 0x11
 1823 0373 E2020000 		.4byte	.LASF47
 1824 0377 01       		.byte	0x1
 1825 0378 AE04     		.2byte	0x4ae
 1826 037a 00000000 		.4byte	.LFB22
 1827 037e 54000000 		.4byte	.LFE22-.LFB22
 1828 0382 01       		.uleb128 0x1
 1829 0383 9C       		.byte	0x9c
 1830 0384 A7030000 		.4byte	0x3a7
 1831 0388 0D       		.uleb128 0xd
 1832 0389 36000000 		.4byte	.LASF48
 1833 038d 01       		.byte	0x1
 1834 038e AE04     		.2byte	0x4ae
 1835 0390 A7030000 		.4byte	0x3a7
 1836 0394 02       		.uleb128 0x2
 1837 0395 91       		.byte	0x91
 1838 0396 6C       		.sleb128 -20
 1839 0397 0F       		.uleb128 0xf
 1840 0398 5C040000 		.4byte	.LASF49
 1841 039c 01       		.byte	0x1
 1842 039d B004     		.2byte	0x4b0
 1843 039f 76000000 		.4byte	0x76
 1844 03a3 02       		.uleb128 0x2
 1845 03a4 91       		.byte	0x91
 1846 03a5 76       		.sleb128 -10
 1847 03a6 00       		.byte	0
 1848 03a7 12       		.uleb128 0x12
 1849 03a8 04       		.byte	0x4
 1850 03a9 AD030000 		.4byte	0x3ad
 1851 03ad 13       		.uleb128 0x13
 1852 03ae 8F000000 		.4byte	0x8f
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 62


 1853 03b2 11       		.uleb128 0x11
 1854 03b3 66040000 		.4byte	.LASF50
 1855 03b7 01       		.byte	0x1
 1856 03b8 D404     		.2byte	0x4d4
 1857 03ba 00000000 		.4byte	.LFB23
 1858 03be 58000000 		.4byte	.LFE23-.LFB23
 1859 03c2 01       		.uleb128 0x1
 1860 03c3 9C       		.byte	0x9c
 1861 03c4 F6030000 		.4byte	0x3f6
 1862 03c8 0D       		.uleb128 0xd
 1863 03c9 36000000 		.4byte	.LASF48
 1864 03cd 01       		.byte	0x1
 1865 03ce D404     		.2byte	0x4d4
 1866 03d0 F6030000 		.4byte	0x3f6
 1867 03d4 02       		.uleb128 0x2
 1868 03d5 91       		.byte	0x91
 1869 03d6 6C       		.sleb128 -20
 1870 03d7 0D       		.uleb128 0xd
 1871 03d8 68030000 		.4byte	.LASF51
 1872 03dc 01       		.byte	0x1
 1873 03dd D404     		.2byte	0x4d4
 1874 03df 6B000000 		.4byte	0x6b
 1875 03e3 02       		.uleb128 0x2
 1876 03e4 91       		.byte	0x91
 1877 03e5 6B       		.sleb128 -21
 1878 03e6 0F       		.uleb128 0xf
 1879 03e7 5C040000 		.4byte	.LASF49
 1880 03eb 01       		.byte	0x1
 1881 03ec D704     		.2byte	0x4d7
 1882 03ee 6B000000 		.4byte	0x6b
 1883 03f2 02       		.uleb128 0x2
 1884 03f3 91       		.byte	0x91
 1885 03f4 77       		.sleb128 -9
 1886 03f5 00       		.byte	0
 1887 03f6 12       		.uleb128 0x12
 1888 03f7 04       		.byte	0x4
 1889 03f8 FC030000 		.4byte	0x3fc
 1890 03fc 13       		.uleb128 0x13
 1891 03fd 6B000000 		.4byte	0x6b
 1892 0401 11       		.uleb128 0x11
 1893 0402 A8000000 		.4byte	.LASF52
 1894 0406 01       		.byte	0x1
 1895 0407 F904     		.2byte	0x4f9
 1896 0409 00000000 		.4byte	.LFB24
 1897 040d 34000000 		.4byte	.LFE24-.LFB24
 1898 0411 01       		.uleb128 0x1
 1899 0412 9C       		.byte	0x9c
 1900 0413 27040000 		.4byte	0x427
 1901 0417 0D       		.uleb128 0xd
 1902 0418 1C000000 		.4byte	.LASF44
 1903 041c 01       		.byte	0x1
 1904 041d F904     		.2byte	0x4f9
 1905 041f 6B000000 		.4byte	0x6b
 1906 0423 02       		.uleb128 0x2
 1907 0424 91       		.byte	0x91
 1908 0425 77       		.sleb128 -9
 1909 0426 00       		.byte	0
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 63


 1910 0427 0E       		.uleb128 0xe
 1911 0428 77000000 		.4byte	.LASF53
 1912 042c 01       		.byte	0x1
 1913 042d 1E05     		.2byte	0x51e
 1914 042f 6B000000 		.4byte	0x6b
 1915 0433 00000000 		.4byte	.LFB25
 1916 0437 48000000 		.4byte	.LFE25-.LFB25
 1917 043b 01       		.uleb128 0x1
 1918 043c 9C       		.byte	0x9c
 1919 043d 51040000 		.4byte	0x451
 1920 0441 0F       		.uleb128 0xf
 1921 0442 DE010000 		.4byte	.LASF35
 1922 0446 01       		.byte	0x1
 1923 0447 2105     		.2byte	0x521
 1924 0449 6B000000 		.4byte	0x6b
 1925 044d 02       		.uleb128 0x2
 1926 044e 91       		.byte	0x91
 1927 044f 77       		.sleb128 -9
 1928 0450 00       		.byte	0
 1929 0451 11       		.uleb128 0x11
 1930 0452 07000000 		.4byte	.LASF54
 1931 0456 01       		.byte	0x1
 1932 0457 7405     		.2byte	0x574
 1933 0459 00000000 		.4byte	.LFB26
 1934 045d 44000000 		.4byte	.LFE26-.LFB26
 1935 0461 01       		.uleb128 0x1
 1936 0462 9C       		.byte	0x9c
 1937 0463 77040000 		.4byte	0x477
 1938 0467 0F       		.uleb128 0xf
 1939 0468 A7030000 		.4byte	.LASF21
 1940 046c 01       		.byte	0x1
 1941 046d 7605     		.2byte	0x576
 1942 046f 6B000000 		.4byte	0x6b
 1943 0473 02       		.uleb128 0x2
 1944 0474 91       		.byte	0x91
 1945 0475 6F       		.sleb128 -17
 1946 0476 00       		.byte	0
 1947 0477 0C       		.uleb128 0xc
 1948 0478 3D000000 		.4byte	.LASF55
 1949 047c 01       		.byte	0x1
 1950 047d CD05     		.2byte	0x5cd
 1951 047f 00000000 		.4byte	.LFB27
 1952 0483 B8000000 		.4byte	.LFE27-.LFB27
 1953 0487 01       		.uleb128 0x1
 1954 0488 9C       		.byte	0x9c
 1955 0489 C8040000 		.4byte	0x4c8
 1956 048d 0D       		.uleb128 0xd
 1957 048e A3010000 		.4byte	.LASF56
 1958 0492 01       		.byte	0x1
 1959 0493 CD05     		.2byte	0x5cd
 1960 0495 6B000000 		.4byte	0x6b
 1961 0499 02       		.uleb128 0x2
 1962 049a 91       		.byte	0x91
 1963 049b 6F       		.sleb128 -17
 1964 049c 14       		.uleb128 0x14
 1965 049d 14000000 		.4byte	.LBB2
 1966 04a1 88000000 		.4byte	.LBE2-.LBB2
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 64


 1967 04a5 0F       		.uleb128 0xf
 1968 04a6 76020000 		.4byte	.LASF57
 1969 04aa 01       		.byte	0x1
 1970 04ab D505     		.2byte	0x5d5
 1971 04ad 6B000000 		.4byte	0x6b
 1972 04b1 02       		.uleb128 0x2
 1973 04b2 91       		.byte	0x91
 1974 04b3 77       		.sleb128 -9
 1975 04b4 0F       		.uleb128 0xf
 1976 04b5 1C020000 		.4byte	.LASF58
 1977 04b9 01       		.byte	0x1
 1978 04ba FB05     		.2byte	0x5fb
 1979 04bc 6B000000 		.4byte	0x6b
 1980 04c0 05       		.uleb128 0x5
 1981 04c1 03       		.byte	0x3
 1982 04c2 01000000 		.4byte	tx_period.4844
 1983 04c6 00       		.byte	0
 1984 04c7 00       		.byte	0
 1985 04c8 0C       		.uleb128 0xc
 1986 04c9 04020000 		.4byte	.LASF59
 1987 04cd 01       		.byte	0x1
 1988 04ce 4606     		.2byte	0x646
 1989 04d0 00000000 		.4byte	.LFB28
 1990 04d4 12000000 		.4byte	.LFE28-.LFB28
 1991 04d8 01       		.uleb128 0x1
 1992 04d9 9C       		.byte	0x9c
 1993 04da EE040000 		.4byte	0x4ee
 1994 04de 0D       		.uleb128 0xd
 1995 04df 3F010000 		.4byte	.LASF38
 1996 04e3 01       		.byte	0x1
 1997 04e4 4606     		.2byte	0x646
 1998 04e6 6B000000 		.4byte	0x6b
 1999 04ea 02       		.uleb128 0x2
 2000 04eb 91       		.byte	0x91
 2001 04ec 77       		.sleb128 -9
 2002 04ed 00       		.byte	0
 2003 04ee 15       		.uleb128 0x15
 2004 04ef 59030000 		.4byte	.LASF63
 2005 04f3 01       		.byte	0x1
 2006 04f4 1C       		.byte	0x1c
 2007 04f5 6B000000 		.4byte	0x6b
 2008 04f9 05       		.uleb128 0x5
 2009 04fa 03       		.byte	0x3
 2010 04fb 00000000 		.4byte	UART_1_initVar
 2011 04ff 00       		.byte	0
 2012              		.section	.debug_abbrev,"",%progbits
 2013              	.Ldebug_abbrev0:
 2014 0000 01       		.uleb128 0x1
 2015 0001 11       		.uleb128 0x11
 2016 0002 01       		.byte	0x1
 2017 0003 25       		.uleb128 0x25
 2018 0004 0E       		.uleb128 0xe
 2019 0005 13       		.uleb128 0x13
 2020 0006 0B       		.uleb128 0xb
 2021 0007 03       		.uleb128 0x3
 2022 0008 0E       		.uleb128 0xe
 2023 0009 1B       		.uleb128 0x1b
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 65


 2024 000a 0E       		.uleb128 0xe
 2025 000b 55       		.uleb128 0x55
 2026 000c 17       		.uleb128 0x17
 2027 000d 11       		.uleb128 0x11
 2028 000e 01       		.uleb128 0x1
 2029 000f 10       		.uleb128 0x10
 2030 0010 17       		.uleb128 0x17
 2031 0011 00       		.byte	0
 2032 0012 00       		.byte	0
 2033 0013 02       		.uleb128 0x2
 2034 0014 24       		.uleb128 0x24
 2035 0015 00       		.byte	0
 2036 0016 0B       		.uleb128 0xb
 2037 0017 0B       		.uleb128 0xb
 2038 0018 3E       		.uleb128 0x3e
 2039 0019 0B       		.uleb128 0xb
 2040 001a 03       		.uleb128 0x3
 2041 001b 0E       		.uleb128 0xe
 2042 001c 00       		.byte	0
 2043 001d 00       		.byte	0
 2044 001e 03       		.uleb128 0x3
 2045 001f 24       		.uleb128 0x24
 2046 0020 00       		.byte	0
 2047 0021 0B       		.uleb128 0xb
 2048 0022 0B       		.uleb128 0xb
 2049 0023 3E       		.uleb128 0x3e
 2050 0024 0B       		.uleb128 0xb
 2051 0025 03       		.uleb128 0x3
 2052 0026 08       		.uleb128 0x8
 2053 0027 00       		.byte	0
 2054 0028 00       		.byte	0
 2055 0029 04       		.uleb128 0x4
 2056 002a 16       		.uleb128 0x16
 2057 002b 00       		.byte	0
 2058 002c 03       		.uleb128 0x3
 2059 002d 0E       		.uleb128 0xe
 2060 002e 3A       		.uleb128 0x3a
 2061 002f 0B       		.uleb128 0xb
 2062 0030 3B       		.uleb128 0x3b
 2063 0031 0B       		.uleb128 0xb
 2064 0032 49       		.uleb128 0x49
 2065 0033 13       		.uleb128 0x13
 2066 0034 00       		.byte	0
 2067 0035 00       		.byte	0
 2068 0036 05       		.uleb128 0x5
 2069 0037 16       		.uleb128 0x16
 2070 0038 00       		.byte	0
 2071 0039 03       		.uleb128 0x3
 2072 003a 0E       		.uleb128 0xe
 2073 003b 3A       		.uleb128 0x3a
 2074 003c 0B       		.uleb128 0xb
 2075 003d 3B       		.uleb128 0x3b
 2076 003e 05       		.uleb128 0x5
 2077 003f 49       		.uleb128 0x49
 2078 0040 13       		.uleb128 0x13
 2079 0041 00       		.byte	0
 2080 0042 00       		.byte	0
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 66


 2081 0043 06       		.uleb128 0x6
 2082 0044 35       		.uleb128 0x35
 2083 0045 00       		.byte	0
 2084 0046 49       		.uleb128 0x49
 2085 0047 13       		.uleb128 0x13
 2086 0048 00       		.byte	0
 2087 0049 00       		.byte	0
 2088 004a 07       		.uleb128 0x7
 2089 004b 2E       		.uleb128 0x2e
 2090 004c 00       		.byte	0
 2091 004d 3F       		.uleb128 0x3f
 2092 004e 19       		.uleb128 0x19
 2093 004f 03       		.uleb128 0x3
 2094 0050 0E       		.uleb128 0xe
 2095 0051 3A       		.uleb128 0x3a
 2096 0052 0B       		.uleb128 0xb
 2097 0053 3B       		.uleb128 0x3b
 2098 0054 0B       		.uleb128 0xb
 2099 0055 27       		.uleb128 0x27
 2100 0056 19       		.uleb128 0x19
 2101 0057 11       		.uleb128 0x11
 2102 0058 01       		.uleb128 0x1
 2103 0059 12       		.uleb128 0x12
 2104 005a 06       		.uleb128 0x6
 2105 005b 40       		.uleb128 0x40
 2106 005c 18       		.uleb128 0x18
 2107 005d 9642     		.uleb128 0x2116
 2108 005f 19       		.uleb128 0x19
 2109 0060 00       		.byte	0
 2110 0061 00       		.byte	0
 2111 0062 08       		.uleb128 0x8
 2112 0063 2E       		.uleb128 0x2e
 2113 0064 00       		.byte	0
 2114 0065 3F       		.uleb128 0x3f
 2115 0066 19       		.uleb128 0x19
 2116 0067 03       		.uleb128 0x3
 2117 0068 0E       		.uleb128 0xe
 2118 0069 3A       		.uleb128 0x3a
 2119 006a 0B       		.uleb128 0xb
 2120 006b 3B       		.uleb128 0x3b
 2121 006c 0B       		.uleb128 0xb
 2122 006d 27       		.uleb128 0x27
 2123 006e 19       		.uleb128 0x19
 2124 006f 11       		.uleb128 0x11
 2125 0070 01       		.uleb128 0x1
 2126 0071 12       		.uleb128 0x12
 2127 0072 06       		.uleb128 0x6
 2128 0073 40       		.uleb128 0x40
 2129 0074 18       		.uleb128 0x18
 2130 0075 9742     		.uleb128 0x2117
 2131 0077 19       		.uleb128 0x19
 2132 0078 00       		.byte	0
 2133 0079 00       		.byte	0
 2134 007a 09       		.uleb128 0x9
 2135 007b 2E       		.uleb128 0x2e
 2136 007c 01       		.byte	0x1
 2137 007d 3F       		.uleb128 0x3f
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 67


 2138 007e 19       		.uleb128 0x19
 2139 007f 03       		.uleb128 0x3
 2140 0080 0E       		.uleb128 0xe
 2141 0081 3A       		.uleb128 0x3a
 2142 0082 0B       		.uleb128 0xb
 2143 0083 3B       		.uleb128 0x3b
 2144 0084 0B       		.uleb128 0xb
 2145 0085 27       		.uleb128 0x27
 2146 0086 19       		.uleb128 0x19
 2147 0087 11       		.uleb128 0x11
 2148 0088 01       		.uleb128 0x1
 2149 0089 12       		.uleb128 0x12
 2150 008a 06       		.uleb128 0x6
 2151 008b 40       		.uleb128 0x40
 2152 008c 18       		.uleb128 0x18
 2153 008d 9642     		.uleb128 0x2116
 2154 008f 19       		.uleb128 0x19
 2155 0090 01       		.uleb128 0x1
 2156 0091 13       		.uleb128 0x13
 2157 0092 00       		.byte	0
 2158 0093 00       		.byte	0
 2159 0094 0A       		.uleb128 0xa
 2160 0095 34       		.uleb128 0x34
 2161 0096 00       		.byte	0
 2162 0097 03       		.uleb128 0x3
 2163 0098 0E       		.uleb128 0xe
 2164 0099 3A       		.uleb128 0x3a
 2165 009a 0B       		.uleb128 0xb
 2166 009b 3B       		.uleb128 0x3b
 2167 009c 0B       		.uleb128 0xb
 2168 009d 49       		.uleb128 0x49
 2169 009e 13       		.uleb128 0x13
 2170 009f 02       		.uleb128 0x2
 2171 00a0 18       		.uleb128 0x18
 2172 00a1 00       		.byte	0
 2173 00a2 00       		.byte	0
 2174 00a3 0B       		.uleb128 0xb
 2175 00a4 2E       		.uleb128 0x2e
 2176 00a5 00       		.byte	0
 2177 00a6 3F       		.uleb128 0x3f
 2178 00a7 19       		.uleb128 0x19
 2179 00a8 03       		.uleb128 0x3
 2180 00a9 0E       		.uleb128 0xe
 2181 00aa 3A       		.uleb128 0x3a
 2182 00ab 0B       		.uleb128 0xb
 2183 00ac 3B       		.uleb128 0x3b
 2184 00ad 05       		.uleb128 0x5
 2185 00ae 27       		.uleb128 0x27
 2186 00af 19       		.uleb128 0x19
 2187 00b0 49       		.uleb128 0x49
 2188 00b1 13       		.uleb128 0x13
 2189 00b2 11       		.uleb128 0x11
 2190 00b3 01       		.uleb128 0x1
 2191 00b4 12       		.uleb128 0x12
 2192 00b5 06       		.uleb128 0x6
 2193 00b6 40       		.uleb128 0x40
 2194 00b7 18       		.uleb128 0x18
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 68


 2195 00b8 9742     		.uleb128 0x2117
 2196 00ba 19       		.uleb128 0x19
 2197 00bb 00       		.byte	0
 2198 00bc 00       		.byte	0
 2199 00bd 0C       		.uleb128 0xc
 2200 00be 2E       		.uleb128 0x2e
 2201 00bf 01       		.byte	0x1
 2202 00c0 3F       		.uleb128 0x3f
 2203 00c1 19       		.uleb128 0x19
 2204 00c2 03       		.uleb128 0x3
 2205 00c3 0E       		.uleb128 0xe
 2206 00c4 3A       		.uleb128 0x3a
 2207 00c5 0B       		.uleb128 0xb
 2208 00c6 3B       		.uleb128 0x3b
 2209 00c7 05       		.uleb128 0x5
 2210 00c8 27       		.uleb128 0x27
 2211 00c9 19       		.uleb128 0x19
 2212 00ca 11       		.uleb128 0x11
 2213 00cb 01       		.uleb128 0x1
 2214 00cc 12       		.uleb128 0x12
 2215 00cd 06       		.uleb128 0x6
 2216 00ce 40       		.uleb128 0x40
 2217 00cf 18       		.uleb128 0x18
 2218 00d0 9742     		.uleb128 0x2117
 2219 00d2 19       		.uleb128 0x19
 2220 00d3 01       		.uleb128 0x1
 2221 00d4 13       		.uleb128 0x13
 2222 00d5 00       		.byte	0
 2223 00d6 00       		.byte	0
 2224 00d7 0D       		.uleb128 0xd
 2225 00d8 05       		.uleb128 0x5
 2226 00d9 00       		.byte	0
 2227 00da 03       		.uleb128 0x3
 2228 00db 0E       		.uleb128 0xe
 2229 00dc 3A       		.uleb128 0x3a
 2230 00dd 0B       		.uleb128 0xb
 2231 00de 3B       		.uleb128 0x3b
 2232 00df 05       		.uleb128 0x5
 2233 00e0 49       		.uleb128 0x49
 2234 00e1 13       		.uleb128 0x13
 2235 00e2 02       		.uleb128 0x2
 2236 00e3 18       		.uleb128 0x18
 2237 00e4 00       		.byte	0
 2238 00e5 00       		.byte	0
 2239 00e6 0E       		.uleb128 0xe
 2240 00e7 2E       		.uleb128 0x2e
 2241 00e8 01       		.byte	0x1
 2242 00e9 3F       		.uleb128 0x3f
 2243 00ea 19       		.uleb128 0x19
 2244 00eb 03       		.uleb128 0x3
 2245 00ec 0E       		.uleb128 0xe
 2246 00ed 3A       		.uleb128 0x3a
 2247 00ee 0B       		.uleb128 0xb
 2248 00ef 3B       		.uleb128 0x3b
 2249 00f0 05       		.uleb128 0x5
 2250 00f1 27       		.uleb128 0x27
 2251 00f2 19       		.uleb128 0x19
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 69


 2252 00f3 49       		.uleb128 0x49
 2253 00f4 13       		.uleb128 0x13
 2254 00f5 11       		.uleb128 0x11
 2255 00f6 01       		.uleb128 0x1
 2256 00f7 12       		.uleb128 0x12
 2257 00f8 06       		.uleb128 0x6
 2258 00f9 40       		.uleb128 0x40
 2259 00fa 18       		.uleb128 0x18
 2260 00fb 9742     		.uleb128 0x2117
 2261 00fd 19       		.uleb128 0x19
 2262 00fe 01       		.uleb128 0x1
 2263 00ff 13       		.uleb128 0x13
 2264 0100 00       		.byte	0
 2265 0101 00       		.byte	0
 2266 0102 0F       		.uleb128 0xf
 2267 0103 34       		.uleb128 0x34
 2268 0104 00       		.byte	0
 2269 0105 03       		.uleb128 0x3
 2270 0106 0E       		.uleb128 0xe
 2271 0107 3A       		.uleb128 0x3a
 2272 0108 0B       		.uleb128 0xb
 2273 0109 3B       		.uleb128 0x3b
 2274 010a 05       		.uleb128 0x5
 2275 010b 49       		.uleb128 0x49
 2276 010c 13       		.uleb128 0x13
 2277 010d 02       		.uleb128 0x2
 2278 010e 18       		.uleb128 0x18
 2279 010f 00       		.byte	0
 2280 0110 00       		.byte	0
 2281 0111 10       		.uleb128 0x10
 2282 0112 2E       		.uleb128 0x2e
 2283 0113 00       		.byte	0
 2284 0114 3F       		.uleb128 0x3f
 2285 0115 19       		.uleb128 0x19
 2286 0116 03       		.uleb128 0x3
 2287 0117 0E       		.uleb128 0xe
 2288 0118 3A       		.uleb128 0x3a
 2289 0119 0B       		.uleb128 0xb
 2290 011a 3B       		.uleb128 0x3b
 2291 011b 05       		.uleb128 0x5
 2292 011c 27       		.uleb128 0x27
 2293 011d 19       		.uleb128 0x19
 2294 011e 49       		.uleb128 0x49
 2295 011f 13       		.uleb128 0x13
 2296 0120 11       		.uleb128 0x11
 2297 0121 01       		.uleb128 0x1
 2298 0122 12       		.uleb128 0x12
 2299 0123 06       		.uleb128 0x6
 2300 0124 40       		.uleb128 0x40
 2301 0125 18       		.uleb128 0x18
 2302 0126 9642     		.uleb128 0x2116
 2303 0128 19       		.uleb128 0x19
 2304 0129 00       		.byte	0
 2305 012a 00       		.byte	0
 2306 012b 11       		.uleb128 0x11
 2307 012c 2E       		.uleb128 0x2e
 2308 012d 01       		.byte	0x1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 70


 2309 012e 3F       		.uleb128 0x3f
 2310 012f 19       		.uleb128 0x19
 2311 0130 03       		.uleb128 0x3
 2312 0131 0E       		.uleb128 0xe
 2313 0132 3A       		.uleb128 0x3a
 2314 0133 0B       		.uleb128 0xb
 2315 0134 3B       		.uleb128 0x3b
 2316 0135 05       		.uleb128 0x5
 2317 0136 27       		.uleb128 0x27
 2318 0137 19       		.uleb128 0x19
 2319 0138 11       		.uleb128 0x11
 2320 0139 01       		.uleb128 0x1
 2321 013a 12       		.uleb128 0x12
 2322 013b 06       		.uleb128 0x6
 2323 013c 40       		.uleb128 0x40
 2324 013d 18       		.uleb128 0x18
 2325 013e 9642     		.uleb128 0x2116
 2326 0140 19       		.uleb128 0x19
 2327 0141 01       		.uleb128 0x1
 2328 0142 13       		.uleb128 0x13
 2329 0143 00       		.byte	0
 2330 0144 00       		.byte	0
 2331 0145 12       		.uleb128 0x12
 2332 0146 0F       		.uleb128 0xf
 2333 0147 00       		.byte	0
 2334 0148 0B       		.uleb128 0xb
 2335 0149 0B       		.uleb128 0xb
 2336 014a 49       		.uleb128 0x49
 2337 014b 13       		.uleb128 0x13
 2338 014c 00       		.byte	0
 2339 014d 00       		.byte	0
 2340 014e 13       		.uleb128 0x13
 2341 014f 26       		.uleb128 0x26
 2342 0150 00       		.byte	0
 2343 0151 49       		.uleb128 0x49
 2344 0152 13       		.uleb128 0x13
 2345 0153 00       		.byte	0
 2346 0154 00       		.byte	0
 2347 0155 14       		.uleb128 0x14
 2348 0156 0B       		.uleb128 0xb
 2349 0157 01       		.byte	0x1
 2350 0158 11       		.uleb128 0x11
 2351 0159 01       		.uleb128 0x1
 2352 015a 12       		.uleb128 0x12
 2353 015b 06       		.uleb128 0x6
 2354 015c 00       		.byte	0
 2355 015d 00       		.byte	0
 2356 015e 15       		.uleb128 0x15
 2357 015f 34       		.uleb128 0x34
 2358 0160 00       		.byte	0
 2359 0161 03       		.uleb128 0x3
 2360 0162 0E       		.uleb128 0xe
 2361 0163 3A       		.uleb128 0x3a
 2362 0164 0B       		.uleb128 0xb
 2363 0165 3B       		.uleb128 0x3b
 2364 0166 0B       		.uleb128 0xb
 2365 0167 49       		.uleb128 0x49
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 71


 2366 0168 13       		.uleb128 0x13
 2367 0169 3F       		.uleb128 0x3f
 2368 016a 19       		.uleb128 0x19
 2369 016b 02       		.uleb128 0x2
 2370 016c 18       		.uleb128 0x18
 2371 016d 00       		.byte	0
 2372 016e 00       		.byte	0
 2373 016f 00       		.byte	0
 2374              		.section	.debug_aranges,"",%progbits
 2375 0000 EC000000 		.4byte	0xec
 2376 0004 0200     		.2byte	0x2
 2377 0006 00000000 		.4byte	.Ldebug_info0
 2378 000a 04       		.byte	0x4
 2379 000b 00       		.byte	0
 2380 000c 0000     		.2byte	0
 2381 000e 0000     		.2byte	0
 2382 0010 00000000 		.4byte	.LFB2
 2383 0014 24000000 		.4byte	.LFE2-.LFB2
 2384 0018 00000000 		.4byte	.LFB3
 2385 001c 3C000000 		.4byte	.LFE3-.LFB3
 2386 0020 00000000 		.4byte	.LFB4
 2387 0024 5C000000 		.4byte	.LFE4-.LFB4
 2388 0028 00000000 		.4byte	.LFB5
 2389 002c 5C000000 		.4byte	.LFE5-.LFB5
 2390 0030 00000000 		.4byte	.LFB6
 2391 0034 0C000000 		.4byte	.LFE6-.LFB6
 2392 0038 00000000 		.4byte	.LFB7
 2393 003c 12000000 		.4byte	.LFE7-.LFB7
 2394 0040 00000000 		.4byte	.LFB8
 2395 0044 20000000 		.4byte	.LFE8-.LFB8
 2396 0048 00000000 		.4byte	.LFB9
 2397 004c 20000000 		.4byte	.LFE9-.LFB9
 2398 0050 00000000 		.4byte	.LFB10
 2399 0054 24000000 		.4byte	.LFE10-.LFB10
 2400 0058 00000000 		.4byte	.LFB11
 2401 005c 4C000000 		.4byte	.LFE11-.LFB11
 2402 0060 00000000 		.4byte	.LFB12
 2403 0064 24000000 		.4byte	.LFE12-.LFB12
 2404 0068 00000000 		.4byte	.LFB13
 2405 006c 30000000 		.4byte	.LFE13-.LFB13
 2406 0070 00000000 		.4byte	.LFB14
 2407 0074 44000000 		.4byte	.LFE14-.LFB14
 2408 0078 00000000 		.4byte	.LFB15
 2409 007c 12000000 		.4byte	.LFE15-.LFB15
 2410 0080 00000000 		.4byte	.LFB16
 2411 0084 20000000 		.4byte	.LFE16-.LFB16
 2412 0088 00000000 		.4byte	.LFB17
 2413 008c 20000000 		.4byte	.LFE17-.LFB17
 2414 0090 00000000 		.4byte	.LFB18
 2415 0094 20000000 		.4byte	.LFE18-.LFB18
 2416 0098 00000000 		.4byte	.LFB19
 2417 009c 2C000000 		.4byte	.LFE19-.LFB19
 2418 00a0 00000000 		.4byte	.LFB20
 2419 00a4 14000000 		.4byte	.LFE20-.LFB20
 2420 00a8 00000000 		.4byte	.LFB21
 2421 00ac 34000000 		.4byte	.LFE21-.LFB21
 2422 00b0 00000000 		.4byte	.LFB22
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 72


 2423 00b4 54000000 		.4byte	.LFE22-.LFB22
 2424 00b8 00000000 		.4byte	.LFB23
 2425 00bc 58000000 		.4byte	.LFE23-.LFB23
 2426 00c0 00000000 		.4byte	.LFB24
 2427 00c4 34000000 		.4byte	.LFE24-.LFB24
 2428 00c8 00000000 		.4byte	.LFB25
 2429 00cc 48000000 		.4byte	.LFE25-.LFB25
 2430 00d0 00000000 		.4byte	.LFB26
 2431 00d4 44000000 		.4byte	.LFE26-.LFB26
 2432 00d8 00000000 		.4byte	.LFB27
 2433 00dc B8000000 		.4byte	.LFE27-.LFB27
 2434 00e0 00000000 		.4byte	.LFB28
 2435 00e4 12000000 		.4byte	.LFE28-.LFB28
 2436 00e8 00000000 		.4byte	0
 2437 00ec 00000000 		.4byte	0
 2438              		.section	.debug_ranges,"",%progbits
 2439              	.Ldebug_ranges0:
 2440 0000 00000000 		.4byte	.LFB2
 2441 0004 24000000 		.4byte	.LFE2
 2442 0008 00000000 		.4byte	.LFB3
 2443 000c 3C000000 		.4byte	.LFE3
 2444 0010 00000000 		.4byte	.LFB4
 2445 0014 5C000000 		.4byte	.LFE4
 2446 0018 00000000 		.4byte	.LFB5
 2447 001c 5C000000 		.4byte	.LFE5
 2448 0020 00000000 		.4byte	.LFB6
 2449 0024 0C000000 		.4byte	.LFE6
 2450 0028 00000000 		.4byte	.LFB7
 2451 002c 12000000 		.4byte	.LFE7
 2452 0030 00000000 		.4byte	.LFB8
 2453 0034 20000000 		.4byte	.LFE8
 2454 0038 00000000 		.4byte	.LFB9
 2455 003c 20000000 		.4byte	.LFE9
 2456 0040 00000000 		.4byte	.LFB10
 2457 0044 24000000 		.4byte	.LFE10
 2458 0048 00000000 		.4byte	.LFB11
 2459 004c 4C000000 		.4byte	.LFE11
 2460 0050 00000000 		.4byte	.LFB12
 2461 0054 24000000 		.4byte	.LFE12
 2462 0058 00000000 		.4byte	.LFB13
 2463 005c 30000000 		.4byte	.LFE13
 2464 0060 00000000 		.4byte	.LFB14
 2465 0064 44000000 		.4byte	.LFE14
 2466 0068 00000000 		.4byte	.LFB15
 2467 006c 12000000 		.4byte	.LFE15
 2468 0070 00000000 		.4byte	.LFB16
 2469 0074 20000000 		.4byte	.LFE16
 2470 0078 00000000 		.4byte	.LFB17
 2471 007c 20000000 		.4byte	.LFE17
 2472 0080 00000000 		.4byte	.LFB18
 2473 0084 20000000 		.4byte	.LFE18
 2474 0088 00000000 		.4byte	.LFB19
 2475 008c 2C000000 		.4byte	.LFE19
 2476 0090 00000000 		.4byte	.LFB20
 2477 0094 14000000 		.4byte	.LFE20
 2478 0098 00000000 		.4byte	.LFB21
 2479 009c 34000000 		.4byte	.LFE21
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 73


 2480 00a0 00000000 		.4byte	.LFB22
 2481 00a4 54000000 		.4byte	.LFE22
 2482 00a8 00000000 		.4byte	.LFB23
 2483 00ac 58000000 		.4byte	.LFE23
 2484 00b0 00000000 		.4byte	.LFB24
 2485 00b4 34000000 		.4byte	.LFE24
 2486 00b8 00000000 		.4byte	.LFB25
 2487 00bc 48000000 		.4byte	.LFE25
 2488 00c0 00000000 		.4byte	.LFB26
 2489 00c4 44000000 		.4byte	.LFE26
 2490 00c8 00000000 		.4byte	.LFB27
 2491 00cc B8000000 		.4byte	.LFE27
 2492 00d0 00000000 		.4byte	.LFB28
 2493 00d4 12000000 		.4byte	.LFE28
 2494 00d8 00000000 		.4byte	0
 2495 00dc 00000000 		.4byte	0
 2496              		.section	.debug_line,"",%progbits
 2497              	.Ldebug_line0:
 2498 0000 E9020000 		.section	.debug_str,"MS",%progbits,1
 2498      02004500 
 2498      00000201 
 2498      FB0E0D00 
 2498      01010101 
 2499              	.LASF10:
 2500 0000 75696E74 		.ascii	"uint16\000"
 2500      313600
 2501              	.LASF54:
 2502 0007 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 2502      5F315F43 
 2502      6C656172 
 2502      54784275 
 2502      66666572 
 2503              	.LASF44:
 2504 001c 74784461 		.ascii	"txDataByte\000"
 2504      74614279 
 2504      746500
 2505              	.LASF46:
 2506 0027 55415254 		.ascii	"UART_1_PutChar\000"
 2506      5F315F50 
 2506      75744368 
 2506      617200
 2507              	.LASF48:
 2508 0036 73747269 		.ascii	"string\000"
 2508      6E6700
 2509              	.LASF55:
 2510 003d 55415254 		.ascii	"UART_1_SendBreak\000"
 2510      5F315F53 
 2510      656E6442 
 2510      7265616B 
 2510      00
 2511              	.LASF27:
 2512 004e 55415254 		.ascii	"UART_1_ReadRxData\000"
 2512      5F315F52 
 2512      65616452 
 2512      78446174 
 2512      6100
 2513              	.LASF7:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 74


 2514 0060 6C6F6E67 		.ascii	"long long unsigned int\000"
 2514      206C6F6E 
 2514      6720756E 
 2514      7369676E 
 2514      65642069 
 2515              	.LASF53:
 2516 0077 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 2516      5F315F47 
 2516      65745478 
 2516      42756666 
 2516      65725369 
 2517              	.LASF6:
 2518 008e 6C6F6E67 		.ascii	"long long int\000"
 2518      206C6F6E 
 2518      6720696E 
 2518      7400
 2519              	.LASF0:
 2520 009c 7369676E 		.ascii	"signed char\000"
 2520      65642063 
 2520      68617200 
 2521              	.LASF52:
 2522 00a8 55415254 		.ascii	"UART_1_PutCRLF\000"
 2522      5F315F50 
 2522      75744352 
 2522      4C4600
 2523              	.LASF4:
 2524 00b7 6C6F6E67 		.ascii	"long int\000"
 2524      20696E74 
 2524      00
 2525              	.LASF62:
 2526 00c0 433A5C55 		.ascii	"C:\\Users\\Christina\\Documents\\For_fun\\GitHub\\D"
 2526      73657273 
 2526      5C436872 
 2526      69737469 
 2526      6E615C44 
 2527 00ed 65707265 		.ascii	"eprecated\\Corner-Module\\CornerModule\\CornerModul"
 2527      63617465 
 2527      645C436F 
 2527      726E6572 
 2527      2D4D6F64 
 2528 011d 652E6379 		.ascii	"e.cydsn\000"
 2528      64736E00 
 2529              	.LASF17:
 2530 0125 55415254 		.ascii	"UART_1_Start\000"
 2530      5F315F53 
 2530      74617274 
 2530      00
 2531              	.LASF9:
 2532 0132 75696E74 		.ascii	"uint8\000"
 2532      3800
 2533              	.LASF12:
 2534 0138 646F7562 		.ascii	"double\000"
 2534      6C6500
 2535              	.LASF38:
 2536 013f 61646472 		.ascii	"addressMode\000"
 2536      6573734D 
 2536      6F646500 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 75


 2537              	.LASF61:
 2538 014b 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART_1.c\000"
 2538      6E657261 
 2538      7465645F 
 2538      536F7572 
 2538      63655C50 
 2539              	.LASF28:
 2540 016d 55415254 		.ascii	"UART_1_ReadRxStatus\000"
 2540      5F315F52 
 2540      65616452 
 2540      78537461 
 2540      74757300 
 2541              	.LASF24:
 2542 0181 636F6E74 		.ascii	"control\000"
 2542      726F6C00 
 2543              	.LASF23:
 2544 0189 55415254 		.ascii	"UART_1_SetRxInterruptMode\000"
 2544      5F315F53 
 2544      65745278 
 2544      496E7465 
 2544      72727570 
 2545              	.LASF56:
 2546 01a3 7265744D 		.ascii	"retMode\000"
 2546      6F646500 
 2547              	.LASF8:
 2548 01ab 756E7369 		.ascii	"unsigned int\000"
 2548      676E6564 
 2548      20696E74 
 2548      00
 2549              	.LASF45:
 2550 01b8 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 2550      5F315F52 
 2550      65616454 
 2550      78537461 
 2550      74757300 
 2551              	.LASF5:
 2552 01cc 6C6F6E67 		.ascii	"long unsigned int\000"
 2552      20756E73 
 2552      69676E65 
 2552      6420696E 
 2552      7400
 2553              	.LASF35:
 2554 01de 73697A65 		.ascii	"size\000"
 2554      00
 2555              	.LASF3:
 2556 01e3 73686F72 		.ascii	"short unsigned int\000"
 2556      7420756E 
 2556      7369676E 
 2556      65642069 
 2556      6E7400
 2557              	.LASF19:
 2558 01f6 55415254 		.ascii	"UART_1_Enable\000"
 2558      5F315F45 
 2558      6E61626C 
 2558      6500
 2559              	.LASF59:
 2560 0204 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 76


 2560      5F315F53 
 2560      65745478 
 2560      41646472 
 2560      6573734D 
 2561              	.LASF58:
 2562 021c 74785F70 		.ascii	"tx_period\000"
 2562      6572696F 
 2562      6400
 2563              	.LASF25:
 2564 0226 696E7453 		.ascii	"intSrc\000"
 2564      726300
 2565              	.LASF32:
 2566 022d 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 2566      5F315F52 
 2566      65616443 
 2566      6F6E7472 
 2566      6F6C5265 
 2567              	.LASF20:
 2568 0248 55415254 		.ascii	"UART_1_Stop\000"
 2568      5F315F53 
 2568      746F7000 
 2569              	.LASF33:
 2570 0254 55415254 		.ascii	"UART_1_GetByte\000"
 2570      5F315F47 
 2570      65744279 
 2570      746500
 2571              	.LASF43:
 2572 0263 55415254 		.ascii	"UART_1_WriteTxData\000"
 2572      5F315F57 
 2572      72697465 
 2572      54784461 
 2572      746100
 2573              	.LASF57:
 2574 0276 746D7053 		.ascii	"tmpStat\000"
 2574      74617400 
 2575              	.LASF16:
 2576 027e 73697A65 		.ascii	"sizetype\000"
 2576      74797065 
 2576      00
 2577              	.LASF39:
 2578 0287 55415254 		.ascii	"UART_1_SetRxAddress1\000"
 2578      5F315F53 
 2578      65745278 
 2578      41646472 
 2578      65737331 
 2579              	.LASF41:
 2580 029c 55415254 		.ascii	"UART_1_SetRxAddress2\000"
 2580      5F315F53 
 2580      65745278 
 2580      41646472 
 2580      65737332 
 2581              	.LASF40:
 2582 02b1 61646472 		.ascii	"address\000"
 2582      65737300 
 2583              	.LASF31:
 2584 02b9 72785374 		.ascii	"rxStatus\000"
 2584      61747573 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 77


 2584      00
 2585              	.LASF42:
 2586 02c2 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 2586      5F315F53 
 2586      65745478 
 2586      496E7465 
 2586      72727570 
 2587              	.LASF11:
 2588 02dc 666C6F61 		.ascii	"float\000"
 2588      7400
 2589              	.LASF47:
 2590 02e2 55415254 		.ascii	"UART_1_PutString\000"
 2590      5F315F50 
 2590      75745374 
 2590      72696E67 
 2590      00
 2591              	.LASF36:
 2592 02f3 55415254 		.ascii	"UART_1_ClearRxBuffer\000"
 2592      5F315F43 
 2592      6C656172 
 2592      52784275 
 2592      66666572 
 2593              	.LASF37:
 2594 0308 55415254 		.ascii	"UART_1_SetRxAddressMode\000"
 2594      5F315F53 
 2594      65745278 
 2594      41646472 
 2594      6573734D 
 2595              	.LASF15:
 2596 0320 72656738 		.ascii	"reg8\000"
 2596      00
 2597              	.LASF1:
 2598 0325 756E7369 		.ascii	"unsigned char\000"
 2598      676E6564 
 2598      20636861 
 2598      7200
 2599              	.LASF2:
 2600 0333 73686F72 		.ascii	"short int\000"
 2600      7420696E 
 2600      7400
 2601              	.LASF22:
 2602 033d 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 2602      5F315F57 
 2602      72697465 
 2602      436F6E74 
 2602      726F6C52 
 2603              	.LASF63:
 2604 0359 55415254 		.ascii	"UART_1_initVar\000"
 2604      5F315F69 
 2604      6E697456 
 2604      617200
 2605              	.LASF51:
 2606 0368 62797465 		.ascii	"byteCount\000"
 2606      436F756E 
 2606      7400
 2607              	.LASF34:
 2608 0372 55415254 		.ascii	"UART_1_GetRxBufferSize\000"
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 78


 2608      5F315F47 
 2608      65745278 
 2608      42756666 
 2608      65725369 
 2609              	.LASF26:
 2610 0389 72784461 		.ascii	"rxData\000"
 2610      746100
 2611              	.LASF14:
 2612 0390 63686172 		.ascii	"char\000"
 2612      00
 2613              	.LASF13:
 2614 0395 63686172 		.ascii	"char8\000"
 2614      3800
 2615              	.LASF18:
 2616 039b 55415254 		.ascii	"UART_1_Init\000"
 2616      5F315F49 
 2616      6E697400 
 2617              	.LASF21:
 2618 03a7 656E6162 		.ascii	"enableInterrupts\000"
 2618      6C65496E 
 2618      74657272 
 2618      75707473 
 2618      00
 2619              	.LASF29:
 2620 03b8 73746174 		.ascii	"status\000"
 2620      757300
 2621              	.LASF60:
 2622 03bf 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 2622      4320342E 
 2622      392E3320 
 2622      32303135 
 2622      30333033 
 2623 03f2 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0 -mthumb -g -O"
 2623      20726576 
 2623      6973696F 
 2623      6E203232 
 2623      31323230 
 2624 0425 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 2624      66756E63 
 2624      74696F6E 
 2624      2D736563 
 2624      74696F6E 
 2625              	.LASF30:
 2626 044d 55415254 		.ascii	"UART_1_GetChar\000"
 2626      5F315F47 
 2626      65744368 
 2626      617200
 2627              	.LASF49:
 2628 045c 6275665F 		.ascii	"buf_index\000"
 2628      696E6465 
 2628      7800
 2629              	.LASF50:
 2630 0466 55415254 		.ascii	"UART_1_PutArray\000"
 2630      5F315F50 
 2630      75744172 
 2630      72617900 
 2631              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccZdYIuY.s 			page 79


