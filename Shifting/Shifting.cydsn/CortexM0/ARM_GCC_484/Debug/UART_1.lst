ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART_1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_1_initVar
  18              		.bss
  19              		.type	UART_1_initVar, %object
  20              		.size	UART_1_initVar, 1
  21              	UART_1_initVar:
  22 0000 00       		.space	1
  23              		.global	UART_1_errorStatus
  24              		.type	UART_1_errorStatus, %object
  25              		.size	UART_1_errorStatus, 1
  26              	UART_1_errorStatus:
  27 0001 00       		.space	1
  28              		.comm	UART_1_rxBuffer,13,4
  29              		.global	UART_1_rxBufferRead
  30              		.type	UART_1_rxBufferRead, %object
  31              		.size	UART_1_rxBufferRead, 1
  32              	UART_1_rxBufferRead:
  33 0002 00       		.space	1
  34              		.global	UART_1_rxBufferWrite
  35              		.type	UART_1_rxBufferWrite, %object
  36              		.size	UART_1_rxBufferWrite, 1
  37              	UART_1_rxBufferWrite:
  38 0003 00       		.space	1
  39              		.global	UART_1_rxBufferLoopDetect
  40              		.type	UART_1_rxBufferLoopDetect, %object
  41              		.size	UART_1_rxBufferLoopDetect, 1
  42              	UART_1_rxBufferLoopDetect:
  43 0004 00       		.space	1
  44              		.global	UART_1_rxBufferOverflow
  45              		.type	UART_1_rxBufferOverflow, %object
  46              		.size	UART_1_rxBufferOverflow, 1
  47              	UART_1_rxBufferOverflow:
  48 0005 00       		.space	1
  49              		.section	.text.UART_1_Start,"ax",%progbits
  50              		.align	2
  51              		.global	UART_1_Start
  52              		.code	16
  53              		.thumb_func
  54              		.type	UART_1_Start, %function
  55              	UART_1_Start:
  56              	.LFB0:
  57              		.file 1 ".\\Generated_Source\\PSoC4\\UART_1.c"
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 2


   1:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC4/UART_1.c **** * Version 2.40
   4:.\Generated_Source\PSoC4/UART_1.c **** *
   5:.\Generated_Source\PSoC4/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC4/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART_1.c **** *
   8:.\Generated_Source\PSoC4/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC4/UART_1.c **** *
  10:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART_1.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART_1.c **** 
  17:.\Generated_Source\PSoC4/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC4/UART_1.c **** #if (UART_1_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC4/UART_1.c ****     #include "UART_1_IntClock.h"
  20:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC4/UART_1.c **** 
  22:.\Generated_Source\PSoC4/UART_1.c **** 
  23:.\Generated_Source\PSoC4/UART_1.c **** /***************************************
  24:.\Generated_Source\PSoC4/UART_1.c **** * Global data allocation
  25:.\Generated_Source\PSoC4/UART_1.c **** ***************************************/
  26:.\Generated_Source\PSoC4/UART_1.c **** 
  27:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_initVar = 0u;
  28:.\Generated_Source\PSoC4/UART_1.c **** 
  29:.\Generated_Source\PSoC4/UART_1.c **** #if (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED)
  30:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART_1.c **** #endif /* (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED) */
  34:.\Generated_Source\PSoC4/UART_1.c **** 
  35:.\Generated_Source\PSoC4/UART_1.c **** #if (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED))
  36:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_errorStatus = 0u;
  37:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC4/UART_1.c **** #endif /* (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED)) */
  47:.\Generated_Source\PSoC4/UART_1.c **** 
  48:.\Generated_Source\PSoC4/UART_1.c **** 
  49:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Start
  51:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  52:.\Generated_Source\PSoC4/UART_1.c **** *
  53:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  54:.\Generated_Source\PSoC4/UART_1.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Init() function, and then calls the
  57:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Enable() function.
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 3


  58:.\Generated_Source\PSoC4/UART_1.c **** *
  59:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  60:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC4/UART_1.c **** *
  62:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  63:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  64:.\Generated_Source\PSoC4/UART_1.c **** *
  65:.\Generated_Source\PSoC4/UART_1.c **** * Global variables:
  66:.\Generated_Source\PSoC4/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC4/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC4/UART_1.c **** *  and set to one (1u) the first time UART_1_Start() is called. This
  69:.\Generated_Source\PSoC4/UART_1.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC4/UART_1.c **** *  subsequent calls to the UART_1_Start() routine.
  71:.\Generated_Source\PSoC4/UART_1.c **** *
  72:.\Generated_Source\PSoC4/UART_1.c **** * Reentrant:
  73:.\Generated_Source\PSoC4/UART_1.c **** *  No.
  74:.\Generated_Source\PSoC4/UART_1.c **** *
  75:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Start(void) 
  77:.\Generated_Source\PSoC4/UART_1.c **** {
  58              		.loc 1 77 0
  59              		.cfi_startproc
  60 0000 80B5     		push	{r7, lr}
  61              		.cfi_def_cfa_offset 8
  62              		.cfi_offset 7, -8
  63              		.cfi_offset 14, -4
  64 0002 00AF     		add	r7, sp, #0
  65              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC4/UART_1.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC4/UART_1.c ****     if(UART_1_initVar == 0u)
  66              		.loc 1 79 0
  67 0004 064B     		ldr	r3, .L3
  68 0006 1B78     		ldrb	r3, [r3]
  69 0008 002B     		cmp	r3, #0
  70 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC4/UART_1.c ****     {
  81:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_Init();
  71              		.loc 1 81 0
  72 000c FFF7FEFF 		bl	UART_1_Init
  82:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_initVar = 1u;
  73              		.loc 1 82 0
  74 0010 034B     		ldr	r3, .L3
  75 0012 0122     		mov	r2, #1
  76 0014 1A70     		strb	r2, [r3]
  77              	.L2:
  83:.\Generated_Source\PSoC4/UART_1.c ****     }
  84:.\Generated_Source\PSoC4/UART_1.c **** 
  85:.\Generated_Source\PSoC4/UART_1.c ****     UART_1_Enable();
  78              		.loc 1 85 0
  79 0016 FFF7FEFF 		bl	UART_1_Enable
  86:.\Generated_Source\PSoC4/UART_1.c **** }
  80              		.loc 1 86 0
  81 001a BD46     		mov	sp, r7
  82              		@ sp needed
  83 001c 80BD     		pop	{r7, pc}
  84              	.L4:
  85 001e C046     		.align	2
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 4


  86              	.L3:
  87 0020 00000000 		.word	UART_1_initVar
  88              		.cfi_endproc
  89              	.LFE0:
  90              		.size	UART_1_Start, .-UART_1_Start
  91              		.section	.text.UART_1_Init,"ax",%progbits
  92              		.align	2
  93              		.global	UART_1_Init
  94              		.code	16
  95              		.thumb_func
  96              		.type	UART_1_Init, %function
  97              	UART_1_Init:
  98              	.LFB1:
  87:.\Generated_Source\PSoC4/UART_1.c **** 
  88:.\Generated_Source\PSoC4/UART_1.c **** 
  89:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Init
  91:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  92:.\Generated_Source\PSoC4/UART_1.c **** *
  93:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  94:.\Generated_Source\PSoC4/UART_1.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC4/UART_1.c **** *  dialog settings. It is not necessary to call UART_1_Init() because
  96:.\Generated_Source\PSoC4/UART_1.c **** *  the UART_1_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC4/UART_1.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC4/UART_1.c **** *
  99:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 100:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 101:.\Generated_Source\PSoC4/UART_1.c **** *
 102:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 103:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 104:.\Generated_Source\PSoC4/UART_1.c **** *
 105:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Init(void) 
 107:.\Generated_Source\PSoC4/UART_1.c **** {
  99              		.loc 1 107 0
 100              		.cfi_startproc
 101 0000 80B5     		push	{r7, lr}
 102              		.cfi_def_cfa_offset 8
 103              		.cfi_offset 7, -8
 104              		.cfi_offset 14, -4
 105 0002 00AF     		add	r7, sp, #0
 106              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 109:.\Generated_Source\PSoC4/UART_1.c **** 
 110:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC4/UART_1.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC4/UART_1.c ****             (void) CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 107              		.loc 1 112 0
 108 0004 0E4B     		ldr	r3, .L6
 109 0006 0020     		mov	r0, #0
 110 0008 191C     		mov	r1, r3
 111 000a FFF7FEFF 		bl	CyIntSetVector
 113:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 112              		.loc 1 113 0
 113 000e 0020     		mov	r0, #0
 114 0010 0321     		mov	r1, #3
 115 0012 FFF7FEFF 		bl	CyIntSetPriority
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 5


 114:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_errorStatus = 0u;
 116              		.loc 1 114 0
 117 0016 0B4B     		ldr	r3, .L6+4
 118 0018 0022     		mov	r2, #0
 119 001a 1A70     		strb	r2, [r3]
 115:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC4/UART_1.c **** 
 117:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC4/UART_1.c **** 
 123:.\Generated_Source\PSoC4/UART_1.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 120              		.loc 1 124 0
 121 001c 0A4B     		ldr	r3, .L6+8
 122 001e 7222     		mov	r2, #114
 123 0020 1A70     		strb	r2, [r3]
 125:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 124              		.loc 1 126 0
 125 0022 0A4B     		ldr	r3, .L6+12
 126 0024 2022     		mov	r2, #32
 127 0026 1A70     		strb	r2, [r3]
 127:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 128:.\Generated_Source\PSoC4/UART_1.c **** 
 129:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 130:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC4/UART_1.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC4/UART_1.c ****             (void) CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 133:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC4/UART_1.c **** 
 136:.\Generated_Source\PSoC4/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
 128              		.loc 1 138 0
 129 0028 094B     		ldr	r3, .L6+16
 130 002a 0622     		mov	r2, #6
 131 002c 1A70     		strb	r2, [r3]
 139:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 132              		.loc 1 139 0
 133 002e 094B     		ldr	r3, .L6+20
 134 0030 4722     		mov	r2, #71
 135 0032 1A70     		strb	r2, [r3]
 140:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT) - 1u;
 141:.\Generated_Source\PSoC4/UART_1.c ****         #else
 142:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 143:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC4/UART_1.c **** 
 146:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC4/UART_1.c ****         #else
 150:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 6


 136              		.loc 1 150 0
 137 0034 084B     		ldr	r3, .L6+24
 138 0036 0022     		mov	r2, #0
 139 0038 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC4/UART_1.c **** 
 153:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 154:.\Generated_Source\PSoC4/UART_1.c **** 
 155:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_WriteControlRegister( \
 157:.\Generated_Source\PSoC4/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC4/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC4/UART_1.c **** }
 140              		.loc 1 160 0
 141 003a BD46     		mov	sp, r7
 142              		@ sp needed
 143 003c 80BD     		pop	{r7, pc}
 144              	.L7:
 145 003e C046     		.align	2
 146              	.L6:
 147 0040 00000000 		.word	UART_1_RXISR
 148 0044 00000000 		.word	UART_1_errorStatus
 149 0048 82000F40 		.word	1074724994
 150 004c 80000F40 		.word	1074724992
 151 0050 20000F40 		.word	1074724896
 152 0054 30000F40 		.word	1074724912
 153 0058 81000F40 		.word	1074724993
 154              		.cfi_endproc
 155              	.LFE1:
 156              		.size	UART_1_Init, .-UART_1_Init
 157              		.section	.text.UART_1_Enable,"ax",%progbits
 158              		.align	2
 159              		.global	UART_1_Enable
 160              		.code	16
 161              		.thumb_func
 162              		.type	UART_1_Enable, %function
 163              	UART_1_Enable:
 164              	.LFB2:
 161:.\Generated_Source\PSoC4/UART_1.c **** 
 162:.\Generated_Source\PSoC4/UART_1.c **** 
 163:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Enable
 165:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 166:.\Generated_Source\PSoC4/UART_1.c **** *
 167:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 168:.\Generated_Source\PSoC4/UART_1.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:.\Generated_Source\PSoC4/UART_1.c **** *  to call UART_1_Enable() because the UART_1_Start() API
 170:.\Generated_Source\PSoC4/UART_1.c **** *  calls this function, which is the preferred method to begin component
 171:.\Generated_Source\PSoC4/UART_1.c **** *  operation.
 172:.\Generated_Source\PSoC4/UART_1.c **** 
 173:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 174:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 175:.\Generated_Source\PSoC4/UART_1.c **** *
 176:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 177:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 178:.\Generated_Source\PSoC4/UART_1.c **** *
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 7


 179:.\Generated_Source\PSoC4/UART_1.c **** * Global Variables:
 180:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC4/UART_1.c **** *
 182:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Enable(void) 
 184:.\Generated_Source\PSoC4/UART_1.c **** {
 165              		.loc 1 184 0
 166              		.cfi_startproc
 167 0000 90B5     		push	{r4, r7, lr}
 168              		.cfi_def_cfa_offset 12
 169              		.cfi_offset 4, -12
 170              		.cfi_offset 7, -8
 171              		.cfi_offset 14, -4
 172 0002 83B0     		sub	sp, sp, #12
 173              		.cfi_def_cfa_offset 24
 174 0004 00AF     		add	r7, sp, #0
 175              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 176              		.loc 1 186 0
 177 0006 FC1D     		add	r4, r7, #7
 178 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 179 000c 031C     		mov	r3, r0
 180 000e 2370     		strb	r3, [r4]
 187:.\Generated_Source\PSoC4/UART_1.c **** 
 188:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 189:.\Generated_Source\PSoC4/UART_1.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 181              		.loc 1 190 0
 182 0010 124B     		ldr	r3, .L9
 183 0012 124A     		ldr	r2, .L9
 184 0014 1278     		ldrb	r2, [r2]
 185 0016 D2B2     		uxtb	r2, r2
 186 0018 2021     		mov	r1, #32
 187 001a 0A43     		orr	r2, r1
 188 001c D2B2     		uxtb	r2, r2
 189 001e 1A70     		strb	r2, [r3]
 191:.\Generated_Source\PSoC4/UART_1.c **** 
 192:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 190              		.loc 1 193 0
 191 0020 0F4B     		ldr	r3, .L9+4
 192 0022 0F4A     		ldr	r2, .L9+4
 193 0024 1278     		ldrb	r2, [r2]
 194 0026 D2B2     		uxtb	r2, r2
 195 0028 1021     		mov	r1, #16
 196 002a 0A43     		orr	r2, r1
 197 002c D2B2     		uxtb	r2, r2
 198 002e 1A70     		strb	r2, [r3]
 194:.\Generated_Source\PSoC4/UART_1.c **** 
 195:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableRxInt();
 199              		.loc 1 196 0
 200 0030 0020     		mov	r0, #0
 201 0032 FFF7FEFF 		bl	CyIntEnable
 197:.\Generated_Source\PSoC4/UART_1.c **** 
 198:.\Generated_Source\PSoC4/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 8


 199:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 203:.\Generated_Source\PSoC4/UART_1.c **** 
 204:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 205:.\Generated_Source\PSoC4/UART_1.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 207:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 208:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC4/UART_1.c **** 
 210:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 202              		.loc 1 211 0
 203 0036 0B4B     		ldr	r3, .L9+8
 204 0038 0A4A     		ldr	r2, .L9+8
 205 003a 1278     		ldrb	r2, [r2]
 206 003c D2B2     		uxtb	r2, r2
 207 003e 1021     		mov	r1, #16
 208 0040 0A43     		orr	r2, r1
 209 0042 D2B2     		uxtb	r2, r2
 210 0044 1A70     		strb	r2, [r3]
 212:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
 215:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC4/UART_1.c ****      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC4/UART_1.c **** 
 218:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Start();  /* Enable the clock */
 211              		.loc 1 219 0
 212 0046 FFF7FEFF 		bl	UART_1_IntClock_Start
 220:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC4/UART_1.c **** 
 222:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 213              		.loc 1 222 0
 214 004a FB1D     		add	r3, r7, #7
 215 004c 1B78     		ldrb	r3, [r3]
 216 004e 181C     		mov	r0, r3
 217 0050 FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC4/UART_1.c **** }
 218              		.loc 1 223 0
 219 0054 BD46     		mov	sp, r7
 220 0056 03B0     		add	sp, sp, #12
 221              		@ sp needed
 222 0058 90BD     		pop	{r4, r7, pc}
 223              	.L10:
 224 005a C046     		.align	2
 225              	.L9:
 226 005c 92000F40 		.word	1074725010
 227 0060 90000F40 		.word	1074725008
 228 0064 91000F40 		.word	1074725009
 229              		.cfi_endproc
 230              	.LFE2:
 231              		.size	UART_1_Enable, .-UART_1_Enable
 232              		.section	.text.UART_1_Stop,"ax",%progbits
 233              		.align	2
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 9


 234              		.global	UART_1_Stop
 235              		.code	16
 236              		.thumb_func
 237              		.type	UART_1_Stop, %function
 238              	UART_1_Stop:
 239              	.LFB3:
 224:.\Generated_Source\PSoC4/UART_1.c **** 
 225:.\Generated_Source\PSoC4/UART_1.c **** 
 226:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Stop
 228:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 229:.\Generated_Source\PSoC4/UART_1.c **** *
 230:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 231:.\Generated_Source\PSoC4/UART_1.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC4/UART_1.c **** *
 233:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 234:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 235:.\Generated_Source\PSoC4/UART_1.c **** *
 236:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 237:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 238:.\Generated_Source\PSoC4/UART_1.c **** *
 239:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Stop(void) 
 241:.\Generated_Source\PSoC4/UART_1.c **** {
 240              		.loc 1 241 0
 241              		.cfi_startproc
 242 0000 90B5     		push	{r4, r7, lr}
 243              		.cfi_def_cfa_offset 12
 244              		.cfi_offset 4, -12
 245              		.cfi_offset 7, -8
 246              		.cfi_offset 14, -4
 247 0002 83B0     		sub	sp, sp, #12
 248              		.cfi_def_cfa_offset 24
 249 0004 00AF     		add	r7, sp, #0
 250              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 251              		.loc 1 243 0
 252 0006 FC1D     		add	r4, r7, #7
 253 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 254 000c 031C     		mov	r3, r0
 255 000e 2370     		strb	r3, [r4]
 244:.\Generated_Source\PSoC4/UART_1.c **** 
 245:.\Generated_Source\PSoC4/UART_1.c ****     /* Write Bit Counter Disable */
 246:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 247:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 256              		.loc 1 247 0
 257 0010 124B     		ldr	r3, .L12
 258 0012 124A     		ldr	r2, .L12
 259 0014 1278     		ldrb	r2, [r2]
 260 0016 D2B2     		uxtb	r2, r2
 261 0018 2021     		mov	r1, #32
 262 001a 8A43     		bic	r2, r1
 263 001c D2B2     		uxtb	r2, r2
 264 001e 1A70     		strb	r2, [r3]
 248:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 249:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 10


 250:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_ENABLED)
 251:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 253:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (!UART_1_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 255:.\Generated_Source\PSoC4/UART_1.c **** 
 256:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Stop();   /* Disable the clock */
 265              		.loc 1 257 0
 266 0020 FFF7FEFF 		bl	UART_1_IntClock_Stop
 258:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 259:.\Generated_Source\PSoC4/UART_1.c **** 
 260:.\Generated_Source\PSoC4/UART_1.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 262:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8) ~UART_1_INT_ENABLE;
 267              		.loc 1 262 0
 268 0024 0E4B     		ldr	r3, .L12+4
 269 0026 0E4A     		ldr	r2, .L12+4
 270 0028 1278     		ldrb	r2, [r2]
 271 002a D2B2     		uxtb	r2, r2
 272 002c 1021     		mov	r1, #16
 273 002e 8A43     		bic	r2, r1
 274 0030 D2B2     		uxtb	r2, r2
 275 0032 1A70     		strb	r2, [r3]
 263:.\Generated_Source\PSoC4/UART_1.c **** 
 264:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableRxInt();
 276              		.loc 1 265 0
 277 0034 0020     		mov	r0, #0
 278 0036 FFF7FEFF 		bl	CyIntDisable
 266:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 267:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 268:.\Generated_Source\PSoC4/UART_1.c **** 
 269:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_ENABLED)
 270:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8) ~UART_1_INT_ENABLE;
 279              		.loc 1 270 0
 280 003a 0A4B     		ldr	r3, .L12+8
 281 003c 094A     		ldr	r2, .L12+8
 282 003e 1278     		ldrb	r2, [r2]
 283 0040 D2B2     		uxtb	r2, r2
 284 0042 1021     		mov	r1, #16
 285 0044 8A43     		bic	r2, r1
 286 0046 D2B2     		uxtb	r2, r2
 287 0048 1A70     		strb	r2, [r3]
 271:.\Generated_Source\PSoC4/UART_1.c **** 
 272:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 273:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 274:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 276:.\Generated_Source\PSoC4/UART_1.c **** 
 277:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 288              		.loc 1 277 0
 289 004a FB1D     		add	r3, r7, #7
 290 004c 1B78     		ldrb	r3, [r3]
 291 004e 181C     		mov	r0, r3
 292 0050 FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC4/UART_1.c **** }
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 11


 293              		.loc 1 278 0
 294 0054 BD46     		mov	sp, r7
 295 0056 03B0     		add	sp, sp, #12
 296              		@ sp needed
 297 0058 90BD     		pop	{r4, r7, pc}
 298              	.L13:
 299 005a C046     		.align	2
 300              	.L12:
 301 005c 92000F40 		.word	1074725010
 302 0060 90000F40 		.word	1074725008
 303 0064 91000F40 		.word	1074725009
 304              		.cfi_endproc
 305              	.LFE3:
 306              		.size	UART_1_Stop, .-UART_1_Stop
 307              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 308              		.align	2
 309              		.global	UART_1_ReadControlRegister
 310              		.code	16
 311              		.thumb_func
 312              		.type	UART_1_ReadControlRegister, %function
 313              	UART_1_ReadControlRegister:
 314              	.LFB4:
 279:.\Generated_Source\PSoC4/UART_1.c **** 
 280:.\Generated_Source\PSoC4/UART_1.c **** 
 281:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 283:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 284:.\Generated_Source\PSoC4/UART_1.c **** *
 285:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 286:.\Generated_Source\PSoC4/UART_1.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC4/UART_1.c **** *
 288:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 289:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 290:.\Generated_Source\PSoC4/UART_1.c **** *
 291:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 292:.\Generated_Source\PSoC4/UART_1.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC4/UART_1.c **** *
 294:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC4/UART_1.c **** {
 315              		.loc 1 296 0
 316              		.cfi_startproc
 317 0000 80B5     		push	{r7, lr}
 318              		.cfi_def_cfa_offset 8
 319              		.cfi_offset 7, -8
 320              		.cfi_offset 14, -4
 321 0002 00AF     		add	r7, sp, #0
 322              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC4/UART_1.c ****         return(0u);
 323              		.loc 1 298 0
 324 0004 0023     		mov	r3, #0
 299:.\Generated_Source\PSoC4/UART_1.c ****     #else
 300:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_CONTROL_REG);
 301:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC4/UART_1.c **** }
 325              		.loc 1 302 0
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 12


 326 0006 181C     		mov	r0, r3
 327 0008 BD46     		mov	sp, r7
 328              		@ sp needed
 329 000a 80BD     		pop	{r7, pc}
 330              		.cfi_endproc
 331              	.LFE4:
 332              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 333              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 334              		.align	2
 335              		.global	UART_1_WriteControlRegister
 336              		.code	16
 337              		.thumb_func
 338              		.type	UART_1_WriteControlRegister, %function
 339              	UART_1_WriteControlRegister:
 340              	.LFB5:
 303:.\Generated_Source\PSoC4/UART_1.c **** 
 304:.\Generated_Source\PSoC4/UART_1.c **** 
 305:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 306:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 307:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 308:.\Generated_Source\PSoC4/UART_1.c **** *
 309:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 310:.\Generated_Source\PSoC4/UART_1.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC4/UART_1.c **** *
 312:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 313:.\Generated_Source\PSoC4/UART_1.c **** *  control:  control register value
 314:.\Generated_Source\PSoC4/UART_1.c **** *
 315:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 316:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 317:.\Generated_Source\PSoC4/UART_1.c **** *
 318:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC4/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC4/UART_1.c **** {
 341              		.loc 1 320 0
 342              		.cfi_startproc
 343 0000 80B5     		push	{r7, lr}
 344              		.cfi_def_cfa_offset 8
 345              		.cfi_offset 7, -8
 346              		.cfi_offset 14, -4
 347 0002 82B0     		sub	sp, sp, #8
 348              		.cfi_def_cfa_offset 16
 349 0004 00AF     		add	r7, sp, #0
 350              		.cfi_def_cfa_register 7
 351 0006 021C     		mov	r2, r0
 352 0008 FB1D     		add	r3, r7, #7
 353 000a 1A70     		strb	r2, [r3]
 321:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 322:.\Generated_Source\PSoC4/UART_1.c ****         if(0u != control)
 323:.\Generated_Source\PSoC4/UART_1.c ****         {
 324:.\Generated_Source\PSoC4/UART_1.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC4/UART_1.c ****         }
 326:.\Generated_Source\PSoC4/UART_1.c ****     #else
 327:.\Generated_Source\PSoC4/UART_1.c ****        UART_1_CONTROL_REG = control;
 328:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC4/UART_1.c **** }
 354              		.loc 1 329 0
 355 000c BD46     		mov	sp, r7
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 13


 356 000e 02B0     		add	sp, sp, #8
 357              		@ sp needed
 358 0010 80BD     		pop	{r7, pc}
 359              		.cfi_endproc
 360              	.LFE5:
 361              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 362 0012 C046     		.section	.text.UART_1_SetRxInterruptMode,"ax",%progbits
 363              		.align	2
 364              		.global	UART_1_SetRxInterruptMode
 365              		.code	16
 366              		.thumb_func
 367              		.type	UART_1_SetRxInterruptMode, %function
 368              	UART_1_SetRxInterruptMode:
 369              	.LFB6:
 330:.\Generated_Source\PSoC4/UART_1.c **** 
 331:.\Generated_Source\PSoC4/UART_1.c **** 
 332:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 333:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 335:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC4/UART_1.c ****     *
 337:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 338:.\Generated_Source\PSoC4/UART_1.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC4/UART_1.c ****     *
 340:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 341:.\Generated_Source\PSoC4/UART_1.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC4/UART_1.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC4/UART_1.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_MRKSPC           Interrupt on address detect.
 351:.\Generated_Source\PSoC4/UART_1.c ****     *
 352:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 353:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 354:.\Generated_Source\PSoC4/UART_1.c ****     *
 355:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 356:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC4/UART_1.c ****     *
 358:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC4/UART_1.c ****     {
 370              		.loc 1 360 0
 371              		.cfi_startproc
 372 0000 80B5     		push	{r7, lr}
 373              		.cfi_def_cfa_offset 8
 374              		.cfi_offset 7, -8
 375              		.cfi_offset 14, -4
 376 0002 82B0     		sub	sp, sp, #8
 377              		.cfi_def_cfa_offset 16
 378 0004 00AF     		add	r7, sp, #0
 379              		.cfi_def_cfa_register 7
 380 0006 021C     		mov	r2, r0
 381 0008 FB1D     		add	r3, r7, #7
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 14


 382 000a 1A70     		strb	r2, [r3]
 361:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 383              		.loc 1 361 0
 384 000c 034B     		ldr	r3, .L18
 385 000e FA1D     		add	r2, r7, #7
 386 0010 1278     		ldrb	r2, [r2]
 387 0012 1A70     		strb	r2, [r3]
 362:.\Generated_Source\PSoC4/UART_1.c ****     }
 388              		.loc 1 362 0
 389 0014 BD46     		mov	sp, r7
 390 0016 02B0     		add	sp, sp, #8
 391              		@ sp needed
 392 0018 80BD     		pop	{r7, pc}
 393              	.L19:
 394 001a C046     		.align	2
 395              	.L18:
 396 001c 80000F40 		.word	1074724992
 397              		.cfi_endproc
 398              	.LFE6:
 399              		.size	UART_1_SetRxInterruptMode, .-UART_1_SetRxInterruptMode
 400              		.section	.text.UART_1_ReadRxData,"ax",%progbits
 401              		.align	2
 402              		.global	UART_1_ReadRxData
 403              		.code	16
 404              		.thumb_func
 405              		.type	UART_1_ReadRxData, %function
 406              	UART_1_ReadRxData:
 407              	.LFB7:
 363:.\Generated_Source\PSoC4/UART_1.c **** 
 364:.\Generated_Source\PSoC4/UART_1.c **** 
 365:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxData
 367:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC4/UART_1.c ****     *
 369:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 370:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC4/UART_1.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC4/UART_1.c ****     *
 373:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 374:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 375:.\Generated_Source\PSoC4/UART_1.c ****     *
 376:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 377:.\Generated_Source\PSoC4/UART_1.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC4/UART_1.c ****     *
 379:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 380:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 381:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 382:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 385:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC4/UART_1.c ****     *
 388:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 389:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 390:.\Generated_Source\PSoC4/UART_1.c ****     *
 391:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 15


 392:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 393:.\Generated_Source\PSoC4/UART_1.c ****     {
 408              		.loc 1 393 0
 409              		.cfi_startproc
 410 0000 80B5     		push	{r7, lr}
 411              		.cfi_def_cfa_offset 8
 412              		.cfi_offset 7, -8
 413              		.cfi_offset 14, -4
 414 0002 82B0     		sub	sp, sp, #8
 415              		.cfi_def_cfa_offset 16
 416 0004 00AF     		add	r7, sp, #0
 417              		.cfi_def_cfa_register 7
 394:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC4/UART_1.c **** 
 396:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC4/UART_1.c **** 
 398:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC4/UART_1.c **** 
 401:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 418              		.loc 1 402 0
 419 0006 0020     		mov	r0, #0
 420 0008 FFF7FEFF 		bl	CyIntDisable
 403:.\Generated_Source\PSoC4/UART_1.c **** 
 404:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 421              		.loc 1 404 0
 422 000c BB1D     		add	r3, r7, #6
 423 000e 1F4A     		ldr	r2, .L27
 424 0010 1278     		ldrb	r2, [r2]
 425 0012 1A70     		strb	r2, [r3]
 405:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 426              		.loc 1 405 0
 427 0014 7B1D     		add	r3, r7, #5
 428 0016 1E4A     		ldr	r2, .L27+4
 429 0018 1278     		ldrb	r2, [r2]
 430 001a 1A70     		strb	r2, [r3]
 406:.\Generated_Source\PSoC4/UART_1.c **** 
 407:.\Generated_Source\PSoC4/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 431              		.loc 1 407 0
 432 001c 1D4B     		ldr	r3, .L27+8
 433 001e 1B78     		ldrb	r3, [r3]
 434 0020 DBB2     		uxtb	r3, r3
 435 0022 002B     		cmp	r3, #0
 436 0024 05D1     		bne	.L21
 437              		.loc 1 407 0 is_stmt 0 discriminator 1
 438 0026 BA1D     		add	r2, r7, #6
 439 0028 7B1D     		add	r3, r7, #5
 440 002a 1278     		ldrb	r2, [r2]
 441 002c 1B78     		ldrb	r3, [r3]
 442 002e 9A42     		cmp	r2, r3
 443 0030 1FD0     		beq	.L22
 444              	.L21:
 408:.\Generated_Source\PSoC4/UART_1.c ****         {
 409:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 445              		.loc 1 409 0 is_stmt 1
 446 0032 BB1D     		add	r3, r7, #6
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 16


 447 0034 1A78     		ldrb	r2, [r3]
 448 0036 FB1D     		add	r3, r7, #7
 449 0038 1749     		ldr	r1, .L27+12
 450 003a 8A5C     		ldrb	r2, [r1, r2]
 451 003c 1A70     		strb	r2, [r3]
 410:.\Generated_Source\PSoC4/UART_1.c ****             locRxBufferRead++;
 452              		.loc 1 410 0
 453 003e BB1D     		add	r3, r7, #6
 454 0040 1A78     		ldrb	r2, [r3]
 455 0042 BB1D     		add	r3, r7, #6
 456 0044 0132     		add	r2, r2, #1
 457 0046 1A70     		strb	r2, [r3]
 411:.\Generated_Source\PSoC4/UART_1.c **** 
 412:.\Generated_Source\PSoC4/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 458              		.loc 1 412 0
 459 0048 BB1D     		add	r3, r7, #6
 460 004a 1B78     		ldrb	r3, [r3]
 461 004c 0C2B     		cmp	r3, #12
 462 004e 02D9     		bls	.L23
 413:.\Generated_Source\PSoC4/UART_1.c ****             {
 414:.\Generated_Source\PSoC4/UART_1.c ****                 locRxBufferRead = 0u;
 463              		.loc 1 414 0
 464 0050 BB1D     		add	r3, r7, #6
 465 0052 0022     		mov	r2, #0
 466 0054 1A70     		strb	r2, [r3]
 467              	.L23:
 415:.\Generated_Source\PSoC4/UART_1.c ****             }
 416:.\Generated_Source\PSoC4/UART_1.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 468              		.loc 1 417 0
 469 0056 0D4B     		ldr	r3, .L27
 470 0058 BA1D     		add	r2, r7, #6
 471 005a 1278     		ldrb	r2, [r2]
 472 005c 1A70     		strb	r2, [r3]
 418:.\Generated_Source\PSoC4/UART_1.c **** 
 419:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 473              		.loc 1 419 0
 474 005e 0D4B     		ldr	r3, .L27+8
 475 0060 1B78     		ldrb	r3, [r3]
 476 0062 DBB2     		uxtb	r3, r3
 477 0064 002B     		cmp	r3, #0
 478 0066 03D0     		beq	.L24
 420:.\Generated_Source\PSoC4/UART_1.c ****             {
 421:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 479              		.loc 1 421 0
 480 0068 0A4B     		ldr	r3, .L27+8
 481 006a 0022     		mov	r2, #0
 482 006c 1A70     		strb	r2, [r3]
 419:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 483              		.loc 1 419 0
 484 006e 04E0     		b	.L25
 485              	.L24:
 419:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 486              		.loc 1 419 0 is_stmt 0 discriminator 1
 487 0070 03E0     		b	.L25
 488              	.L22:
 422:.\Generated_Source\PSoC4/UART_1.c ****                 #if ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u))
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 17


 423:.\Generated_Source\PSoC4/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC4/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 425:.\Generated_Source\PSoC4/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC4/UART_1.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC4/UART_1.c ****                             *  configuration set, otherwise
 428:.\Generated_Source\PSoC4/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:.\Generated_Source\PSoC4/UART_1.c ****                             */
 430:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC4/UART_1.c ****                         }
 432:.\Generated_Source\PSoC4/UART_1.c ****                     #else
 433:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 435:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC4/UART_1.c ****             }
 437:.\Generated_Source\PSoC4/UART_1.c ****         }
 438:.\Generated_Source\PSoC4/UART_1.c ****         else
 439:.\Generated_Source\PSoC4/UART_1.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 489              		.loc 1 440 0 is_stmt 1
 490 0072 0A4A     		ldr	r2, .L27+16
 491 0074 FB1D     		add	r3, r7, #7
 492 0076 1278     		ldrb	r2, [r2]
 493 0078 1A70     		strb	r2, [r3]
 494              	.L25:
 441:.\Generated_Source\PSoC4/UART_1.c ****         }
 442:.\Generated_Source\PSoC4/UART_1.c **** 
 443:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 495              		.loc 1 443 0
 496 007a 0020     		mov	r0, #0
 497 007c FFF7FEFF 		bl	CyIntEnable
 444:.\Generated_Source\PSoC4/UART_1.c **** 
 445:.\Generated_Source\PSoC4/UART_1.c ****     #else
 446:.\Generated_Source\PSoC4/UART_1.c **** 
 447:.\Generated_Source\PSoC4/UART_1.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC4/UART_1.c ****         rxData = UART_1_RXDATA_REG;
 449:.\Generated_Source\PSoC4/UART_1.c **** 
 450:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 451:.\Generated_Source\PSoC4/UART_1.c **** 
 452:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 498              		.loc 1 452 0
 499 0080 FB1D     		add	r3, r7, #7
 500 0082 1B78     		ldrb	r3, [r3]
 453:.\Generated_Source\PSoC4/UART_1.c ****     }
 501              		.loc 1 453 0
 502 0084 181C     		mov	r0, r3
 503 0086 BD46     		mov	sp, r7
 504 0088 02B0     		add	sp, sp, #8
 505              		@ sp needed
 506 008a 80BD     		pop	{r7, pc}
 507              	.L28:
 508              		.align	2
 509              	.L27:
 510 008c 00000000 		.word	UART_1_rxBufferRead
 511 0090 00000000 		.word	UART_1_rxBufferWrite
 512 0094 00000000 		.word	UART_1_rxBufferLoopDetect
 513 0098 00000000 		.word	UART_1_rxBuffer
 514 009c 42000F40 		.word	1074724930
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 18


 515              		.cfi_endproc
 516              	.LFE7:
 517              		.size	UART_1_ReadRxData, .-UART_1_ReadRxData
 518              		.section	.text.UART_1_ReadRxStatus,"ax",%progbits
 519              		.align	2
 520              		.global	UART_1_ReadRxStatus
 521              		.code	16
 522              		.thumb_func
 523              		.type	UART_1_ReadRxStatus, %function
 524              	UART_1_ReadRxStatus:
 525              	.LFB8:
 454:.\Generated_Source\PSoC4/UART_1.c **** 
 455:.\Generated_Source\PSoC4/UART_1.c **** 
 456:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 457:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 458:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC4/UART_1.c ****     *
 460:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 461:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC4/UART_1.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC4/UART_1.c ****     *
 464:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 465:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 466:.\Generated_Source\PSoC4/UART_1.c ****     *
 467:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 468:.\Generated_Source\PSoC4/UART_1.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC4/UART_1.c ****     *
 470:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effect:
 471:.\Generated_Source\PSoC4/UART_1.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC4/UART_1.c ****     *  register read.
 475:.\Generated_Source\PSoC4/UART_1.c ****     *
 476:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 477:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC4/UART_1.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC4/UART_1.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC4/UART_1.c ****     *   bits.
 483:.\Generated_Source\PSoC4/UART_1.c ****     *
 484:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC4/UART_1.c ****     {
 526              		.loc 1 486 0
 527              		.cfi_startproc
 528 0000 80B5     		push	{r7, lr}
 529              		.cfi_def_cfa_offset 8
 530              		.cfi_offset 7, -8
 531              		.cfi_offset 14, -4
 532 0002 82B0     		sub	sp, sp, #8
 533              		.cfi_def_cfa_offset 16
 534 0004 00AF     		add	r7, sp, #0
 535              		.cfi_def_cfa_register 7
 487:.\Generated_Source\PSoC4/UART_1.c ****         uint8 status;
 488:.\Generated_Source\PSoC4/UART_1.c **** 
 489:.\Generated_Source\PSoC4/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 19


 536              		.loc 1 489 0
 537 0006 0E4B     		ldr	r3, .L32
 538 0008 1B78     		ldrb	r3, [r3]
 539 000a D9B2     		uxtb	r1, r3
 540 000c FB1D     		add	r3, r7, #7
 541 000e 7F22     		mov	r2, #127
 542 0010 0A40     		and	r2, r1
 543 0012 1A70     		strb	r2, [r3]
 490:.\Generated_Source\PSoC4/UART_1.c **** 
 491:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_rxBufferOverflow != 0u)
 544              		.loc 1 492 0
 545 0014 0B4B     		ldr	r3, .L32+4
 546 0016 1B78     		ldrb	r3, [r3]
 547 0018 DBB2     		uxtb	r3, r3
 548 001a 002B     		cmp	r3, #0
 549 001c 09D0     		beq	.L30
 493:.\Generated_Source\PSoC4/UART_1.c ****         {
 494:.\Generated_Source\PSoC4/UART_1.c ****             status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 550              		.loc 1 494 0
 551 001e FB1D     		add	r3, r7, #7
 552 0020 FA1D     		add	r2, r7, #7
 553 0022 1278     		ldrb	r2, [r2]
 554 0024 8021     		mov	r1, #128
 555 0026 4942     		neg	r1, r1
 556 0028 0A43     		orr	r2, r1
 557 002a 1A70     		strb	r2, [r3]
 495:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 558              		.loc 1 495 0
 559 002c 054B     		ldr	r3, .L32+4
 560 002e 0022     		mov	r2, #0
 561 0030 1A70     		strb	r2, [r3]
 562              	.L30:
 496:.\Generated_Source\PSoC4/UART_1.c ****         }
 497:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC4/UART_1.c **** 
 499:.\Generated_Source\PSoC4/UART_1.c ****         return(status);
 563              		.loc 1 499 0
 564 0032 FB1D     		add	r3, r7, #7
 565 0034 1B78     		ldrb	r3, [r3]
 500:.\Generated_Source\PSoC4/UART_1.c ****     }
 566              		.loc 1 500 0
 567 0036 181C     		mov	r0, r3
 568 0038 BD46     		mov	sp, r7
 569 003a 02B0     		add	sp, sp, #8
 570              		@ sp needed
 571 003c 80BD     		pop	{r7, pc}
 572              	.L33:
 573 003e C046     		.align	2
 574              	.L32:
 575 0040 60000F40 		.word	1074724960
 576 0044 00000000 		.word	UART_1_rxBufferOverflow
 577              		.cfi_endproc
 578              	.LFE8:
 579              		.size	UART_1_ReadRxStatus, .-UART_1_ReadRxStatus
 580              		.section	.text.UART_1_GetChar,"ax",%progbits
 581              		.align	2
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 20


 582              		.global	UART_1_GetChar
 583              		.code	16
 584              		.thumb_func
 585              		.type	UART_1_GetChar, %function
 586              	UART_1_GetChar:
 587              	.LFB9:
 501:.\Generated_Source\PSoC4/UART_1.c **** 
 502:.\Generated_Source\PSoC4/UART_1.c **** 
 503:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetChar
 505:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC4/UART_1.c ****     *
 507:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 508:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the last received byte of data. UART_1_GetChar() is
 509:.\Generated_Source\PSoC4/UART_1.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC4/UART_1.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC4/UART_1.c ****     *
 512:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 513:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 514:.\Generated_Source\PSoC4/UART_1.c ****     *
 515:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 516:.\Generated_Source\PSoC4/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC4/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC4/UART_1.c ****     *
 519:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 520:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 522:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 527:.\Generated_Source\PSoC4/UART_1.c ****     *
 528:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 529:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 530:.\Generated_Source\PSoC4/UART_1.c ****     *
 531:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetChar(void) 
 533:.\Generated_Source\PSoC4/UART_1.c ****     {
 588              		.loc 1 533 0
 589              		.cfi_startproc
 590 0000 80B5     		push	{r7, lr}
 591              		.cfi_def_cfa_offset 8
 592              		.cfi_offset 7, -8
 593              		.cfi_offset 14, -4
 594 0002 82B0     		sub	sp, sp, #8
 595              		.cfi_def_cfa_offset 16
 596 0004 00AF     		add	r7, sp, #0
 597              		.cfi_def_cfa_register 7
 534:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData = 0u;
 598              		.loc 1 534 0
 599 0006 FB1D     		add	r3, r7, #7
 600 0008 0022     		mov	r2, #0
 601 000a 1A70     		strb	r2, [r3]
 535:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC4/UART_1.c **** 
 537:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 21


 538:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC4/UART_1.c **** 
 541:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 602              		.loc 1 542 0
 603 000c 0020     		mov	r0, #0
 604 000e FFF7FEFF 		bl	CyIntDisable
 543:.\Generated_Source\PSoC4/UART_1.c **** 
 544:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 605              		.loc 1 544 0
 606 0012 BB1D     		add	r3, r7, #6
 607 0014 274A     		ldr	r2, .L41
 608 0016 1278     		ldrb	r2, [r2]
 609 0018 1A70     		strb	r2, [r3]
 545:.\Generated_Source\PSoC4/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 610              		.loc 1 545 0
 611 001a 7B1D     		add	r3, r7, #5
 612 001c 264A     		ldr	r2, .L41+4
 613 001e 1278     		ldrb	r2, [r2]
 614 0020 1A70     		strb	r2, [r3]
 546:.\Generated_Source\PSoC4/UART_1.c **** 
 547:.\Generated_Source\PSoC4/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 615              		.loc 1 547 0
 616 0022 264B     		ldr	r3, .L41+8
 617 0024 1B78     		ldrb	r3, [r3]
 618 0026 DBB2     		uxtb	r3, r3
 619 0028 002B     		cmp	r3, #0
 620 002a 05D1     		bne	.L35
 621              		.loc 1 547 0 is_stmt 0 discriminator 1
 622 002c BA1D     		add	r2, r7, #6
 623 002e 7B1D     		add	r3, r7, #5
 624 0030 1278     		ldrb	r2, [r2]
 625 0032 1B78     		ldrb	r3, [r3]
 626 0034 9A42     		cmp	r2, r3
 627 0036 1FD0     		beq	.L36
 628              	.L35:
 548:.\Generated_Source\PSoC4/UART_1.c ****         {
 549:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 629              		.loc 1 549 0 is_stmt 1
 630 0038 BB1D     		add	r3, r7, #6
 631 003a 1A78     		ldrb	r2, [r3]
 632 003c FB1D     		add	r3, r7, #7
 633 003e 2049     		ldr	r1, .L41+12
 634 0040 8A5C     		ldrb	r2, [r1, r2]
 635 0042 1A70     		strb	r2, [r3]
 550:.\Generated_Source\PSoC4/UART_1.c ****             locRxBufferRead++;
 636              		.loc 1 550 0
 637 0044 BB1D     		add	r3, r7, #6
 638 0046 1A78     		ldrb	r2, [r3]
 639 0048 BB1D     		add	r3, r7, #6
 640 004a 0132     		add	r2, r2, #1
 641 004c 1A70     		strb	r2, [r3]
 551:.\Generated_Source\PSoC4/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 642              		.loc 1 551 0
 643 004e BB1D     		add	r3, r7, #6
 644 0050 1B78     		ldrb	r3, [r3]
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 22


 645 0052 0C2B     		cmp	r3, #12
 646 0054 02D9     		bls	.L37
 552:.\Generated_Source\PSoC4/UART_1.c ****             {
 553:.\Generated_Source\PSoC4/UART_1.c ****                 locRxBufferRead = 0u;
 647              		.loc 1 553 0
 648 0056 BB1D     		add	r3, r7, #6
 649 0058 0022     		mov	r2, #0
 650 005a 1A70     		strb	r2, [r3]
 651              	.L37:
 554:.\Generated_Source\PSoC4/UART_1.c ****             }
 555:.\Generated_Source\PSoC4/UART_1.c ****             /* Update the real pointer */
 556:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 652              		.loc 1 556 0
 653 005c 154B     		ldr	r3, .L41
 654 005e BA1D     		add	r2, r7, #6
 655 0060 1278     		ldrb	r2, [r2]
 656 0062 1A70     		strb	r2, [r3]
 557:.\Generated_Source\PSoC4/UART_1.c **** 
 558:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 657              		.loc 1 558 0
 658 0064 154B     		ldr	r3, .L41+8
 659 0066 1B78     		ldrb	r3, [r3]
 660 0068 DBB2     		uxtb	r3, r3
 661 006a 002B     		cmp	r3, #0
 662 006c 03D0     		beq	.L38
 559:.\Generated_Source\PSoC4/UART_1.c ****             {
 560:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 663              		.loc 1 560 0
 664 006e 134B     		ldr	r3, .L41+8
 665 0070 0022     		mov	r2, #0
 666 0072 1A70     		strb	r2, [r3]
 558:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 667              		.loc 1 558 0
 668 0074 15E0     		b	.L39
 669              	.L38:
 558:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 670              		.loc 1 558 0 is_stmt 0 discriminator 1
 671 0076 14E0     		b	.L39
 672              	.L36:
 561:.\Generated_Source\PSoC4/UART_1.c ****                 #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC4/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC4/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 564:.\Generated_Source\PSoC4/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 565:.\Generated_Source\PSoC4/UART_1.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC4/UART_1.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC4/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC4/UART_1.c ****                             */
 569:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC4/UART_1.c ****                         }
 571:.\Generated_Source\PSoC4/UART_1.c ****                     #else
 572:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 574:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC4/UART_1.c ****             }
 576:.\Generated_Source\PSoC4/UART_1.c **** 
 577:.\Generated_Source\PSoC4/UART_1.c ****         }
 578:.\Generated_Source\PSoC4/UART_1.c ****         else
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 23


 579:.\Generated_Source\PSoC4/UART_1.c ****         {   rxStatus = UART_1_RXSTATUS_REG;
 673              		.loc 1 579 0 is_stmt 1
 674 0078 124A     		ldr	r2, .L41+16
 675 007a 3B1D     		add	r3, r7, #4
 676 007c 1278     		ldrb	r2, [r2]
 677 007e 1A70     		strb	r2, [r3]
 580:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 678              		.loc 1 580 0
 679 0080 3B1D     		add	r3, r7, #4
 680 0082 1A78     		ldrb	r2, [r3]
 681 0084 2023     		mov	r3, #32
 682 0086 1340     		and	r3, r2
 683 0088 0BD0     		beq	.L39
 581:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 684              		.loc 1 582 0
 685 008a 0F4A     		ldr	r2, .L41+20
 686 008c FB1D     		add	r3, r7, #7
 687 008e 1278     		ldrb	r2, [r2]
 688 0090 1A70     		strb	r2, [r3]
 583:.\Generated_Source\PSoC4/UART_1.c ****                 /*Check status on error*/
 584:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 689              		.loc 1 585 0
 690 0092 3B1D     		add	r3, r7, #4
 691 0094 1A78     		ldrb	r2, [r3]
 692 0096 1E23     		mov	r3, #30
 693 0098 1340     		and	r3, r2
 584:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 694              		.loc 1 584 0
 695 009a 02D0     		beq	.L39
 586:.\Generated_Source\PSoC4/UART_1.c ****                 {
 587:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = 0u;
 696              		.loc 1 587 0
 697 009c FB1D     		add	r3, r7, #7
 698 009e 0022     		mov	r2, #0
 699 00a0 1A70     		strb	r2, [r3]
 700              	.L39:
 588:.\Generated_Source\PSoC4/UART_1.c ****                 }
 589:.\Generated_Source\PSoC4/UART_1.c ****             }
 590:.\Generated_Source\PSoC4/UART_1.c ****         }
 591:.\Generated_Source\PSoC4/UART_1.c **** 
 592:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 701              		.loc 1 592 0
 702 00a2 0020     		mov	r0, #0
 703 00a4 FFF7FEFF 		bl	CyIntEnable
 593:.\Generated_Source\PSoC4/UART_1.c **** 
 594:.\Generated_Source\PSoC4/UART_1.c ****     #else
 595:.\Generated_Source\PSoC4/UART_1.c **** 
 596:.\Generated_Source\PSoC4/UART_1.c ****         rxStatus =UART_1_RXSTATUS_REG;
 597:.\Generated_Source\PSoC4/UART_1.c ****         if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 598:.\Generated_Source\PSoC4/UART_1.c ****         {
 599:.\Generated_Source\PSoC4/UART_1.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 601:.\Generated_Source\PSoC4/UART_1.c **** 
 602:.\Generated_Source\PSoC4/UART_1.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 24


 604:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 605:.\Generated_Source\PSoC4/UART_1.c ****             {
 606:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = 0u;
 607:.\Generated_Source\PSoC4/UART_1.c ****             }
 608:.\Generated_Source\PSoC4/UART_1.c ****         }
 609:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC4/UART_1.c **** 
 611:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 704              		.loc 1 611 0
 705 00a8 FB1D     		add	r3, r7, #7
 706 00aa 1B78     		ldrb	r3, [r3]
 612:.\Generated_Source\PSoC4/UART_1.c ****     }
 707              		.loc 1 612 0
 708 00ac 181C     		mov	r0, r3
 709 00ae BD46     		mov	sp, r7
 710 00b0 02B0     		add	sp, sp, #8
 711              		@ sp needed
 712 00b2 80BD     		pop	{r7, pc}
 713              	.L42:
 714              		.align	2
 715              	.L41:
 716 00b4 00000000 		.word	UART_1_rxBufferRead
 717 00b8 00000000 		.word	UART_1_rxBufferWrite
 718 00bc 00000000 		.word	UART_1_rxBufferLoopDetect
 719 00c0 00000000 		.word	UART_1_rxBuffer
 720 00c4 60000F40 		.word	1074724960
 721 00c8 42000F40 		.word	1074724930
 722              		.cfi_endproc
 723              	.LFE9:
 724              		.size	UART_1_GetChar, .-UART_1_GetChar
 725              		.section	.text.UART_1_GetByte,"ax",%progbits
 726              		.align	2
 727              		.global	UART_1_GetByte
 728              		.code	16
 729              		.thumb_func
 730              		.type	UART_1_GetByte, %function
 731              	UART_1_GetByte:
 732              	.LFB10:
 613:.\Generated_Source\PSoC4/UART_1.c **** 
 614:.\Generated_Source\PSoC4/UART_1.c **** 
 615:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetByte
 617:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC4/UART_1.c ****     *
 619:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 620:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC4/UART_1.c ****     *  condition.
 622:.\Generated_Source\PSoC4/UART_1.c ****     *
 623:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 624:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 625:.\Generated_Source\PSoC4/UART_1.c ****     *
 626:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 627:.\Generated_Source\PSoC4/UART_1.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC4/UART_1.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC4/UART_1.c ****     *
 630:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 631:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 25


 632:.\Generated_Source\PSoC4/UART_1.c ****     *
 633:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC4/UART_1.c ****     uint16 UART_1_GetByte(void) 
 635:.\Generated_Source\PSoC4/UART_1.c ****     {
 733              		.loc 1 635 0
 734              		.cfi_startproc
 735 0000 90B5     		push	{r4, r7, lr}
 736              		.cfi_def_cfa_offset 12
 737              		.cfi_offset 4, -12
 738              		.cfi_offset 7, -8
 739              		.cfi_offset 14, -4
 740 0002 83B0     		sub	sp, sp, #12
 741              		.cfi_def_cfa_offset 24
 742 0004 00AF     		add	r7, sp, #0
 743              		.cfi_def_cfa_register 7
 636:.\Generated_Source\PSoC4/UART_1.c ****         
 637:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC4/UART_1.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 744              		.loc 1 640 0
 745 0006 0020     		mov	r0, #0
 746 0008 FFF7FEFF 		bl	CyIntDisable
 641:.\Generated_Source\PSoC4/UART_1.c ****         locErrorStatus = (uint16)UART_1_errorStatus;
 747              		.loc 1 641 0
 748 000c 0B4B     		ldr	r3, .L45
 749 000e 1A78     		ldrb	r2, [r3]
 750 0010 BB1D     		add	r3, r7, #6
 751 0012 1A80     		strh	r2, [r3]
 642:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_errorStatus = 0u;
 752              		.loc 1 642 0
 753 0014 094B     		ldr	r3, .L45
 754 0016 0022     		mov	r2, #0
 755 0018 1A70     		strb	r2, [r3]
 643:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 756              		.loc 1 643 0
 757 001a 0020     		mov	r0, #0
 758 001c FFF7FEFF 		bl	CyIntEnable
 644:.\Generated_Source\PSoC4/UART_1.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_1_ReadRxData() );
 759              		.loc 1 644 0
 760 0020 BB1D     		add	r3, r7, #6
 761 0022 1B88     		ldrh	r3, [r3]
 762 0024 1B02     		lsl	r3, r3, #8
 763 0026 9CB2     		uxth	r4, r3
 764 0028 FFF7FEFF 		bl	UART_1_ReadRxData
 765 002c 031C     		mov	r3, r0
 766 002e 2343     		orr	r3, r4
 767 0030 9BB2     		uxth	r3, r3
 645:.\Generated_Source\PSoC4/UART_1.c ****     #else
 646:.\Generated_Source\PSoC4/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 647:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC4/UART_1.c ****         
 649:.\Generated_Source\PSoC4/UART_1.c ****     }
 768              		.loc 1 649 0
 769 0032 181C     		mov	r0, r3
 770 0034 BD46     		mov	sp, r7
 771 0036 03B0     		add	sp, sp, #12
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 26


 772              		@ sp needed
 773 0038 90BD     		pop	{r4, r7, pc}
 774              	.L46:
 775 003a C046     		.align	2
 776              	.L45:
 777 003c 00000000 		.word	UART_1_errorStatus
 778              		.cfi_endproc
 779              	.LFE10:
 780              		.size	UART_1_GetByte, .-UART_1_GetByte
 781              		.section	.text.UART_1_GetRxBufferSize,"ax",%progbits
 782              		.align	2
 783              		.global	UART_1_GetRxBufferSize
 784              		.code	16
 785              		.thumb_func
 786              		.type	UART_1_GetRxBufferSize, %function
 787              	UART_1_GetRxBufferSize:
 788              	.LFB11:
 650:.\Generated_Source\PSoC4/UART_1.c **** 
 651:.\Generated_Source\PSoC4/UART_1.c **** 
 652:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 654:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC4/UART_1.c ****     *
 656:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 657:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC4/UART_1.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC4/UART_1.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC4/UART_1.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC4/UART_1.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC4/UART_1.c ****     *    account.
 663:.\Generated_Source\PSoC4/UART_1.c ****     *
 664:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 665:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 666:.\Generated_Source\PSoC4/UART_1.c ****     *
 667:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 668:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC4/UART_1.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:.\Generated_Source\PSoC4/UART_1.c ****     *
 671:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 672:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC4/UART_1.c ****     *
 676:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 677:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 678:.\Generated_Source\PSoC4/UART_1.c ****     *
 679:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 680:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC4/UART_1.c ****     *
 682:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC4/UART_1.c ****                                                             
 685:.\Generated_Source\PSoC4/UART_1.c ****     {
 789              		.loc 1 685 0
 790              		.cfi_startproc
 791 0000 80B5     		push	{r7, lr}
 792              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 27


 793              		.cfi_offset 7, -8
 794              		.cfi_offset 14, -4
 795 0002 82B0     		sub	sp, sp, #8
 796              		.cfi_def_cfa_offset 16
 797 0004 00AF     		add	r7, sp, #0
 798              		.cfi_def_cfa_register 7
 686:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
 687:.\Generated_Source\PSoC4/UART_1.c **** 
 688:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC4/UART_1.c **** 
 690:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 799              		.loc 1 691 0
 800 0006 0020     		mov	r0, #0
 801 0008 FFF7FEFF 		bl	CyIntDisable
 692:.\Generated_Source\PSoC4/UART_1.c **** 
 693:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 802              		.loc 1 693 0
 803 000c 1D4B     		ldr	r3, .L54
 804 000e 1B78     		ldrb	r3, [r3]
 805 0010 DAB2     		uxtb	r2, r3
 806 0012 1D4B     		ldr	r3, .L54+4
 807 0014 1B78     		ldrb	r3, [r3]
 808 0016 DBB2     		uxtb	r3, r3
 809 0018 9A42     		cmp	r2, r3
 810 001a 0CD1     		bne	.L48
 694:.\Generated_Source\PSoC4/UART_1.c ****         {
 695:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 811              		.loc 1 695 0
 812 001c 1B4B     		ldr	r3, .L54+8
 813 001e 1B78     		ldrb	r3, [r3]
 814 0020 DBB2     		uxtb	r3, r3
 815 0022 002B     		cmp	r3, #0
 816 0024 03D0     		beq	.L49
 696:.\Generated_Source\PSoC4/UART_1.c ****             {
 697:.\Generated_Source\PSoC4/UART_1.c ****                 size = UART_1_RX_BUFFER_SIZE;
 817              		.loc 1 697 0
 818 0026 FB1D     		add	r3, r7, #7
 819 0028 0D22     		mov	r2, #13
 820 002a 1A70     		strb	r2, [r3]
 821 002c 20E0     		b	.L51
 822              	.L49:
 698:.\Generated_Source\PSoC4/UART_1.c ****             }
 699:.\Generated_Source\PSoC4/UART_1.c ****             else
 700:.\Generated_Source\PSoC4/UART_1.c ****             {
 701:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
 823              		.loc 1 701 0
 824 002e FB1D     		add	r3, r7, #7
 825 0030 0022     		mov	r2, #0
 826 0032 1A70     		strb	r2, [r3]
 827 0034 1CE0     		b	.L51
 828              	.L48:
 702:.\Generated_Source\PSoC4/UART_1.c ****             }
 703:.\Generated_Source\PSoC4/UART_1.c ****         }
 704:.\Generated_Source\PSoC4/UART_1.c ****         else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 829              		.loc 1 704 0
 830 0036 134B     		ldr	r3, .L54
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 28


 831 0038 1B78     		ldrb	r3, [r3]
 832 003a DAB2     		uxtb	r2, r3
 833 003c 124B     		ldr	r3, .L54+4
 834 003e 1B78     		ldrb	r3, [r3]
 835 0040 DBB2     		uxtb	r3, r3
 836 0042 9A42     		cmp	r2, r3
 837 0044 09D2     		bcs	.L52
 705:.\Generated_Source\PSoC4/UART_1.c ****         {
 706:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 838              		.loc 1 706 0
 839 0046 104B     		ldr	r3, .L54+4
 840 0048 1B78     		ldrb	r3, [r3]
 841 004a D9B2     		uxtb	r1, r3
 842 004c 0D4B     		ldr	r3, .L54
 843 004e 1B78     		ldrb	r3, [r3]
 844 0050 DAB2     		uxtb	r2, r3
 845 0052 FB1D     		add	r3, r7, #7
 846 0054 8A1A     		sub	r2, r1, r2
 847 0056 1A70     		strb	r2, [r3]
 848 0058 0AE0     		b	.L51
 849              	.L52:
 707:.\Generated_Source\PSoC4/UART_1.c ****         }
 708:.\Generated_Source\PSoC4/UART_1.c ****         else
 709:.\Generated_Source\PSoC4/UART_1.c ****         {
 710:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_RX_BUFFER_SIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 850              		.loc 1 710 0
 851 005a 0B4B     		ldr	r3, .L54+4
 852 005c 1B78     		ldrb	r3, [r3]
 853 005e DAB2     		uxtb	r2, r3
 854 0060 084B     		ldr	r3, .L54
 855 0062 1B78     		ldrb	r3, [r3]
 856 0064 DBB2     		uxtb	r3, r3
 857 0066 D31A     		sub	r3, r2, r3
 858 0068 DAB2     		uxtb	r2, r3
 859 006a FB1D     		add	r3, r7, #7
 860 006c 0D32     		add	r2, r2, #13
 861 006e 1A70     		strb	r2, [r3]
 862              	.L51:
 711:.\Generated_Source\PSoC4/UART_1.c ****         }
 712:.\Generated_Source\PSoC4/UART_1.c **** 
 713:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 863              		.loc 1 713 0
 864 0070 0020     		mov	r0, #0
 865 0072 FFF7FEFF 		bl	CyIntEnable
 714:.\Generated_Source\PSoC4/UART_1.c **** 
 715:.\Generated_Source\PSoC4/UART_1.c ****     #else
 716:.\Generated_Source\PSoC4/UART_1.c **** 
 717:.\Generated_Source\PSoC4/UART_1.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC4/UART_1.c ****         size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 719:.\Generated_Source\PSoC4/UART_1.c **** 
 720:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC4/UART_1.c **** 
 722:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 866              		.loc 1 722 0
 867 0076 FB1D     		add	r3, r7, #7
 868 0078 1B78     		ldrb	r3, [r3]
 723:.\Generated_Source\PSoC4/UART_1.c ****     }
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 29


 869              		.loc 1 723 0
 870 007a 181C     		mov	r0, r3
 871 007c BD46     		mov	sp, r7
 872 007e 02B0     		add	sp, sp, #8
 873              		@ sp needed
 874 0080 80BD     		pop	{r7, pc}
 875              	.L55:
 876 0082 C046     		.align	2
 877              	.L54:
 878 0084 00000000 		.word	UART_1_rxBufferRead
 879 0088 00000000 		.word	UART_1_rxBufferWrite
 880 008c 00000000 		.word	UART_1_rxBufferLoopDetect
 881              		.cfi_endproc
 882              	.LFE11:
 883              		.size	UART_1_GetRxBufferSize, .-UART_1_GetRxBufferSize
 884              		.section	.text.UART_1_ClearRxBuffer,"ax",%progbits
 885              		.align	2
 886              		.global	UART_1_ClearRxBuffer
 887              		.code	16
 888              		.thumb_func
 889              		.type	UART_1_ClearRxBuffer, %function
 890              	UART_1_ClearRxBuffer:
 891              	.LFB12:
 724:.\Generated_Source\PSoC4/UART_1.c **** 
 725:.\Generated_Source\PSoC4/UART_1.c **** 
 726:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 727:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 728:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC4/UART_1.c ****     *
 730:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 731:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC4/UART_1.c ****     *
 733:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 734:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 735:.\Generated_Source\PSoC4/UART_1.c ****     *
 736:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 737:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 738:.\Generated_Source\PSoC4/UART_1.c ****     *
 739:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 740:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC4/UART_1.c ****     *
 745:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 746:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 747:.\Generated_Source\PSoC4/UART_1.c ****     *
 748:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 749:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC4/UART_1.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC4/UART_1.c ****     *
 753:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
 754:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:.\Generated_Source\PSoC4/UART_1.c ****     *
 756:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 30


 758:.\Generated_Source\PSoC4/UART_1.c ****     {
 892              		.loc 1 758 0
 893              		.cfi_startproc
 894 0000 90B5     		push	{r4, r7, lr}
 895              		.cfi_def_cfa_offset 12
 896              		.cfi_offset 4, -12
 897              		.cfi_offset 7, -8
 898              		.cfi_offset 14, -4
 899 0002 83B0     		sub	sp, sp, #12
 900              		.cfi_def_cfa_offset 24
 901 0004 00AF     		add	r7, sp, #0
 902              		.cfi_def_cfa_register 7
 759:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
 760:.\Generated_Source\PSoC4/UART_1.c **** 
 761:.\Generated_Source\PSoC4/UART_1.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 903              		.loc 1 762 0
 904 0006 FC1D     		add	r4, r7, #7
 905 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 906 000c 031C     		mov	r3, r0
 907 000e 2370     		strb	r3, [r4]
 763:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |= (uint8)  UART_1_RX_FIFO_CLR;
 908              		.loc 1 763 0
 909 0010 144B     		ldr	r3, .L57
 910 0012 144A     		ldr	r2, .L57
 911 0014 1278     		ldrb	r2, [r2]
 912 0016 D2B2     		uxtb	r2, r2
 913 0018 0121     		mov	r1, #1
 914 001a 0A43     		orr	r2, r1
 915 001c D2B2     		uxtb	r2, r2
 916 001e 1A70     		strb	r2, [r3]
 764:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8) ~UART_1_RX_FIFO_CLR;
 917              		.loc 1 764 0
 918 0020 104B     		ldr	r3, .L57
 919 0022 104A     		ldr	r2, .L57
 920 0024 1278     		ldrb	r2, [r2]
 921 0026 D2B2     		uxtb	r2, r2
 922 0028 0121     		mov	r1, #1
 923 002a 8A43     		bic	r2, r1
 924 002c D2B2     		uxtb	r2, r2
 925 002e 1A70     		strb	r2, [r3]
 765:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 926              		.loc 1 765 0
 927 0030 FB1D     		add	r3, r7, #7
 928 0032 1B78     		ldrb	r3, [r3]
 929 0034 181C     		mov	r0, r3
 930 0036 FFF7FEFF 		bl	CyExitCriticalSection
 766:.\Generated_Source\PSoC4/UART_1.c **** 
 767:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC4/UART_1.c **** 
 769:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 931              		.loc 1 770 0
 932 003a 0020     		mov	r0, #0
 933 003c FFF7FEFF 		bl	CyIntDisable
 771:.\Generated_Source\PSoC4/UART_1.c **** 
 772:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferRead = 0u;
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 31


 934              		.loc 1 772 0
 935 0040 094B     		ldr	r3, .L57+4
 936 0042 0022     		mov	r2, #0
 937 0044 1A70     		strb	r2, [r3]
 773:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferWrite = 0u;
 938              		.loc 1 773 0
 939 0046 094B     		ldr	r3, .L57+8
 940 0048 0022     		mov	r2, #0
 941 004a 1A70     		strb	r2, [r3]
 774:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferLoopDetect = 0u;
 942              		.loc 1 774 0
 943 004c 084B     		ldr	r3, .L57+12
 944 004e 0022     		mov	r2, #0
 945 0050 1A70     		strb	r2, [r3]
 775:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferOverflow = 0u;
 946              		.loc 1 775 0
 947 0052 084B     		ldr	r3, .L57+16
 948 0054 0022     		mov	r2, #0
 949 0056 1A70     		strb	r2, [r3]
 776:.\Generated_Source\PSoC4/UART_1.c **** 
 777:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 950              		.loc 1 777 0
 951 0058 0020     		mov	r0, #0
 952 005a FFF7FEFF 		bl	CyIntEnable
 778:.\Generated_Source\PSoC4/UART_1.c **** 
 779:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC4/UART_1.c **** 
 781:.\Generated_Source\PSoC4/UART_1.c ****     }
 953              		.loc 1 781 0
 954 005e BD46     		mov	sp, r7
 955 0060 03B0     		add	sp, sp, #12
 956              		@ sp needed
 957 0062 90BD     		pop	{r4, r7, pc}
 958              	.L58:
 959              		.align	2
 960              	.L57:
 961 0064 92000F40 		.word	1074725010
 962 0068 00000000 		.word	UART_1_rxBufferRead
 963 006c 00000000 		.word	UART_1_rxBufferWrite
 964 0070 00000000 		.word	UART_1_rxBufferLoopDetect
 965 0074 00000000 		.word	UART_1_rxBufferOverflow
 966              		.cfi_endproc
 967              	.LFE12:
 968              		.size	UART_1_ClearRxBuffer, .-UART_1_ClearRxBuffer
 969              		.section	.text.UART_1_SetRxAddressMode,"ax",%progbits
 970              		.align	2
 971              		.global	UART_1_SetRxAddressMode
 972              		.code	16
 973              		.thumb_func
 974              		.type	UART_1_SetRxAddressMode, %function
 975              	UART_1_SetRxAddressMode:
 976              	.LFB13:
 782:.\Generated_Source\PSoC4/UART_1.c **** 
 783:.\Generated_Source\PSoC4/UART_1.c **** 
 784:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 786:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 32


 787:.\Generated_Source\PSoC4/UART_1.c ****     *
 788:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 789:.\Generated_Source\PSoC4/UART_1.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC4/UART_1.c ****     *  UART.
 791:.\Generated_Source\PSoC4/UART_1.c ****     *
 792:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 793:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 796:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 798:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 800:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 802:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC4/UART_1.c ****     *
 804:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 805:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 806:.\Generated_Source\PSoC4/UART_1.c ****     *
 807:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 808:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC4/UART_1.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC4/UART_1.c ****     *
 812:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC4/UART_1.c ****                                                         
 815:.\Generated_Source\PSoC4/UART_1.c ****     {
 977              		.loc 1 815 0
 978              		.cfi_startproc
 979 0000 80B5     		push	{r7, lr}
 980              		.cfi_def_cfa_offset 8
 981              		.cfi_offset 7, -8
 982              		.cfi_offset 14, -4
 983 0002 82B0     		sub	sp, sp, #8
 984              		.cfi_def_cfa_offset 16
 985 0004 00AF     		add	r7, sp, #0
 986              		.cfi_def_cfa_register 7
 987 0006 021C     		mov	r2, r0
 988 0008 FB1D     		add	r3, r7, #7
 989 000a 1A70     		strb	r2, [r3]
 816:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC4/UART_1.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC4/UART_1.c ****                 {
 820:.\Generated_Source\PSoC4/UART_1.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC4/UART_1.c ****                 }
 822:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC4/UART_1.c **** 
 828:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC4/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 33


 831:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC4/UART_1.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC4/UART_1.c ****             {
 837:.\Generated_Source\PSoC4/UART_1.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC4/UART_1.c ****             }
 839:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC4/UART_1.c ****     }
 990              		.loc 1 840 0
 991 000c BD46     		mov	sp, r7
 992 000e 02B0     		add	sp, sp, #8
 993              		@ sp needed
 994 0010 80BD     		pop	{r7, pc}
 995              		.cfi_endproc
 996              	.LFE13:
 997              		.size	UART_1_SetRxAddressMode, .-UART_1_SetRxAddressMode
 998 0012 C046     		.section	.text.UART_1_SetRxAddress1,"ax",%progbits
 999              		.align	2
 1000              		.global	UART_1_SetRxAddress1
 1001              		.code	16
 1002              		.thumb_func
 1003              		.type	UART_1_SetRxAddress1, %function
 1004              	UART_1_SetRxAddress1:
 1005              	.LFB14:
 841:.\Generated_Source\PSoC4/UART_1.c **** 
 842:.\Generated_Source\PSoC4/UART_1.c **** 
 843:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 845:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC4/UART_1.c ****     *
 847:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 848:.\Generated_Source\PSoC4/UART_1.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC4/UART_1.c ****     *
 850:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 851:.\Generated_Source\PSoC4/UART_1.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC4/UART_1.c ****     *
 853:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 854:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 855:.\Generated_Source\PSoC4/UART_1.c ****     *
 856:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC4/UART_1.c ****     {
 1006              		.loc 1 858 0
 1007              		.cfi_startproc
 1008 0000 80B5     		push	{r7, lr}
 1009              		.cfi_def_cfa_offset 8
 1010              		.cfi_offset 7, -8
 1011              		.cfi_offset 14, -4
 1012 0002 82B0     		sub	sp, sp, #8
 1013              		.cfi_def_cfa_offset 16
 1014 0004 00AF     		add	r7, sp, #0
 1015              		.cfi_def_cfa_register 7
 1016 0006 021C     		mov	r2, r0
 1017 0008 FB1D     		add	r3, r7, #7
 1018 000a 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 34


 859:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 1019              		.loc 1 859 0
 1020 000c 034B     		ldr	r3, .L61
 1021 000e FA1D     		add	r2, r7, #7
 1022 0010 1278     		ldrb	r2, [r2]
 1023 0012 1A70     		strb	r2, [r3]
 860:.\Generated_Source\PSoC4/UART_1.c ****     }
 1024              		.loc 1 860 0
 1025 0014 BD46     		mov	sp, r7
 1026 0016 02B0     		add	sp, sp, #8
 1027              		@ sp needed
 1028 0018 80BD     		pop	{r7, pc}
 1029              	.L62:
 1030 001a C046     		.align	2
 1031              	.L61:
 1032 001c 22000F40 		.word	1074724898
 1033              		.cfi_endproc
 1034              	.LFE14:
 1035              		.size	UART_1_SetRxAddress1, .-UART_1_SetRxAddress1
 1036              		.section	.text.UART_1_SetRxAddress2,"ax",%progbits
 1037              		.align	2
 1038              		.global	UART_1_SetRxAddress2
 1039              		.code	16
 1040              		.thumb_func
 1041              		.type	UART_1_SetRxAddress2, %function
 1042              	UART_1_SetRxAddress2:
 1043              	.LFB15:
 861:.\Generated_Source\PSoC4/UART_1.c **** 
 862:.\Generated_Source\PSoC4/UART_1.c **** 
 863:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 864:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 865:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC4/UART_1.c ****     *
 867:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 868:.\Generated_Source\PSoC4/UART_1.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:.\Generated_Source\PSoC4/UART_1.c ****     *
 870:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 871:.\Generated_Source\PSoC4/UART_1.c ****     *  address: Address #2 for hardware address detection.
 872:.\Generated_Source\PSoC4/UART_1.c ****     *
 873:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 874:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 875:.\Generated_Source\PSoC4/UART_1.c ****     *
 876:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC4/UART_1.c ****     {
 1044              		.loc 1 878 0
 1045              		.cfi_startproc
 1046 0000 80B5     		push	{r7, lr}
 1047              		.cfi_def_cfa_offset 8
 1048              		.cfi_offset 7, -8
 1049              		.cfi_offset 14, -4
 1050 0002 82B0     		sub	sp, sp, #8
 1051              		.cfi_def_cfa_offset 16
 1052 0004 00AF     		add	r7, sp, #0
 1053              		.cfi_def_cfa_register 7
 1054 0006 021C     		mov	r2, r0
 1055 0008 FB1D     		add	r3, r7, #7
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 35


 1056 000a 1A70     		strb	r2, [r3]
 879:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 1057              		.loc 1 879 0
 1058 000c 034B     		ldr	r3, .L64
 1059 000e FA1D     		add	r2, r7, #7
 1060 0010 1278     		ldrb	r2, [r2]
 1061 0012 1A70     		strb	r2, [r3]
 880:.\Generated_Source\PSoC4/UART_1.c ****     }
 1062              		.loc 1 880 0
 1063 0014 BD46     		mov	sp, r7
 1064 0016 02B0     		add	sp, sp, #8
 1065              		@ sp needed
 1066 0018 80BD     		pop	{r7, pc}
 1067              	.L65:
 1068 001a C046     		.align	2
 1069              	.L64:
 1070 001c 32000F40 		.word	1074724914
 1071              		.cfi_endproc
 1072              	.LFE15:
 1073              		.size	UART_1_SetRxAddress2, .-UART_1_SetRxAddress2
 1074              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 1075              		.align	2
 1076              		.global	UART_1_SetTxInterruptMode
 1077              		.code	16
 1078              		.thumb_func
 1079              		.type	UART_1_SetTxInterruptMode, %function
 1080              	UART_1_SetTxInterruptMode:
 1081              	.LFB16:
 881:.\Generated_Source\PSoC4/UART_1.c **** 
 882:.\Generated_Source\PSoC4/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 883:.\Generated_Source\PSoC4/UART_1.c **** 
 884:.\Generated_Source\PSoC4/UART_1.c **** 
 885:.\Generated_Source\PSoC4/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 886:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 888:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC4/UART_1.c ****     *
 890:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 891:.\Generated_Source\PSoC4/UART_1.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:.\Generated_Source\PSoC4/UART_1.c ****     *  interrupt.
 893:.\Generated_Source\PSoC4/UART_1.c ****     *
 894:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 895:.\Generated_Source\PSoC4/UART_1.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC4/UART_1.c ****     *
 901:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 902:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 903:.\Generated_Source\PSoC4/UART_1.c ****     *
 904:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 905:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC4/UART_1.c ****     *
 907:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC4/UART_1.c ****     {
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 36


 1082              		.loc 1 909 0
 1083              		.cfi_startproc
 1084 0000 80B5     		push	{r7, lr}
 1085              		.cfi_def_cfa_offset 8
 1086              		.cfi_offset 7, -8
 1087              		.cfi_offset 14, -4
 1088 0002 82B0     		sub	sp, sp, #8
 1089              		.cfi_def_cfa_offset 16
 1090 0004 00AF     		add	r7, sp, #0
 1091              		.cfi_def_cfa_register 7
 1092 0006 021C     		mov	r2, r0
 1093 0008 FB1D     		add	r3, r7, #7
 1094 000a 1A70     		strb	r2, [r3]
 910:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 1095              		.loc 1 910 0
 1096 000c 034B     		ldr	r3, .L67
 1097 000e FA1D     		add	r2, r7, #7
 1098 0010 1278     		ldrb	r2, [r2]
 1099 0012 1A70     		strb	r2, [r3]
 911:.\Generated_Source\PSoC4/UART_1.c ****     }
 1100              		.loc 1 911 0
 1101 0014 BD46     		mov	sp, r7
 1102 0016 02B0     		add	sp, sp, #8
 1103              		@ sp needed
 1104 0018 80BD     		pop	{r7, pc}
 1105              	.L68:
 1106 001a C046     		.align	2
 1107              	.L67:
 1108 001c 81000F40 		.word	1074724993
 1109              		.cfi_endproc
 1110              	.LFE16:
 1111              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 1112              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 1113              		.align	2
 1114              		.global	UART_1_WriteTxData
 1115              		.code	16
 1116              		.thumb_func
 1117              		.type	UART_1_WriteTxData, %function
 1118              	UART_1_WriteTxData:
 1119              	.LFB17:
 912:.\Generated_Source\PSoC4/UART_1.c **** 
 913:.\Generated_Source\PSoC4/UART_1.c **** 
 914:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_WriteTxData
 916:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC4/UART_1.c ****     *
 918:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 919:.\Generated_Source\PSoC4/UART_1.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC4/UART_1.c ****     *  available without checking the TX status register. You must check status
 921:.\Generated_Source\PSoC4/UART_1.c ****     *  separately.
 922:.\Generated_Source\PSoC4/UART_1.c ****     *
 923:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 924:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC4/UART_1.c ****     *
 926:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 927:.\Generated_Source\PSoC4/UART_1.c ****     * None.
 928:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 37


 929:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 930:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC4/UART_1.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC4/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC4/UART_1.c ****     *    initialized.
 937:.\Generated_Source\PSoC4/UART_1.c ****     *
 938:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 939:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 940:.\Generated_Source\PSoC4/UART_1.c ****     *
 941:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC4/UART_1.c ****     {
 1120              		.loc 1 943 0
 1121              		.cfi_startproc
 1122 0000 80B5     		push	{r7, lr}
 1123              		.cfi_def_cfa_offset 8
 1124              		.cfi_offset 7, -8
 1125              		.cfi_offset 14, -4
 1126 0002 82B0     		sub	sp, sp, #8
 1127              		.cfi_def_cfa_offset 16
 1128 0004 00AF     		add	r7, sp, #0
 1129              		.cfi_def_cfa_register 7
 1130 0006 021C     		mov	r2, r0
 1131 0008 FB1D     		add	r3, r7, #7
 1132 000a 1A70     		strb	r2, [r3]
 944:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1133              		.loc 1 945 0
 1134 000c 054B     		ldr	r3, .L71
 1135 000e 1B78     		ldrb	r3, [r3]
 1136 0010 002B     		cmp	r3, #0
 1137 0012 03D0     		beq	.L69
 946:.\Generated_Source\PSoC4/UART_1.c ****         {
 947:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC4/UART_1.c **** 
 949:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 950:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 951:.\Generated_Source\PSoC4/UART_1.c **** 
 952:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
 953:.\Generated_Source\PSoC4/UART_1.c ****                 ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC4/UART_1.c ****             {
 955:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC4/UART_1.c ****             }
 958:.\Generated_Source\PSoC4/UART_1.c ****             else
 959:.\Generated_Source\PSoC4/UART_1.c ****             {
 960:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_txBufferWrite >= UART_1_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC4/UART_1.c ****                 {
 962:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC4/UART_1.c ****                 }
 964:.\Generated_Source\PSoC4/UART_1.c **** 
 965:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC4/UART_1.c **** 
 967:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add to the software buffer. */
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 38


 968:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_txBufferWrite++;
 969:.\Generated_Source\PSoC4/UART_1.c ****             }
 970:.\Generated_Source\PSoC4/UART_1.c **** 
 971:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
 972:.\Generated_Source\PSoC4/UART_1.c **** 
 973:.\Generated_Source\PSoC4/UART_1.c ****         #else
 974:.\Generated_Source\PSoC4/UART_1.c **** 
 975:.\Generated_Source\PSoC4/UART_1.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
 1138              		.loc 1 976 0
 1139 0014 044B     		ldr	r3, .L71+4
 1140 0016 FA1D     		add	r2, r7, #7
 1141 0018 1278     		ldrb	r2, [r2]
 1142 001a 1A70     		strb	r2, [r3]
 1143              	.L69:
 977:.\Generated_Source\PSoC4/UART_1.c **** 
 978:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*(UART_1_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC4/UART_1.c ****         }
 980:.\Generated_Source\PSoC4/UART_1.c ****     }
 1144              		.loc 1 980 0
 1145 001c BD46     		mov	sp, r7
 1146 001e 02B0     		add	sp, sp, #8
 1147              		@ sp needed
 1148 0020 80BD     		pop	{r7, pc}
 1149              	.L72:
 1150 0022 C046     		.align	2
 1151              	.L71:
 1152 0024 00000000 		.word	UART_1_initVar
 1153 0028 41000F40 		.word	1074724929
 1154              		.cfi_endproc
 1155              	.LFE17:
 1156              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 1157              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 1158              		.align	2
 1159              		.global	UART_1_ReadTxStatus
 1160              		.code	16
 1161              		.thumb_func
 1162              		.type	UART_1_ReadTxStatus, %function
 1163              	UART_1_ReadTxStatus:
 1164              	.LFB18:
 981:.\Generated_Source\PSoC4/UART_1.c **** 
 982:.\Generated_Source\PSoC4/UART_1.c **** 
 983:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
 985:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC4/UART_1.c ****     *
 987:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 988:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC4/UART_1.c ****     *
 990:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 991:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 992:.\Generated_Source\PSoC4/UART_1.c ****     *
 993:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 994:.\Generated_Source\PSoC4/UART_1.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC4/UART_1.c ****     *
 996:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 997:.\Generated_Source\PSoC4/UART_1.c ****     *  This function reads the TX status register, which is cleared on read.
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 39


 998:.\Generated_Source\PSoC4/UART_1.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC4/UART_1.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC4/UART_1.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC4/UART_1.c ****     *
1002:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC4/UART_1.c ****     {
 1165              		.loc 1 1004 0
 1166              		.cfi_startproc
 1167 0000 80B5     		push	{r7, lr}
 1168              		.cfi_def_cfa_offset 8
 1169              		.cfi_offset 7, -8
 1170              		.cfi_offset 14, -4
 1171 0002 00AF     		add	r7, sp, #0
 1172              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 1173              		.loc 1 1005 0
 1174 0004 024B     		ldr	r3, .L75
 1175 0006 1B78     		ldrb	r3, [r3]
 1176 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC4/UART_1.c ****     }
 1177              		.loc 1 1006 0
 1178 000a 181C     		mov	r0, r3
 1179 000c BD46     		mov	sp, r7
 1180              		@ sp needed
 1181 000e 80BD     		pop	{r7, pc}
 1182              	.L76:
 1183              		.align	2
 1184              	.L75:
 1185 0010 61000F40 		.word	1074724961
 1186              		.cfi_endproc
 1187              	.LFE18:
 1188              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 1189              		.section	.text.UART_1_PutChar,"ax",%progbits
 1190              		.align	2
 1191              		.global	UART_1_PutChar
 1192              		.code	16
 1193              		.thumb_func
 1194              		.type	UART_1_PutChar, %function
 1195              	UART_1_PutChar:
 1196              	.LFB19:
1007:.\Generated_Source\PSoC4/UART_1.c **** 
1008:.\Generated_Source\PSoC4/UART_1.c **** 
1009:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutChar
1011:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC4/UART_1.c ****     *
1013:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1014:.\Generated_Source\PSoC4/UART_1.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC4/UART_1.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC4/UART_1.c ****     *  hold the data.
1017:.\Generated_Source\PSoC4/UART_1.c ****     *
1018:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1019:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC4/UART_1.c ****     *
1021:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1022:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 40


1023:.\Generated_Source\PSoC4/UART_1.c ****     *
1024:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1025:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC4/UART_1.c ****     *     saved to buffer.
1029:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1033:.\Generated_Source\PSoC4/UART_1.c ****     *
1034:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1035:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1036:.\Generated_Source\PSoC4/UART_1.c ****     *
1037:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1038:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:.\Generated_Source\PSoC4/UART_1.c ****     *
1040:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC4/UART_1.c ****     {
 1197              		.loc 1 1042 0
 1198              		.cfi_startproc
 1199 0000 80B5     		push	{r7, lr}
 1200              		.cfi_def_cfa_offset 8
 1201              		.cfi_offset 7, -8
 1202              		.cfi_offset 14, -4
 1203 0002 82B0     		sub	sp, sp, #8
 1204              		.cfi_def_cfa_offset 16
 1205 0004 00AF     		add	r7, sp, #0
 1206              		.cfi_def_cfa_register 7
 1207 0006 021C     		mov	r2, r0
 1208 0008 FB1D     		add	r3, r7, #7
 1209 000a 1A70     		strb	r2, [r3]
1043:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC4/UART_1.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC4/UART_1.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC4/UART_1.c ****         *  pointer and getting an interrupt in between instructions.
1047:.\Generated_Source\PSoC4/UART_1.c ****         */
1048:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locTxBufferWrite;
1049:.\Generated_Source\PSoC4/UART_1.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC4/UART_1.c **** 
1051:.\Generated_Source\PSoC4/UART_1.c ****         do
1052:.\Generated_Source\PSoC4/UART_1.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC4/UART_1.c **** 
1054:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
1057:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1058:.\Generated_Source\PSoC4/UART_1.c **** 
1059:.\Generated_Source\PSoC4/UART_1.c ****             locTxBufferWrite = UART_1_txBufferWrite;
1060:.\Generated_Source\PSoC4/UART_1.c ****             locTxBufferRead  = UART_1_txBufferRead;
1061:.\Generated_Source\PSoC4/UART_1.c **** 
1062:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
1065:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1066:.\Generated_Source\PSoC4/UART_1.c ****         }
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 41


1067:.\Generated_Source\PSoC4/UART_1.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC4/UART_1.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC4/UART_1.c ****                                 (uint8)(UART_1_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC4/UART_1.c **** 
1071:.\Generated_Source\PSoC4/UART_1.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:.\Generated_Source\PSoC4/UART_1.c ****             ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC4/UART_1.c ****         {
1074:.\Generated_Source\PSoC4/UART_1.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC4/UART_1.c ****         }
1077:.\Generated_Source\PSoC4/UART_1.c ****         else
1078:.\Generated_Source\PSoC4/UART_1.c ****         {
1079:.\Generated_Source\PSoC4/UART_1.c ****             if(locTxBufferWrite >= UART_1_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC4/UART_1.c ****             {
1081:.\Generated_Source\PSoC4/UART_1.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC4/UART_1.c ****             }
1083:.\Generated_Source\PSoC4/UART_1.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC4/UART_1.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC4/UART_1.c **** 
1087:.\Generated_Source\PSoC4/UART_1.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
1090:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1091:.\Generated_Source\PSoC4/UART_1.c **** 
1092:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC4/UART_1.c **** 
1094:.\Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
1096:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > 255) */
1097:.\Generated_Source\PSoC4/UART_1.c **** 
1098:.\Generated_Source\PSoC4/UART_1.c ****             if(0u != (UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC4/UART_1.c ****             {
1100:.\Generated_Source\PSoC4/UART_1.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_SetPendingTxInt();
1102:.\Generated_Source\PSoC4/UART_1.c ****             }
1103:.\Generated_Source\PSoC4/UART_1.c ****         }
1104:.\Generated_Source\PSoC4/UART_1.c **** 
1105:.\Generated_Source\PSoC4/UART_1.c ****     #else
1106:.\Generated_Source\PSoC4/UART_1.c **** 
1107:.\Generated_Source\PSoC4/UART_1.c ****         while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 1210              		.loc 1 1107 0
 1211 000c C046     		mov	r8, r8
 1212              	.L78:
 1213              		.loc 1 1107 0 is_stmt 0 discriminator 1
 1214 000e 074B     		ldr	r3, .L79
 1215 0010 1B78     		ldrb	r3, [r3]
 1216 0012 DBB2     		uxtb	r3, r3
 1217 0014 1A1C     		mov	r2, r3
 1218 0016 0423     		mov	r3, #4
 1219 0018 1340     		and	r3, r2
 1220 001a F8D1     		bne	.L78
1108:.\Generated_Source\PSoC4/UART_1.c ****         {
1109:.\Generated_Source\PSoC4/UART_1.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC4/UART_1.c ****         }
1111:.\Generated_Source\PSoC4/UART_1.c **** 
1112:.\Generated_Source\PSoC4/UART_1.c ****         /* Add directly to the FIFO */
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 42


1113:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_REG = txDataByte;
 1221              		.loc 1 1113 0 is_stmt 1
 1222 001c 044B     		ldr	r3, .L79+4
 1223 001e FA1D     		add	r2, r7, #7
 1224 0020 1278     		ldrb	r2, [r2]
 1225 0022 1A70     		strb	r2, [r3]
1114:.\Generated_Source\PSoC4/UART_1.c **** 
1115:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End (UART_1_TX_INTERRUPT_ENABLED) */
1116:.\Generated_Source\PSoC4/UART_1.c ****     }
 1226              		.loc 1 1116 0
 1227 0024 BD46     		mov	sp, r7
 1228 0026 02B0     		add	sp, sp, #8
 1229              		@ sp needed
 1230 0028 80BD     		pop	{r7, pc}
 1231              	.L80:
 1232 002a C046     		.align	2
 1233              	.L79:
 1234 002c 61000F40 		.word	1074724961
 1235 0030 41000F40 		.word	1074724929
 1236              		.cfi_endproc
 1237              	.LFE19:
 1238              		.size	UART_1_PutChar, .-UART_1_PutChar
 1239              		.section	.text.UART_1_PutString,"ax",%progbits
 1240              		.align	2
 1241              		.global	UART_1_PutString
 1242              		.code	16
 1243              		.thumb_func
 1244              		.type	UART_1_PutString, %function
 1245              	UART_1_PutString:
 1246              	.LFB20:
1117:.\Generated_Source\PSoC4/UART_1.c **** 
1118:.\Generated_Source\PSoC4/UART_1.c **** 
1119:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutString
1121:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC4/UART_1.c ****     *
1123:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1124:.\Generated_Source\PSoC4/UART_1.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:.\Generated_Source\PSoC4/UART_1.c ****     *
1126:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1127:.\Generated_Source\PSoC4/UART_1.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC4/UART_1.c ****     *
1129:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1130:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1131:.\Generated_Source\PSoC4/UART_1.c ****     *
1132:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1133:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1135:.\Generated_Source\PSoC4/UART_1.c ****     *
1136:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1137:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1138:.\Generated_Source\PSoC4/UART_1.c ****     *
1139:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1140:.\Generated_Source\PSoC4/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC4/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC4/UART_1.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 43


1144:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC4/UART_1.c ****     {
 1247              		.loc 1 1146 0
 1248              		.cfi_startproc
 1249 0000 80B5     		push	{r7, lr}
 1250              		.cfi_def_cfa_offset 8
 1251              		.cfi_offset 7, -8
 1252              		.cfi_offset 14, -4
 1253 0002 84B0     		sub	sp, sp, #16
 1254              		.cfi_def_cfa_offset 24
 1255 0004 00AF     		add	r7, sp, #0
 1256              		.cfi_def_cfa_register 7
 1257 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC4/UART_1.c ****         uint16 bufIndex = 0u;
 1258              		.loc 1 1147 0
 1259 0008 3B1C     		mov	r3, r7
 1260 000a 0E33     		add	r3, r3, #14
 1261 000c 0022     		mov	r2, #0
 1262 000e 1A80     		strh	r2, [r3]
1148:.\Generated_Source\PSoC4/UART_1.c **** 
1149:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1263              		.loc 1 1150 0
 1264 0010 0F4B     		ldr	r3, .L85
 1265 0012 1B78     		ldrb	r3, [r3]
 1266 0014 002B     		cmp	r3, #0
 1267 0016 18D0     		beq	.L81
1151:.\Generated_Source\PSoC4/UART_1.c ****         {
1152:.\Generated_Source\PSoC4/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC4/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 1268              		.loc 1 1153 0
 1269 0018 0FE0     		b	.L83
 1270              	.L84:
1154:.\Generated_Source\PSoC4/UART_1.c ****             {
1155:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar((uint8)string[bufIndex]);
 1271              		.loc 1 1155 0
 1272 001a 3B1C     		mov	r3, r7
 1273 001c 0E33     		add	r3, r3, #14
 1274 001e 1B88     		ldrh	r3, [r3]
 1275 0020 7A68     		ldr	r2, [r7, #4]
 1276 0022 D318     		add	r3, r2, r3
 1277 0024 1B78     		ldrb	r3, [r3]
 1278 0026 181C     		mov	r0, r3
 1279 0028 FFF7FEFF 		bl	UART_1_PutChar
1156:.\Generated_Source\PSoC4/UART_1.c ****                 bufIndex++;
 1280              		.loc 1 1156 0
 1281 002c 3B1C     		mov	r3, r7
 1282 002e 0E33     		add	r3, r3, #14
 1283 0030 1A88     		ldrh	r2, [r3]
 1284 0032 3B1C     		mov	r3, r7
 1285 0034 0E33     		add	r3, r3, #14
 1286 0036 0132     		add	r2, r2, #1
 1287 0038 1A80     		strh	r2, [r3]
 1288              	.L83:
1153:.\Generated_Source\PSoC4/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 1289              		.loc 1 1153 0 discriminator 1
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 44


 1290 003a 3B1C     		mov	r3, r7
 1291 003c 0E33     		add	r3, r3, #14
 1292 003e 1B88     		ldrh	r3, [r3]
 1293 0040 7A68     		ldr	r2, [r7, #4]
 1294 0042 D318     		add	r3, r2, r3
 1295 0044 1B78     		ldrb	r3, [r3]
 1296 0046 002B     		cmp	r3, #0
 1297 0048 E7D1     		bne	.L84
 1298              	.L81:
1157:.\Generated_Source\PSoC4/UART_1.c ****             }
1158:.\Generated_Source\PSoC4/UART_1.c ****         }
1159:.\Generated_Source\PSoC4/UART_1.c ****     }
 1299              		.loc 1 1159 0
 1300 004a BD46     		mov	sp, r7
 1301 004c 04B0     		add	sp, sp, #16
 1302              		@ sp needed
 1303 004e 80BD     		pop	{r7, pc}
 1304              	.L86:
 1305              		.align	2
 1306              	.L85:
 1307 0050 00000000 		.word	UART_1_initVar
 1308              		.cfi_endproc
 1309              	.LFE20:
 1310              		.size	UART_1_PutString, .-UART_1_PutString
 1311              		.section	.text.UART_1_PutArray,"ax",%progbits
 1312              		.align	2
 1313              		.global	UART_1_PutArray
 1314              		.code	16
 1315              		.thumb_func
 1316              		.type	UART_1_PutArray, %function
 1317              	UART_1_PutArray:
 1318              	.LFB21:
1160:.\Generated_Source\PSoC4/UART_1.c **** 
1161:.\Generated_Source\PSoC4/UART_1.c **** 
1162:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutArray
1164:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC4/UART_1.c ****     *
1166:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1167:.\Generated_Source\PSoC4/UART_1.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:.\Generated_Source\PSoC4/UART_1.c ****     *  transmission.
1169:.\Generated_Source\PSoC4/UART_1.c ****     *
1170:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1171:.\Generated_Source\PSoC4/UART_1.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC4/UART_1.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC4/UART_1.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC4/UART_1.c ****     *
1175:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1176:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1177:.\Generated_Source\PSoC4/UART_1.c ****     *
1178:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1179:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1181:.\Generated_Source\PSoC4/UART_1.c ****     *
1182:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1183:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1184:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 45


1185:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1186:.\Generated_Source\PSoC4/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC4/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC4/UART_1.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC4/UART_1.c ****     *
1190:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC4/UART_1.c ****                                                                     
1193:.\Generated_Source\PSoC4/UART_1.c ****     {
 1319              		.loc 1 1193 0
 1320              		.cfi_startproc
 1321 0000 80B5     		push	{r7, lr}
 1322              		.cfi_def_cfa_offset 8
 1323              		.cfi_offset 7, -8
 1324              		.cfi_offset 14, -4
 1325 0002 84B0     		sub	sp, sp, #16
 1326              		.cfi_def_cfa_offset 24
 1327 0004 00AF     		add	r7, sp, #0
 1328              		.cfi_def_cfa_register 7
 1329 0006 7860     		str	r0, [r7, #4]
 1330 0008 0A1C     		mov	r2, r1
 1331 000a FB1C     		add	r3, r7, #3
 1332 000c 1A70     		strb	r2, [r3]
1194:.\Generated_Source\PSoC4/UART_1.c ****         uint8 bufIndex = 0u;
 1333              		.loc 1 1194 0
 1334 000e 3B1C     		mov	r3, r7
 1335 0010 0F33     		add	r3, r3, #15
 1336 0012 0022     		mov	r2, #0
 1337 0014 1A70     		strb	r2, [r3]
1195:.\Generated_Source\PSoC4/UART_1.c **** 
1196:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1338              		.loc 1 1197 0
 1339 0016 0F4B     		ldr	r3, .L91
 1340 0018 1B78     		ldrb	r3, [r3]
 1341 001a 002B     		cmp	r3, #0
 1342 001c 17D0     		beq	.L87
1198:.\Generated_Source\PSoC4/UART_1.c ****         {
1199:.\Generated_Source\PSoC4/UART_1.c ****             while(bufIndex < byteCount)
 1343              		.loc 1 1199 0
 1344 001e 0FE0     		b	.L89
 1345              	.L90:
1200:.\Generated_Source\PSoC4/UART_1.c ****             {
1201:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar(string[bufIndex]);
 1346              		.loc 1 1201 0
 1347 0020 3B1C     		mov	r3, r7
 1348 0022 0F33     		add	r3, r3, #15
 1349 0024 1B78     		ldrb	r3, [r3]
 1350 0026 7A68     		ldr	r2, [r7, #4]
 1351 0028 D318     		add	r3, r2, r3
 1352 002a 1B78     		ldrb	r3, [r3]
 1353 002c 181C     		mov	r0, r3
 1354 002e FFF7FEFF 		bl	UART_1_PutChar
1202:.\Generated_Source\PSoC4/UART_1.c ****                 bufIndex++;
 1355              		.loc 1 1202 0
 1356 0032 3B1C     		mov	r3, r7
 1357 0034 0F33     		add	r3, r3, #15
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 46


 1358 0036 1A78     		ldrb	r2, [r3]
 1359 0038 3B1C     		mov	r3, r7
 1360 003a 0F33     		add	r3, r3, #15
 1361 003c 0132     		add	r2, r2, #1
 1362 003e 1A70     		strb	r2, [r3]
 1363              	.L89:
1199:.\Generated_Source\PSoC4/UART_1.c ****             while(bufIndex < byteCount)
 1364              		.loc 1 1199 0 discriminator 1
 1365 0040 3A1C     		mov	r2, r7
 1366 0042 0F32     		add	r2, r2, #15
 1367 0044 FB1C     		add	r3, r7, #3
 1368 0046 1278     		ldrb	r2, [r2]
 1369 0048 1B78     		ldrb	r3, [r3]
 1370 004a 9A42     		cmp	r2, r3
 1371 004c E8D3     		bcc	.L90
 1372              	.L87:
1203:.\Generated_Source\PSoC4/UART_1.c ****             }
1204:.\Generated_Source\PSoC4/UART_1.c ****         }
1205:.\Generated_Source\PSoC4/UART_1.c ****     }
 1373              		.loc 1 1205 0
 1374 004e BD46     		mov	sp, r7
 1375 0050 04B0     		add	sp, sp, #16
 1376              		@ sp needed
 1377 0052 80BD     		pop	{r7, pc}
 1378              	.L92:
 1379              		.align	2
 1380              	.L91:
 1381 0054 00000000 		.word	UART_1_initVar
 1382              		.cfi_endproc
 1383              	.LFE21:
 1384              		.size	UART_1_PutArray, .-UART_1_PutArray
 1385              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 1386              		.align	2
 1387              		.global	UART_1_PutCRLF
 1388              		.code	16
 1389              		.thumb_func
 1390              		.type	UART_1_PutCRLF, %function
 1391              	UART_1_PutCRLF:
 1392              	.LFB22:
1206:.\Generated_Source\PSoC4/UART_1.c **** 
1207:.\Generated_Source\PSoC4/UART_1.c **** 
1208:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutCRLF
1210:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC4/UART_1.c ****     *
1212:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1213:.\Generated_Source\PSoC4/UART_1.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC4/UART_1.c ****     *  (0x0A) to the transmit buffer.
1215:.\Generated_Source\PSoC4/UART_1.c ****     *
1216:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1217:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC4/UART_1.c ****     *
1219:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1220:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1221:.\Generated_Source\PSoC4/UART_1.c ****     *
1222:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1223:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 47


1224:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1225:.\Generated_Source\PSoC4/UART_1.c ****     *
1226:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1227:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1228:.\Generated_Source\PSoC4/UART_1.c ****     *
1229:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC4/UART_1.c ****     {
 1393              		.loc 1 1231 0
 1394              		.cfi_startproc
 1395 0000 80B5     		push	{r7, lr}
 1396              		.cfi_def_cfa_offset 8
 1397              		.cfi_offset 7, -8
 1398              		.cfi_offset 14, -4
 1399 0002 82B0     		sub	sp, sp, #8
 1400              		.cfi_def_cfa_offset 16
 1401 0004 00AF     		add	r7, sp, #0
 1402              		.cfi_def_cfa_register 7
 1403 0006 021C     		mov	r2, r0
 1404 0008 FB1D     		add	r3, r7, #7
 1405 000a 1A70     		strb	r2, [r3]
1232:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1406              		.loc 1 1233 0
 1407 000c 084B     		ldr	r3, .L95
 1408 000e 1B78     		ldrb	r3, [r3]
 1409 0010 002B     		cmp	r3, #0
 1410 0012 0AD0     		beq	.L93
1234:.\Generated_Source\PSoC4/UART_1.c ****         {
1235:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(txDataByte);
 1411              		.loc 1 1235 0
 1412 0014 FB1D     		add	r3, r7, #7
 1413 0016 1B78     		ldrb	r3, [r3]
 1414 0018 181C     		mov	r0, r3
 1415 001a FFF7FEFF 		bl	UART_1_PutChar
1236:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Du);
 1416              		.loc 1 1236 0
 1417 001e 0D20     		mov	r0, #13
 1418 0020 FFF7FEFF 		bl	UART_1_PutChar
1237:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Au);
 1419              		.loc 1 1237 0
 1420 0024 0A20     		mov	r0, #10
 1421 0026 FFF7FEFF 		bl	UART_1_PutChar
 1422              	.L93:
1238:.\Generated_Source\PSoC4/UART_1.c ****         }
1239:.\Generated_Source\PSoC4/UART_1.c ****     }
 1423              		.loc 1 1239 0
 1424 002a BD46     		mov	sp, r7
 1425 002c 02B0     		add	sp, sp, #8
 1426              		@ sp needed
 1427 002e 80BD     		pop	{r7, pc}
 1428              	.L96:
 1429              		.align	2
 1430              	.L95:
 1431 0030 00000000 		.word	UART_1_initVar
 1432              		.cfi_endproc
 1433              	.LFE22:
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 48


 1434              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 1435              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 1436              		.align	2
 1437              		.global	UART_1_GetTxBufferSize
 1438              		.code	16
 1439              		.thumb_func
 1440              		.type	UART_1_GetTxBufferSize, %function
 1441              	UART_1_GetTxBufferSize:
 1442              	.LFB23:
1240:.\Generated_Source\PSoC4/UART_1.c **** 
1241:.\Generated_Source\PSoC4/UART_1.c **** 
1242:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1244:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC4/UART_1.c ****     *
1246:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1247:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC4/UART_1.c ****     *  transmitted.
1249:.\Generated_Source\PSoC4/UART_1.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC4/UART_1.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC4/UART_1.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC4/UART_1.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC4/UART_1.c ****     *    TX FIFO do not take to account.
1254:.\Generated_Source\PSoC4/UART_1.c ****     *
1255:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1256:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1257:.\Generated_Source\PSoC4/UART_1.c ****     *
1258:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1259:.\Generated_Source\PSoC4/UART_1.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC4/UART_1.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC4/UART_1.c ****     *
1262:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1263:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC4/UART_1.c ****     *
1266:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1267:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1268:.\Generated_Source\PSoC4/UART_1.c ****     *
1269:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1270:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC4/UART_1.c ****     *
1272:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC4/UART_1.c ****                                                             
1275:.\Generated_Source\PSoC4/UART_1.c ****     {
 1443              		.loc 1 1275 0
 1444              		.cfi_startproc
 1445 0000 80B5     		push	{r7, lr}
 1446              		.cfi_def_cfa_offset 8
 1447              		.cfi_offset 7, -8
 1448              		.cfi_offset 14, -4
 1449 0002 82B0     		sub	sp, sp, #8
 1450              		.cfi_def_cfa_offset 16
 1451 0004 00AF     		add	r7, sp, #0
 1452              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
1277:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 49


1278:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC4/UART_1.c **** 
1280:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableTxInt();
1282:.\Generated_Source\PSoC4/UART_1.c **** 
1283:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_txBufferRead == UART_1_txBufferWrite)
1284:.\Generated_Source\PSoC4/UART_1.c ****         {
1285:.\Generated_Source\PSoC4/UART_1.c ****             size = 0u;
1286:.\Generated_Source\PSoC4/UART_1.c ****         }
1287:.\Generated_Source\PSoC4/UART_1.c ****         else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1288:.\Generated_Source\PSoC4/UART_1.c ****         {
1289:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1290:.\Generated_Source\PSoC4/UART_1.c ****         }
1291:.\Generated_Source\PSoC4/UART_1.c ****         else
1292:.\Generated_Source\PSoC4/UART_1.c ****         {
1293:.\Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_TX_BUFFER_SIZE - UART_1_txBufferRead) +
1294:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite;
1295:.\Generated_Source\PSoC4/UART_1.c ****         }
1296:.\Generated_Source\PSoC4/UART_1.c **** 
1297:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableTxInt();
1298:.\Generated_Source\PSoC4/UART_1.c **** 
1299:.\Generated_Source\PSoC4/UART_1.c ****     #else
1300:.\Generated_Source\PSoC4/UART_1.c **** 
1301:.\Generated_Source\PSoC4/UART_1.c ****         size = UART_1_TXSTATUS_REG;
 1453              		.loc 1 1301 0
 1454 0006 0F4A     		ldr	r2, .L102
 1455 0008 FB1D     		add	r3, r7, #7
 1456 000a 1278     		ldrb	r2, [r2]
 1457 000c 1A70     		strb	r2, [r3]
1302:.\Generated_Source\PSoC4/UART_1.c **** 
1303:.\Generated_Source\PSoC4/UART_1.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC4/UART_1.c ****         if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 1458              		.loc 1 1304 0
 1459 000e FB1D     		add	r3, r7, #7
 1460 0010 1A78     		ldrb	r2, [r3]
 1461 0012 0423     		mov	r3, #4
 1462 0014 1340     		and	r3, r2
 1463 0016 03D0     		beq	.L98
1305:.\Generated_Source\PSoC4/UART_1.c ****         {
1306:.\Generated_Source\PSoC4/UART_1.c ****             size = UART_1_FIFO_LENGTH;
 1464              		.loc 1 1306 0
 1465 0018 FB1D     		add	r3, r7, #7
 1466 001a 0422     		mov	r2, #4
 1467 001c 1A70     		strb	r2, [r3]
 1468 001e 0BE0     		b	.L99
 1469              	.L98:
1307:.\Generated_Source\PSoC4/UART_1.c ****         }
1308:.\Generated_Source\PSoC4/UART_1.c ****         else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 1470              		.loc 1 1308 0
 1471 0020 FB1D     		add	r3, r7, #7
 1472 0022 1A78     		ldrb	r2, [r3]
 1473 0024 0223     		mov	r3, #2
 1474 0026 1340     		and	r3, r2
 1475 0028 03D0     		beq	.L100
1309:.\Generated_Source\PSoC4/UART_1.c ****         {
1310:.\Generated_Source\PSoC4/UART_1.c ****             size = 0u;
 1476              		.loc 1 1310 0
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 50


 1477 002a FB1D     		add	r3, r7, #7
 1478 002c 0022     		mov	r2, #0
 1479 002e 1A70     		strb	r2, [r3]
 1480 0030 02E0     		b	.L99
 1481              	.L100:
1311:.\Generated_Source\PSoC4/UART_1.c ****         }
1312:.\Generated_Source\PSoC4/UART_1.c ****         else
1313:.\Generated_Source\PSoC4/UART_1.c ****         {
1314:.\Generated_Source\PSoC4/UART_1.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC4/UART_1.c ****             size = 1u;
 1482              		.loc 1 1315 0
 1483 0032 FB1D     		add	r3, r7, #7
 1484 0034 0122     		mov	r2, #1
 1485 0036 1A70     		strb	r2, [r3]
 1486              	.L99:
1316:.\Generated_Source\PSoC4/UART_1.c ****         }
1317:.\Generated_Source\PSoC4/UART_1.c **** 
1318:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC4/UART_1.c **** 
1320:.\Generated_Source\PSoC4/UART_1.c ****     return(size);
 1487              		.loc 1 1320 0
 1488 0038 FB1D     		add	r3, r7, #7
 1489 003a 1B78     		ldrb	r3, [r3]
1321:.\Generated_Source\PSoC4/UART_1.c ****     }
 1490              		.loc 1 1321 0
 1491 003c 181C     		mov	r0, r3
 1492 003e BD46     		mov	sp, r7
 1493 0040 02B0     		add	sp, sp, #8
 1494              		@ sp needed
 1495 0042 80BD     		pop	{r7, pc}
 1496              	.L103:
 1497              		.align	2
 1498              	.L102:
 1499 0044 61000F40 		.word	1074724961
 1500              		.cfi_endproc
 1501              	.LFE23:
 1502              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 1503              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 1504              		.align	2
 1505              		.global	UART_1_ClearTxBuffer
 1506              		.code	16
 1507              		.thumb_func
 1508              		.type	UART_1_ClearTxBuffer, %function
 1509              	UART_1_ClearTxBuffer:
 1510              	.LFB24:
1322:.\Generated_Source\PSoC4/UART_1.c **** 
1323:.\Generated_Source\PSoC4/UART_1.c **** 
1324:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1326:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC4/UART_1.c ****     *
1328:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1329:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC4/UART_1.c ****     *
1331:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1332:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1333:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 51


1334:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1335:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1336:.\Generated_Source\PSoC4/UART_1.c ****     *
1337:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1338:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC4/UART_1.c ****     *
1341:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1342:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1343:.\Generated_Source\PSoC4/UART_1.c ****     *
1344:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1345:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC4/UART_1.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC4/UART_1.c ****     *
1349:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1350:.\Generated_Source\PSoC4/UART_1.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC4/UART_1.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC4/UART_1.c ****     *
1353:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC4/UART_1.c ****     {
 1511              		.loc 1 1355 0
 1512              		.cfi_startproc
 1513 0000 90B5     		push	{r4, r7, lr}
 1514              		.cfi_def_cfa_offset 12
 1515              		.cfi_offset 4, -12
 1516              		.cfi_offset 7, -8
 1517              		.cfi_offset 14, -4
 1518 0002 83B0     		sub	sp, sp, #12
 1519              		.cfi_def_cfa_offset 24
 1520 0004 00AF     		add	r7, sp, #0
 1521              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC4/UART_1.c **** 
1358:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 1522              		.loc 1 1358 0
 1523 0006 FC1D     		add	r4, r7, #7
 1524 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 1525 000c 031C     		mov	r3, r0
 1526 000e 2370     		strb	r3, [r4]
1359:.\Generated_Source\PSoC4/UART_1.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |= (uint8)  UART_1_TX_FIFO_CLR;
 1527              		.loc 1 1360 0
 1528 0010 0B4B     		ldr	r3, .L105
 1529 0012 0B4A     		ldr	r2, .L105
 1530 0014 1278     		ldrb	r2, [r2]
 1531 0016 D2B2     		uxtb	r2, r2
 1532 0018 0121     		mov	r1, #1
 1533 001a 0A43     		orr	r2, r1
 1534 001c D2B2     		uxtb	r2, r2
 1535 001e 1A70     		strb	r2, [r3]
1361:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8) ~UART_1_TX_FIFO_CLR;
 1536              		.loc 1 1361 0
 1537 0020 074B     		ldr	r3, .L105
 1538 0022 074A     		ldr	r2, .L105
 1539 0024 1278     		ldrb	r2, [r2]
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 52


 1540 0026 D2B2     		uxtb	r2, r2
 1541 0028 0121     		mov	r1, #1
 1542 002a 8A43     		bic	r2, r1
 1543 002c D2B2     		uxtb	r2, r2
 1544 002e 1A70     		strb	r2, [r3]
1362:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 1545              		.loc 1 1362 0
 1546 0030 FB1D     		add	r3, r7, #7
 1547 0032 1B78     		ldrb	r3, [r3]
 1548 0034 181C     		mov	r0, r3
 1549 0036 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC4/UART_1.c **** 
1364:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC4/UART_1.c **** 
1366:.\Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableTxInt();
1368:.\Generated_Source\PSoC4/UART_1.c **** 
1369:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_txBufferRead = 0u;
1370:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC4/UART_1.c **** 
1372:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableTxInt();
1374:.\Generated_Source\PSoC4/UART_1.c **** 
1375:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC4/UART_1.c ****     }
 1550              		.loc 1 1376 0
 1551 003a BD46     		mov	sp, r7
 1552 003c 03B0     		add	sp, sp, #12
 1553              		@ sp needed
 1554 003e 90BD     		pop	{r4, r7, pc}
 1555              	.L106:
 1556              		.align	2
 1557              	.L105:
 1558 0040 91000F40 		.word	1074725009
 1559              		.cfi_endproc
 1560              	.LFE24:
 1561              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 1562              		.section	.text.UART_1_SendBreak,"ax",%progbits
 1563              		.align	2
 1564              		.global	UART_1_SendBreak
 1565              		.code	16
 1566              		.thumb_func
 1567              		.type	UART_1_SendBreak, %function
 1568              	UART_1_SendBreak:
 1569              	.LFB25:
1377:.\Generated_Source\PSoC4/UART_1.c **** 
1378:.\Generated_Source\PSoC4/UART_1.c **** 
1379:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SendBreak
1381:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC4/UART_1.c ****     *
1383:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1384:.\Generated_Source\PSoC4/UART_1.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC4/UART_1.c ****     *
1386:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1387:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_SEND_BREAK - Initialize registers for break, send the Break
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 53


1389:.\Generated_Source\PSoC4/UART_1.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC4/UART_1.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC4/UART_1.c ****     *       then return.
1394:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC4/UART_1.c ****     *      UART_1_SEND_BREAK and UART_1_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC4/UART_1.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC4/UART_1.c ****     *
1398:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1399:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1400:.\Generated_Source\PSoC4/UART_1.c ****     *
1401:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1402:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1404:.\Generated_Source\PSoC4/UART_1.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:.\Generated_Source\PSoC4/UART_1.c ****     *
1406:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1407:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1408:.\Generated_Source\PSoC4/UART_1.c ****     *
1409:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1410:.\Generated_Source\PSoC4/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC4/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC4/UART_1.c ****     *  operation.
1413:.\Generated_Source\PSoC4/UART_1.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC4/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC4/UART_1.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC4/UART_1.c ****     *     complete.
1417:.\Generated_Source\PSoC4/UART_1.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC4/UART_1.c ****     *     operation
1419:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1420:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC4/UART_1.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC4/UART_1.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC4/UART_1.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC4/UART_1.c ****     *     When interrupt appear with UART_1_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC4/UART_1.c ****     *
1432:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1433:.\Generated_Source\PSoC4/UART_1.c ****     *  The UART_1_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC4/UART_1.c ****     *  break signal.
1435:.\Generated_Source\PSoC4/UART_1.c ****     *  Break signal length depends on the break signal bits configuration.
1436:.\Generated_Source\PSoC4/UART_1.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC4/UART_1.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC4/UART_1.c ****     *
1439:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC4/UART_1.c ****     {
 1570              		.loc 1 1441 0
 1571              		.cfi_startproc
 1572 0000 80B5     		push	{r7, lr}
 1573              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 54


 1574              		.cfi_offset 7, -8
 1575              		.cfi_offset 14, -4
 1576 0002 84B0     		sub	sp, sp, #16
 1577              		.cfi_def_cfa_offset 24
 1578 0004 00AF     		add	r7, sp, #0
 1579              		.cfi_def_cfa_register 7
 1580 0006 021C     		mov	r2, r0
 1581 0008 FB1D     		add	r3, r7, #7
 1582 000a 1A70     		strb	r2, [r3]
1442:.\Generated_Source\PSoC4/UART_1.c **** 
1443:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1583              		.loc 1 1444 0
 1584 000c 254B     		ldr	r3, .L115
 1585 000e 1B78     		ldrb	r3, [r3]
 1586 0010 002B     		cmp	r3, #0
 1587 0012 43D0     		beq	.L107
 1588              	.LBB2:
1445:.\Generated_Source\PSoC4/UART_1.c ****         {
1446:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC4/UART_1.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC4/UART_1.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC4/UART_1.c **** 
1450:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC4/UART_1.c **** 
1452:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
1453:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC4/UART_1.c ****             {
1455:.\Generated_Source\PSoC4/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1457:.\Generated_Source\PSoC4/UART_1.c ****                                                       UART_1_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC4/UART_1.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC4/UART_1.c **** 
1461:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC4/UART_1.c ****                 {
1463:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1464:.\Generated_Source\PSoC4/UART_1.c ****                 }
1465:.\Generated_Source\PSoC4/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1466:.\Generated_Source\PSoC4/UART_1.c ****             }
1467:.\Generated_Source\PSoC4/UART_1.c **** 
1468:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC4/UART_1.c ****             {
1471:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC4/UART_1.c ****                 {
1473:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1474:.\Generated_Source\PSoC4/UART_1.c ****                 }
1475:.\Generated_Source\PSoC4/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC4/UART_1.c ****             }
1477:.\Generated_Source\PSoC4/UART_1.c **** 
1478:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_REINIT) ||
1480:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC4/UART_1.c ****             {
1482:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1483:.\Generated_Source\PSoC4/UART_1.c ****                                               (uint8)~UART_1_CTRL_HD_SEND_BREAK);
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 55


1484:.\Generated_Source\PSoC4/UART_1.c ****             }
1485:.\Generated_Source\PSoC4/UART_1.c **** 
1486:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC4/UART_1.c **** 
1488:.\Generated_Source\PSoC4/UART_1.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC4/UART_1.c **** 
1490:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
 1589              		.loc 1 1490 0
 1590 0014 FB1D     		add	r3, r7, #7
 1591 0016 1B78     		ldrb	r3, [r3]
 1592 0018 002B     		cmp	r3, #0
 1593 001a 03D0     		beq	.L109
 1594              		.loc 1 1490 0 is_stmt 0 discriminator 1
 1595 001c FB1D     		add	r3, r7, #7
 1596 001e 1B78     		ldrb	r3, [r3]
 1597 0020 032B     		cmp	r3, #3
 1598 0022 15D1     		bne	.L110
 1599              	.L109:
1491:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC4/UART_1.c ****             {
1493:.\Generated_Source\PSoC4/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC4/UART_1.c ****                 #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC4/UART_1.c ****                                     (UART_1_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1497:.\Generated_Source\PSoC4/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC4/UART_1.c **** 
1500:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC4/UART_1.c ****                     txPeriod = UART_1_TXBITCLKTX_COMPLETE_REG;
 1600              		.loc 1 1501 0 is_stmt 1
 1601 0024 204B     		ldr	r3, .L115+4
 1602 0026 1B78     		ldrb	r3, [r3]
 1603 0028 DAB2     		uxtb	r2, r3
 1604 002a 204B     		ldr	r3, .L115+8
 1605 002c 1A70     		strb	r2, [r3]
1502:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 1606              		.loc 1 1502 0
 1607 002e 1E4B     		ldr	r3, .L115+4
 1608 0030 6722     		mov	r2, #103
 1609 0032 1A70     		strb	r2, [r3]
1503:.\Generated_Source\PSoC4/UART_1.c ****                 #else
1504:.\Generated_Source\PSoC4/UART_1.c ****                     txPeriod = UART_1_TXBITCTR_PERIOD_REG;
1505:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1506:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC4/UART_1.c **** 
1508:.\Generated_Source\PSoC4/UART_1.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
 1610              		.loc 1 1509 0
 1611 0034 1E4B     		ldr	r3, .L115+12
 1612 0036 0022     		mov	r2, #0
 1613 0038 1A70     		strb	r2, [r3]
 1614              	.L111:
1510:.\Generated_Source\PSoC4/UART_1.c **** 
1511:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC4/UART_1.c ****                 {
1513:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 1615              		.loc 1 1513 0 discriminator 1
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 56


 1616 003a 1E4A     		ldr	r2, .L115+16
 1617 003c 3B1C     		mov	r3, r7
 1618 003e 0F33     		add	r3, r3, #15
 1619 0040 1278     		ldrb	r2, [r2]
 1620 0042 1A70     		strb	r2, [r3]
1514:.\Generated_Source\PSoC4/UART_1.c ****                 }
1515:.\Generated_Source\PSoC4/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 1621              		.loc 1 1515 0 discriminator 1
 1622 0044 3B1C     		mov	r3, r7
 1623 0046 0F33     		add	r3, r3, #15
 1624 0048 1A78     		ldrb	r2, [r3]
 1625 004a 0223     		mov	r3, #2
 1626 004c 1340     		and	r3, r2
 1627 004e F4D1     		bne	.L111
 1628              	.L110:
1516:.\Generated_Source\PSoC4/UART_1.c ****             }
1517:.\Generated_Source\PSoC4/UART_1.c **** 
1518:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1629              		.loc 1 1518 0
 1630 0050 FB1D     		add	r3, r7, #7
 1631 0052 1B78     		ldrb	r3, [r3]
 1632 0054 012B     		cmp	r3, #1
 1633 0056 03D0     		beq	.L112
 1634              		.loc 1 1518 0 is_stmt 0 discriminator 1
 1635 0058 FB1D     		add	r3, r7, #7
 1636 005a 1B78     		ldrb	r3, [r3]
 1637 005c 032B     		cmp	r3, #3
 1638 005e 0DD1     		bne	.L113
 1639              	.L112:
1519:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC4/UART_1.c ****             {
1521:.\Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC4/UART_1.c ****                 {
1523:.\Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 1640              		.loc 1 1523 0 is_stmt 1 discriminator 1
 1641 0060 144A     		ldr	r2, .L115+16
 1642 0062 3B1C     		mov	r3, r7
 1643 0064 0F33     		add	r3, r3, #15
 1644 0066 1278     		ldrb	r2, [r2]
 1645 0068 1A70     		strb	r2, [r3]
1524:.\Generated_Source\PSoC4/UART_1.c ****                 }
1525:.\Generated_Source\PSoC4/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 1646              		.loc 1 1525 0 discriminator 1
 1647 006a 3B1C     		mov	r3, r7
 1648 006c 0F33     		add	r3, r3, #15
 1649 006e 1B78     		ldrb	r3, [r3]
 1650 0070 DB43     		mvn	r3, r3
 1651 0072 DBB2     		uxtb	r3, r3
 1652 0074 1A1C     		mov	r2, r3
 1653 0076 0123     		mov	r3, #1
 1654 0078 1340     		and	r3, r2
 1655 007a F1D1     		bne	.L112
 1656              	.L113:
1526:.\Generated_Source\PSoC4/UART_1.c ****             }
1527:.\Generated_Source\PSoC4/UART_1.c **** 
1528:.\Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1657              		.loc 1 1528 0
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 57


 1658 007c FB1D     		add	r3, r7, #7
 1659 007e 1B78     		ldrb	r3, [r3]
 1660 0080 012B     		cmp	r3, #1
 1661 0082 07D0     		beq	.L114
 1662              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1663 0084 FB1D     		add	r3, r7, #7
 1664 0086 1B78     		ldrb	r3, [r3]
 1665 0088 022B     		cmp	r3, #2
 1666 008a 03D0     		beq	.L114
1529:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_REINIT) ||
 1667              		.loc 1 1529 0 is_stmt 1
 1668 008c FB1D     		add	r3, r7, #7
 1669 008e 1B78     		ldrb	r3, [r3]
 1670 0090 032B     		cmp	r3, #3
 1671 0092 03D1     		bne	.L107
 1672              	.L114:
1530:.\Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC4/UART_1.c ****             {
1532:.\Generated_Source\PSoC4/UART_1.c **** 
1533:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXBITCLKTX_COMPLETE_REG = txPeriod;
 1673              		.loc 1 1534 0
 1674 0094 044B     		ldr	r3, .L115+4
 1675 0096 054A     		ldr	r2, .L115+8
 1676 0098 1278     		ldrb	r2, [r2]
 1677 009a 1A70     		strb	r2, [r3]
 1678              	.L107:
 1679              	.LBE2:
1535:.\Generated_Source\PSoC4/UART_1.c ****             #else
1536:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXBITCTR_PERIOD_REG = txPeriod;
1537:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC4/UART_1.c **** 
1539:.\Generated_Source\PSoC4/UART_1.c ****             #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC4/UART_1.c ****                  (UART_1_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1542:.\Generated_Source\PSoC4/UART_1.c ****                                                       (uint8) ~UART_1_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC4/UART_1.c ****             }
1545:.\Generated_Source\PSoC4/UART_1.c ****         #endif    /* End UART_1_HD_ENABLED */
1546:.\Generated_Source\PSoC4/UART_1.c ****         }
1547:.\Generated_Source\PSoC4/UART_1.c ****     }
 1680              		.loc 1 1547 0
 1681 009c BD46     		mov	sp, r7
 1682 009e 04B0     		add	sp, sp, #16
 1683              		@ sp needed
 1684 00a0 80BD     		pop	{r7, pc}
 1685              	.L116:
 1686 00a2 C046     		.align	2
 1687              	.L115:
 1688 00a4 00000000 		.word	UART_1_initVar
 1689 00a8 30000F40 		.word	1074724912
 1690 00ac 06000000 		.word	txPeriod.4846
 1691 00b0 41000F40 		.word	1074724929
 1692 00b4 61000F40 		.word	1074724961
 1693              		.cfi_endproc
 1694              	.LFE25:
 1695              		.size	UART_1_SendBreak, .-UART_1_SendBreak
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 58


 1696              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 1697              		.align	2
 1698              		.global	UART_1_SetTxAddressMode
 1699              		.code	16
 1700              		.thumb_func
 1701              		.type	UART_1_SetTxAddressMode, %function
 1702              	UART_1_SetTxAddressMode:
 1703              	.LFB26:
1548:.\Generated_Source\PSoC4/UART_1.c **** 
1549:.\Generated_Source\PSoC4/UART_1.c **** 
1550:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1552:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC4/UART_1.c ****     *
1554:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1555:.\Generated_Source\PSoC4/UART_1.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:.\Generated_Source\PSoC4/UART_1.c ****     *
1557:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1558:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC4/UART_1.c ****     *       UART_1_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC4/UART_1.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC4/UART_1.c ****     *       UART_1_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC4/UART_1.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC4/UART_1.c ****     *
1564:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1565:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1566:.\Generated_Source\PSoC4/UART_1.c ****     *
1567:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1568:.\Generated_Source\PSoC4/UART_1.c ****     *  This function sets and clears UART_1_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC4/UART_1.c ****     *  register.
1570:.\Generated_Source\PSoC4/UART_1.c ****     *
1571:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC4/UART_1.c ****     {
 1704              		.loc 1 1573 0
 1705              		.cfi_startproc
 1706 0000 80B5     		push	{r7, lr}
 1707              		.cfi_def_cfa_offset 8
 1708              		.cfi_offset 7, -8
 1709              		.cfi_offset 14, -4
 1710 0002 82B0     		sub	sp, sp, #8
 1711              		.cfi_def_cfa_offset 16
 1712 0004 00AF     		add	r7, sp, #0
 1713              		.cfi_def_cfa_register 7
 1714 0006 021C     		mov	r2, r0
 1715 0008 FB1D     		add	r3, r7, #7
 1716 000a 1A70     		strb	r2, [r3]
1574:.\Generated_Source\PSoC4/UART_1.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC4/UART_1.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC4/UART_1.c ****         {
1577:.\Generated_Source\PSoC4/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1579:.\Generated_Source\PSoC4/UART_1.c ****                                                   UART_1_CTRL_MARK);
1580:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC4/UART_1.c ****         }
1582:.\Generated_Source\PSoC4/UART_1.c ****         else
1583:.\Generated_Source\PSoC4/UART_1.c ****         {
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 59


1584:.\Generated_Source\PSoC4/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1586:.\Generated_Source\PSoC4/UART_1.c ****                                                   (uint8) ~UART_1_CTRL_MARK);
1587:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC4/UART_1.c ****         }
1589:.\Generated_Source\PSoC4/UART_1.c ****     }
 1717              		.loc 1 1589 0
 1718 000c BD46     		mov	sp, r7
 1719 000e 02B0     		add	sp, sp, #8
 1720              		@ sp needed
 1721 0010 80BD     		pop	{r7, pc}
 1722              		.cfi_endproc
 1723              	.LFE26:
 1724              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 1725 0012 C046     		.bss
 1726              	txPeriod.4846:
 1727 0006 00       		.space	1
 1728              		.text
 1729              	.Letext0:
 1730              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 1731              		.section	.debug_info,"",%progbits
 1732              	.Ldebug_info0:
 1733 0000 C7050000 		.4byte	0x5c7
 1734 0004 0400     		.2byte	0x4
 1735 0006 00000000 		.4byte	.Ldebug_abbrev0
 1736 000a 04       		.byte	0x4
 1737 000b 01       		.uleb128 0x1
 1738 000c 3B030000 		.4byte	.LASF70
 1739 0010 01       		.byte	0x1
 1740 0011 07010000 		.4byte	.LASF71
 1741 0015 64020000 		.4byte	.LASF72
 1742 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1743 001d 00000000 		.4byte	0
 1744 0021 00000000 		.4byte	.Ldebug_line0
 1745 0025 02       		.uleb128 0x2
 1746 0026 01       		.byte	0x1
 1747 0027 06       		.byte	0x6
 1748 0028 B4000000 		.4byte	.LASF0
 1749 002c 02       		.uleb128 0x2
 1750 002d 01       		.byte	0x1
 1751 002e 08       		.byte	0x8
 1752 002f E9030000 		.4byte	.LASF1
 1753 0033 02       		.uleb128 0x2
 1754 0034 02       		.byte	0x2
 1755 0035 05       		.byte	0x5
 1756 0036 F7030000 		.4byte	.LASF2
 1757 003a 02       		.uleb128 0x2
 1758 003b 02       		.byte	0x2
 1759 003c 07       		.byte	0x7
 1760 003d AE010000 		.4byte	.LASF3
 1761 0041 02       		.uleb128 0x2
 1762 0042 04       		.byte	0x4
 1763 0043 05       		.byte	0x5
 1764 0044 D8000000 		.4byte	.LASF4
 1765 0048 02       		.uleb128 0x2
 1766 0049 04       		.byte	0x4
 1767 004a 07       		.byte	0x7
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 60


 1768 004b 97010000 		.4byte	.LASF5
 1769 004f 02       		.uleb128 0x2
 1770 0050 08       		.byte	0x8
 1771 0051 05       		.byte	0x5
 1772 0052 A6000000 		.4byte	.LASF6
 1773 0056 02       		.uleb128 0x2
 1774 0057 08       		.byte	0x8
 1775 0058 07       		.byte	0x7
 1776 0059 60000000 		.4byte	.LASF7
 1777 005d 03       		.uleb128 0x3
 1778 005e 04       		.byte	0x4
 1779 005f 05       		.byte	0x5
 1780 0060 696E7400 		.ascii	"int\000"
 1781 0064 02       		.uleb128 0x2
 1782 0065 04       		.byte	0x4
 1783 0066 07       		.byte	0x7
 1784 0067 67010000 		.4byte	.LASF8
 1785 006b 04       		.uleb128 0x4
 1786 006c EE000000 		.4byte	.LASF9
 1787 0070 02       		.byte	0x2
 1788 0071 A1       		.byte	0xa1
 1789 0072 2C000000 		.4byte	0x2c
 1790 0076 04       		.uleb128 0x4
 1791 0077 00000000 		.4byte	.LASF10
 1792 007b 02       		.byte	0x2
 1793 007c A2       		.byte	0xa2
 1794 007d 3A000000 		.4byte	0x3a
 1795 0081 02       		.uleb128 0x2
 1796 0082 04       		.byte	0x4
 1797 0083 04       		.byte	0x4
 1798 0084 35030000 		.4byte	.LASF11
 1799 0088 02       		.uleb128 0x2
 1800 0089 08       		.byte	0x8
 1801 008a 04       		.byte	0x4
 1802 008b F4000000 		.4byte	.LASF12
 1803 008f 04       		.uleb128 0x4
 1804 0090 69040000 		.4byte	.LASF13
 1805 0094 02       		.byte	0x2
 1806 0095 B2       		.byte	0xb2
 1807 0096 9A000000 		.4byte	0x9a
 1808 009a 02       		.uleb128 0x2
 1809 009b 01       		.byte	0x1
 1810 009c 08       		.byte	0x8
 1811 009d 64040000 		.4byte	.LASF14
 1812 00a1 05       		.uleb128 0x5
 1813 00a2 E4030000 		.4byte	.LASF15
 1814 00a6 02       		.byte	0x2
 1815 00a7 4B01     		.2byte	0x14b
 1816 00a9 AD000000 		.4byte	0xad
 1817 00ad 06       		.uleb128 0x6
 1818 00ae 6B000000 		.4byte	0x6b
 1819 00b2 02       		.uleb128 0x2
 1820 00b3 04       		.byte	0x4
 1821 00b4 07       		.byte	0x7
 1822 00b5 AC020000 		.4byte	.LASF16
 1823 00b9 07       		.uleb128 0x7
 1824 00ba E1000000 		.4byte	.LASF17
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 61


 1825 00be 01       		.byte	0x1
 1826 00bf 4C       		.byte	0x4c
 1827 00c0 00000000 		.4byte	.LFB0
 1828 00c4 24000000 		.4byte	.LFE0-.LFB0
 1829 00c8 01       		.uleb128 0x1
 1830 00c9 9C       		.byte	0x9c
 1831 00ca 07       		.uleb128 0x7
 1832 00cb 7F040000 		.4byte	.LASF18
 1833 00cf 01       		.byte	0x1
 1834 00d0 6A       		.byte	0x6a
 1835 00d1 00000000 		.4byte	.LFB1
 1836 00d5 5C000000 		.4byte	.LFE1-.LFB1
 1837 00d9 01       		.uleb128 0x1
 1838 00da 9C       		.byte	0x9c
 1839 00db 08       		.uleb128 0x8
 1840 00dc C1010000 		.4byte	.LASF19
 1841 00e0 01       		.byte	0x1
 1842 00e1 B7       		.byte	0xb7
 1843 00e2 00000000 		.4byte	.LFB2
 1844 00e6 68000000 		.4byte	.LFE2-.LFB2
 1845 00ea 01       		.uleb128 0x1
 1846 00eb 9C       		.byte	0x9c
 1847 00ec FF000000 		.4byte	0xff
 1848 00f0 09       		.uleb128 0x9
 1849 00f1 8B040000 		.4byte	.LASF21
 1850 00f5 01       		.byte	0x1
 1851 00f6 B9       		.byte	0xb9
 1852 00f7 6B000000 		.4byte	0x6b
 1853 00fb 02       		.uleb128 0x2
 1854 00fc 91       		.byte	0x91
 1855 00fd 6F       		.sleb128 -17
 1856 00fe 00       		.byte	0
 1857 00ff 08       		.uleb128 0x8
 1858 0100 25020000 		.4byte	.LASF20
 1859 0104 01       		.byte	0x1
 1860 0105 F0       		.byte	0xf0
 1861 0106 00000000 		.4byte	.LFB3
 1862 010a 68000000 		.4byte	.LFE3-.LFB3
 1863 010e 01       		.uleb128 0x1
 1864 010f 9C       		.byte	0x9c
 1865 0110 23010000 		.4byte	0x123
 1866 0114 09       		.uleb128 0x9
 1867 0115 8B040000 		.4byte	.LASF21
 1868 0119 01       		.byte	0x1
 1869 011a F2       		.byte	0xf2
 1870 011b 6B000000 		.4byte	0x6b
 1871 011f 02       		.uleb128 0x2
 1872 0120 91       		.byte	0x91
 1873 0121 6F       		.sleb128 -17
 1874 0122 00       		.byte	0
 1875 0123 0A       		.uleb128 0xa
 1876 0124 0A020000 		.4byte	.LASF47
 1877 0128 01       		.byte	0x1
 1878 0129 2701     		.2byte	0x127
 1879 012b 6B000000 		.4byte	0x6b
 1880 012f 00000000 		.4byte	.LFB4
 1881 0133 0C000000 		.4byte	.LFE4-.LFB4
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 62


 1882 0137 01       		.uleb128 0x1
 1883 0138 9C       		.byte	0x9c
 1884 0139 0B       		.uleb128 0xb
 1885 013a 01040000 		.4byte	.LASF22
 1886 013e 01       		.byte	0x1
 1887 013f 3F01     		.2byte	0x13f
 1888 0141 00000000 		.4byte	.LFB5
 1889 0145 12000000 		.4byte	.LFE5-.LFB5
 1890 0149 01       		.uleb128 0x1
 1891 014a 9C       		.byte	0x9c
 1892 014b 5F010000 		.4byte	0x15f
 1893 014f 0C       		.uleb128 0xc
 1894 0150 29010000 		.4byte	.LASF24
 1895 0154 01       		.byte	0x1
 1896 0155 3F01     		.2byte	0x13f
 1897 0157 6B000000 		.4byte	0x6b
 1898 015b 02       		.uleb128 0x2
 1899 015c 91       		.byte	0x91
 1900 015d 77       		.sleb128 -9
 1901 015e 00       		.byte	0
 1902 015f 0B       		.uleb128 0xb
 1903 0160 31010000 		.4byte	.LASF23
 1904 0164 01       		.byte	0x1
 1905 0165 6701     		.2byte	0x167
 1906 0167 00000000 		.4byte	.LFB6
 1907 016b 20000000 		.4byte	.LFE6-.LFB6
 1908 016f 01       		.uleb128 0x1
 1909 0170 9C       		.byte	0x9c
 1910 0171 85010000 		.4byte	0x185
 1911 0175 0C       		.uleb128 0xc
 1912 0176 03020000 		.4byte	.LASF25
 1913 017a 01       		.byte	0x1
 1914 017b 6701     		.2byte	0x167
 1915 017d 6B000000 		.4byte	0x6b
 1916 0181 02       		.uleb128 0x2
 1917 0182 91       		.byte	0x91
 1918 0183 77       		.sleb128 -9
 1919 0184 00       		.byte	0
 1920 0185 0D       		.uleb128 0xd
 1921 0186 4E000000 		.4byte	.LASF29
 1922 018a 01       		.byte	0x1
 1923 018b 8801     		.2byte	0x188
 1924 018d 6B000000 		.4byte	0x6b
 1925 0191 00000000 		.4byte	.LFB7
 1926 0195 A0000000 		.4byte	.LFE7-.LFB7
 1927 0199 01       		.uleb128 0x1
 1928 019a 9C       		.byte	0x9c
 1929 019b CD010000 		.4byte	0x1cd
 1930 019f 0E       		.uleb128 0xe
 1931 01a0 4D040000 		.4byte	.LASF26
 1932 01a4 01       		.byte	0x1
 1933 01a5 8A01     		.2byte	0x18a
 1934 01a7 6B000000 		.4byte	0x6b
 1935 01ab 02       		.uleb128 0x2
 1936 01ac 91       		.byte	0x91
 1937 01ad 77       		.sleb128 -9
 1938 01ae 0E       		.uleb128 0xe
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 63


 1939 01af 6F040000 		.4byte	.LASF27
 1940 01b3 01       		.byte	0x1
 1941 01b4 8E01     		.2byte	0x18e
 1942 01b6 6B000000 		.4byte	0x6b
 1943 01ba 02       		.uleb128 0x2
 1944 01bb 91       		.byte	0x91
 1945 01bc 76       		.sleb128 -10
 1946 01bd 0E       		.uleb128 0xe
 1947 01be 01030000 		.4byte	.LASF28
 1948 01c2 01       		.byte	0x1
 1949 01c3 8F01     		.2byte	0x18f
 1950 01c5 6B000000 		.4byte	0x6b
 1951 01c9 02       		.uleb128 0x2
 1952 01ca 91       		.byte	0x91
 1953 01cb 75       		.sleb128 -11
 1954 01cc 00       		.byte	0
 1955 01cd 0F       		.uleb128 0xf
 1956 01ce B8040000 		.4byte	.LASF30
 1957 01d2 01       		.byte	0x1
 1958 01d3 E501     		.2byte	0x1e5
 1959 01d5 6B000000 		.4byte	0x6b
 1960 01d9 00000000 		.4byte	.LFB8
 1961 01dd 48000000 		.4byte	.LFE8-.LFB8
 1962 01e1 01       		.uleb128 0x1
 1963 01e2 9C       		.byte	0x9c
 1964 01e3 F7010000 		.4byte	0x1f7
 1965 01e7 0E       		.uleb128 0xe
 1966 01e8 9C040000 		.4byte	.LASF31
 1967 01ec 01       		.byte	0x1
 1968 01ed E701     		.2byte	0x1e7
 1969 01ef 6B000000 		.4byte	0x6b
 1970 01f3 02       		.uleb128 0x2
 1971 01f4 91       		.byte	0x91
 1972 01f5 77       		.sleb128 -9
 1973 01f6 00       		.byte	0
 1974 01f7 0D       		.uleb128 0xd
 1975 01f8 CC040000 		.4byte	.LASF32
 1976 01fc 01       		.byte	0x1
 1977 01fd 1402     		.2byte	0x214
 1978 01ff 6B000000 		.4byte	0x6b
 1979 0203 00000000 		.4byte	.LFB9
 1980 0207 CC000000 		.4byte	.LFE9-.LFB9
 1981 020b 01       		.uleb128 0x1
 1982 020c 9C       		.byte	0x9c
 1983 020d 4E020000 		.4byte	0x24e
 1984 0211 0E       		.uleb128 0xe
 1985 0212 4D040000 		.4byte	.LASF26
 1986 0216 01       		.byte	0x1
 1987 0217 1602     		.2byte	0x216
 1988 0219 6B000000 		.4byte	0x6b
 1989 021d 02       		.uleb128 0x2
 1990 021e 91       		.byte	0x91
 1991 021f 77       		.sleb128 -9
 1992 0220 0E       		.uleb128 0xe
 1993 0221 12030000 		.4byte	.LASF33
 1994 0225 01       		.byte	0x1
 1995 0226 1702     		.2byte	0x217
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 64


 1996 0228 6B000000 		.4byte	0x6b
 1997 022c 02       		.uleb128 0x2
 1998 022d 91       		.byte	0x91
 1999 022e 74       		.sleb128 -12
 2000 022f 0E       		.uleb128 0xe
 2001 0230 6F040000 		.4byte	.LASF27
 2002 0234 01       		.byte	0x1
 2003 0235 1A02     		.2byte	0x21a
 2004 0237 6B000000 		.4byte	0x6b
 2005 023b 02       		.uleb128 0x2
 2006 023c 91       		.byte	0x91
 2007 023d 76       		.sleb128 -10
 2008 023e 0E       		.uleb128 0xe
 2009 023f 01030000 		.4byte	.LASF28
 2010 0243 01       		.byte	0x1
 2011 0244 1B02     		.2byte	0x21b
 2012 0246 6B000000 		.4byte	0x6b
 2013 024a 02       		.uleb128 0x2
 2014 024b 91       		.byte	0x91
 2015 024c 75       		.sleb128 -11
 2016 024d 00       		.byte	0
 2017 024e 0D       		.uleb128 0xd
 2018 024f 31020000 		.4byte	.LASF34
 2019 0253 01       		.byte	0x1
 2020 0254 7A02     		.2byte	0x27a
 2021 0256 76000000 		.4byte	0x76
 2022 025a 00000000 		.4byte	.LFB10
 2023 025e 40000000 		.4byte	.LFE10-.LFB10
 2024 0262 01       		.uleb128 0x1
 2025 0263 9C       		.byte	0x9c
 2026 0264 78020000 		.4byte	0x278
 2027 0268 0E       		.uleb128 0xe
 2028 0269 88010000 		.4byte	.LASF35
 2029 026d 01       		.byte	0x1
 2030 026e 7E02     		.2byte	0x27e
 2031 0270 76000000 		.4byte	0x76
 2032 0274 02       		.uleb128 0x2
 2033 0275 91       		.byte	0x91
 2034 0276 6E       		.sleb128 -18
 2035 0277 00       		.byte	0
 2036 0278 0D       		.uleb128 0xd
 2037 0279 36040000 		.4byte	.LASF36
 2038 027d 01       		.byte	0x1
 2039 027e AB02     		.2byte	0x2ab
 2040 0280 6B000000 		.4byte	0x6b
 2041 0284 00000000 		.4byte	.LFB11
 2042 0288 90000000 		.4byte	.LFE11-.LFB11
 2043 028c 01       		.uleb128 0x1
 2044 028d 9C       		.byte	0x9c
 2045 028e A2020000 		.4byte	0x2a2
 2046 0292 0E       		.uleb128 0xe
 2047 0293 A9010000 		.4byte	.LASF37
 2048 0297 01       		.byte	0x1
 2049 0298 AE02     		.2byte	0x2ae
 2050 029a 6B000000 		.4byte	0x6b
 2051 029e 02       		.uleb128 0x2
 2052 029f 91       		.byte	0x91
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 65


 2053 02a0 77       		.sleb128 -9
 2054 02a1 00       		.byte	0
 2055 02a2 10       		.uleb128 0x10
 2056 02a3 B7030000 		.4byte	.LASF38
 2057 02a7 01       		.byte	0x1
 2058 02a8 F502     		.2byte	0x2f5
 2059 02aa 00000000 		.4byte	.LFB12
 2060 02ae 78000000 		.4byte	.LFE12-.LFB12
 2061 02b2 01       		.uleb128 0x1
 2062 02b3 9C       		.byte	0x9c
 2063 02b4 C8020000 		.4byte	0x2c8
 2064 02b8 0E       		.uleb128 0xe
 2065 02b9 8B040000 		.4byte	.LASF21
 2066 02bd 01       		.byte	0x1
 2067 02be F702     		.2byte	0x2f7
 2068 02c0 6B000000 		.4byte	0x6b
 2069 02c4 02       		.uleb128 0x2
 2070 02c5 91       		.byte	0x91
 2071 02c6 6F       		.sleb128 -17
 2072 02c7 00       		.byte	0
 2073 02c8 0B       		.uleb128 0xb
 2074 02c9 CC030000 		.4byte	.LASF39
 2075 02cd 01       		.byte	0x1
 2076 02ce 2D03     		.2byte	0x32d
 2077 02d0 00000000 		.4byte	.LFB13
 2078 02d4 12000000 		.4byte	.LFE13-.LFB13
 2079 02d8 01       		.uleb128 0x1
 2080 02d9 9C       		.byte	0x9c
 2081 02da EE020000 		.4byte	0x2ee
 2082 02de 0C       		.uleb128 0xc
 2083 02df FB000000 		.4byte	.LASF40
 2084 02e3 01       		.byte	0x1
 2085 02e4 2D03     		.2byte	0x32d
 2086 02e6 6B000000 		.4byte	0x6b
 2087 02ea 02       		.uleb128 0x2
 2088 02eb 91       		.byte	0x91
 2089 02ec 77       		.sleb128 -9
 2090 02ed 00       		.byte	0
 2091 02ee 0B       		.uleb128 0xb
 2092 02ef B5020000 		.4byte	.LASF41
 2093 02f3 01       		.byte	0x1
 2094 02f4 5903     		.2byte	0x359
 2095 02f6 00000000 		.4byte	.LFB14
 2096 02fa 20000000 		.4byte	.LFE14-.LFB14
 2097 02fe 01       		.uleb128 0x1
 2098 02ff 9C       		.byte	0x9c
 2099 0300 14030000 		.4byte	0x314
 2100 0304 0C       		.uleb128 0xc
 2101 0305 DF020000 		.4byte	.LASF42
 2102 0309 01       		.byte	0x1
 2103 030a 5903     		.2byte	0x359
 2104 030c 6B000000 		.4byte	0x6b
 2105 0310 02       		.uleb128 0x2
 2106 0311 91       		.byte	0x91
 2107 0312 77       		.sleb128 -9
 2108 0313 00       		.byte	0
 2109 0314 0B       		.uleb128 0xb
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 66


 2110 0315 CA020000 		.4byte	.LASF43
 2111 0319 01       		.byte	0x1
 2112 031a 6D03     		.2byte	0x36d
 2113 031c 00000000 		.4byte	.LFB15
 2114 0320 20000000 		.4byte	.LFE15-.LFB15
 2115 0324 01       		.uleb128 0x1
 2116 0325 9C       		.byte	0x9c
 2117 0326 3A030000 		.4byte	0x33a
 2118 032a 0C       		.uleb128 0xc
 2119 032b DF020000 		.4byte	.LASF42
 2120 032f 01       		.byte	0x1
 2121 0330 6D03     		.2byte	0x36d
 2122 0332 6B000000 		.4byte	0x6b
 2123 0336 02       		.uleb128 0x2
 2124 0337 91       		.byte	0x91
 2125 0338 77       		.sleb128 -9
 2126 0339 00       		.byte	0
 2127 033a 0B       		.uleb128 0xb
 2128 033b 1B030000 		.4byte	.LASF44
 2129 033f 01       		.byte	0x1
 2130 0340 8C03     		.2byte	0x38c
 2131 0342 00000000 		.4byte	.LFB16
 2132 0346 20000000 		.4byte	.LFE16-.LFB16
 2133 034a 01       		.uleb128 0x1
 2134 034b 9C       		.byte	0x9c
 2135 034c 60030000 		.4byte	0x360
 2136 0350 0C       		.uleb128 0xc
 2137 0351 03020000 		.4byte	.LASF25
 2138 0355 01       		.byte	0x1
 2139 0356 8C03     		.2byte	0x38c
 2140 0358 6B000000 		.4byte	0x6b
 2141 035c 02       		.uleb128 0x2
 2142 035d 91       		.byte	0x91
 2143 035e 77       		.sleb128 -9
 2144 035f 00       		.byte	0
 2145 0360 0B       		.uleb128 0xb
 2146 0361 51020000 		.4byte	.LASF45
 2147 0365 01       		.byte	0x1
 2148 0366 AE03     		.2byte	0x3ae
 2149 0368 00000000 		.4byte	.LFB17
 2150 036c 2C000000 		.4byte	.LFE17-.LFB17
 2151 0370 01       		.uleb128 0x1
 2152 0371 9C       		.byte	0x9c
 2153 0372 86030000 		.4byte	0x386
 2154 0376 0C       		.uleb128 0xc
 2155 0377 1C000000 		.4byte	.LASF46
 2156 037b 01       		.byte	0x1
 2157 037c AE03     		.2byte	0x3ae
 2158 037e 6B000000 		.4byte	0x6b
 2159 0382 02       		.uleb128 0x2
 2160 0383 91       		.byte	0x91
 2161 0384 77       		.sleb128 -9
 2162 0385 00       		.byte	0
 2163 0386 0A       		.uleb128 0xa
 2164 0387 74010000 		.4byte	.LASF48
 2165 038b 01       		.byte	0x1
 2166 038c EB03     		.2byte	0x3eb
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 67


 2167 038e 6B000000 		.4byte	0x6b
 2168 0392 00000000 		.4byte	.LFB18
 2169 0396 14000000 		.4byte	.LFE18-.LFB18
 2170 039a 01       		.uleb128 0x1
 2171 039b 9C       		.byte	0x9c
 2172 039c 0B       		.uleb128 0xb
 2173 039d 27000000 		.4byte	.LASF49
 2174 03a1 01       		.byte	0x1
 2175 03a2 1104     		.2byte	0x411
 2176 03a4 00000000 		.4byte	.LFB19
 2177 03a8 34000000 		.4byte	.LFE19-.LFB19
 2178 03ac 01       		.uleb128 0x1
 2179 03ad 9C       		.byte	0x9c
 2180 03ae C2030000 		.4byte	0x3c2
 2181 03b2 0C       		.uleb128 0xc
 2182 03b3 1C000000 		.4byte	.LASF46
 2183 03b7 01       		.byte	0x1
 2184 03b8 1104     		.2byte	0x411
 2185 03ba 6B000000 		.4byte	0x6b
 2186 03be 02       		.uleb128 0x2
 2187 03bf 91       		.byte	0x91
 2188 03c0 77       		.sleb128 -9
 2189 03c1 00       		.byte	0
 2190 03c2 10       		.uleb128 0x10
 2191 03c3 40020000 		.4byte	.LASF50
 2192 03c7 01       		.byte	0x1
 2193 03c8 7904     		.2byte	0x479
 2194 03ca 00000000 		.4byte	.LFB20
 2195 03ce 54000000 		.4byte	.LFE20-.LFB20
 2196 03d2 01       		.uleb128 0x1
 2197 03d3 9C       		.byte	0x9c
 2198 03d4 F7030000 		.4byte	0x3f7
 2199 03d8 0C       		.uleb128 0xc
 2200 03d9 36000000 		.4byte	.LASF51
 2201 03dd 01       		.byte	0x1
 2202 03de 7904     		.2byte	0x479
 2203 03e0 F7030000 		.4byte	0x3f7
 2204 03e4 02       		.uleb128 0x2
 2205 03e5 91       		.byte	0x91
 2206 03e6 6C       		.sleb128 -20
 2207 03e7 0E       		.uleb128 0xe
 2208 03e8 CF010000 		.4byte	.LASF52
 2209 03ec 01       		.byte	0x1
 2210 03ed 7B04     		.2byte	0x47b
 2211 03ef 76000000 		.4byte	0x76
 2212 03f3 02       		.uleb128 0x2
 2213 03f4 91       		.byte	0x91
 2214 03f5 76       		.sleb128 -10
 2215 03f6 00       		.byte	0
 2216 03f7 11       		.uleb128 0x11
 2217 03f8 04       		.byte	0x4
 2218 03f9 FD030000 		.4byte	0x3fd
 2219 03fd 12       		.uleb128 0x12
 2220 03fe 8F000000 		.4byte	0x8f
 2221 0402 10       		.uleb128 0x10
 2222 0403 DB040000 		.4byte	.LASF53
 2223 0407 01       		.byte	0x1
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 68


 2224 0408 A704     		.2byte	0x4a7
 2225 040a 00000000 		.4byte	.LFB21
 2226 040e 58000000 		.4byte	.LFE21-.LFB21
 2227 0412 01       		.uleb128 0x1
 2228 0413 9C       		.byte	0x9c
 2229 0414 46040000 		.4byte	0x446
 2230 0418 0C       		.uleb128 0xc
 2231 0419 36000000 		.4byte	.LASF51
 2232 041d 01       		.byte	0x1
 2233 041e A704     		.2byte	0x4a7
 2234 0420 46040000 		.4byte	0x446
 2235 0424 02       		.uleb128 0x2
 2236 0425 91       		.byte	0x91
 2237 0426 6C       		.sleb128 -20
 2238 0427 0C       		.uleb128 0xc
 2239 0428 2C040000 		.4byte	.LASF54
 2240 042c 01       		.byte	0x1
 2241 042d A704     		.2byte	0x4a7
 2242 042f 6B000000 		.4byte	0x6b
 2243 0433 02       		.uleb128 0x2
 2244 0434 91       		.byte	0x91
 2245 0435 6B       		.sleb128 -21
 2246 0436 0E       		.uleb128 0xe
 2247 0437 CF010000 		.4byte	.LASF52
 2248 043b 01       		.byte	0x1
 2249 043c AA04     		.2byte	0x4aa
 2250 043e 6B000000 		.4byte	0x6b
 2251 0442 02       		.uleb128 0x2
 2252 0443 91       		.byte	0x91
 2253 0444 77       		.sleb128 -9
 2254 0445 00       		.byte	0
 2255 0446 11       		.uleb128 0x11
 2256 0447 04       		.byte	0x4
 2257 0448 4C040000 		.4byte	0x44c
 2258 044c 12       		.uleb128 0x12
 2259 044d 6B000000 		.4byte	0x6b
 2260 0451 10       		.uleb128 0x10
 2261 0452 C9000000 		.4byte	.LASF55
 2262 0456 01       		.byte	0x1
 2263 0457 CE04     		.2byte	0x4ce
 2264 0459 00000000 		.4byte	.LFB22
 2265 045d 34000000 		.4byte	.LFE22-.LFB22
 2266 0461 01       		.uleb128 0x1
 2267 0462 9C       		.byte	0x9c
 2268 0463 77040000 		.4byte	0x477
 2269 0467 0C       		.uleb128 0xc
 2270 0468 1C000000 		.4byte	.LASF46
 2271 046c 01       		.byte	0x1
 2272 046d CE04     		.2byte	0x4ce
 2273 046f 6B000000 		.4byte	0x6b
 2274 0473 02       		.uleb128 0x2
 2275 0474 91       		.byte	0x91
 2276 0475 77       		.sleb128 -9
 2277 0476 00       		.byte	0
 2278 0477 0F       		.uleb128 0xf
 2279 0478 8F000000 		.4byte	.LASF56
 2280 047c 01       		.byte	0x1
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 69


 2281 047d F904     		.2byte	0x4f9
 2282 047f 6B000000 		.4byte	0x6b
 2283 0483 00000000 		.4byte	.LFB23
 2284 0487 48000000 		.4byte	.LFE23-.LFB23
 2285 048b 01       		.uleb128 0x1
 2286 048c 9C       		.byte	0x9c
 2287 048d A1040000 		.4byte	0x4a1
 2288 0491 0E       		.uleb128 0xe
 2289 0492 A9010000 		.4byte	.LASF37
 2290 0496 01       		.byte	0x1
 2291 0497 FC04     		.2byte	0x4fc
 2292 0499 6B000000 		.4byte	0x6b
 2293 049d 02       		.uleb128 0x2
 2294 049e 91       		.byte	0x91
 2295 049f 77       		.sleb128 -9
 2296 04a0 00       		.byte	0
 2297 04a1 10       		.uleb128 0x10
 2298 04a2 07000000 		.4byte	.LASF57
 2299 04a6 01       		.byte	0x1
 2300 04a7 4A05     		.2byte	0x54a
 2301 04a9 00000000 		.4byte	.LFB24
 2302 04ad 44000000 		.4byte	.LFE24-.LFB24
 2303 04b1 01       		.uleb128 0x1
 2304 04b2 9C       		.byte	0x9c
 2305 04b3 C7040000 		.4byte	0x4c7
 2306 04b7 0E       		.uleb128 0xe
 2307 04b8 8B040000 		.4byte	.LASF21
 2308 04bc 01       		.byte	0x1
 2309 04bd 4C05     		.2byte	0x54c
 2310 04bf 6B000000 		.4byte	0x6b
 2311 04c3 02       		.uleb128 0x2
 2312 04c4 91       		.byte	0x91
 2313 04c5 6F       		.sleb128 -17
 2314 04c6 00       		.byte	0
 2315 04c7 0B       		.uleb128 0xb
 2316 04c8 3D000000 		.4byte	.LASF58
 2317 04cc 01       		.byte	0x1
 2318 04cd A005     		.2byte	0x5a0
 2319 04cf 00000000 		.4byte	.LFB25
 2320 04d3 B8000000 		.4byte	.LFE25-.LFB25
 2321 04d7 01       		.uleb128 0x1
 2322 04d8 9C       		.byte	0x9c
 2323 04d9 18050000 		.4byte	0x518
 2324 04dd 0C       		.uleb128 0xc
 2325 04de 5F010000 		.4byte	.LASF59
 2326 04e2 01       		.byte	0x1
 2327 04e3 A005     		.2byte	0x5a0
 2328 04e5 6B000000 		.4byte	0x6b
 2329 04e9 02       		.uleb128 0x2
 2330 04ea 91       		.byte	0x91
 2331 04eb 6F       		.sleb128 -17
 2332 04ec 13       		.uleb128 0x13
 2333 04ed 14000000 		.4byte	.LBB2
 2334 04f1 88000000 		.4byte	.LBE2-.LBB2
 2335 04f5 0E       		.uleb128 0xe
 2336 04f6 A4020000 		.4byte	.LASF60
 2337 04fa 01       		.byte	0x1
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 70


 2338 04fb A805     		.2byte	0x5a8
 2339 04fd 6B000000 		.4byte	0x6b
 2340 0501 02       		.uleb128 0x2
 2341 0502 91       		.byte	0x91
 2342 0503 77       		.sleb128 -9
 2343 0504 0E       		.uleb128 0xe
 2344 0505 C0000000 		.4byte	.LASF61
 2345 0509 01       		.byte	0x1
 2346 050a D005     		.2byte	0x5d0
 2347 050c 6B000000 		.4byte	0x6b
 2348 0510 05       		.uleb128 0x5
 2349 0511 03       		.byte	0x3
 2350 0512 06000000 		.4byte	txPeriod.4846
 2351 0516 00       		.byte	0
 2352 0517 00       		.byte	0
 2353 0518 0B       		.uleb128 0xb
 2354 0519 EB010000 		.4byte	.LASF62
 2355 051d 01       		.byte	0x1
 2356 051e 2406     		.2byte	0x624
 2357 0520 00000000 		.4byte	.LFB26
 2358 0524 12000000 		.4byte	.LFE26-.LFB26
 2359 0528 01       		.uleb128 0x1
 2360 0529 9C       		.byte	0x9c
 2361 052a 3E050000 		.4byte	0x53e
 2362 052e 0C       		.uleb128 0xc
 2363 052f FB000000 		.4byte	.LASF40
 2364 0533 01       		.byte	0x1
 2365 0534 2406     		.2byte	0x624
 2366 0536 6B000000 		.4byte	0x6b
 2367 053a 02       		.uleb128 0x2
 2368 053b 91       		.byte	0x91
 2369 053c 77       		.sleb128 -9
 2370 053d 00       		.byte	0
 2371 053e 14       		.uleb128 0x14
 2372 053f 1D040000 		.4byte	.LASF63
 2373 0543 01       		.byte	0x1
 2374 0544 1B       		.byte	0x1b
 2375 0545 6B000000 		.4byte	0x6b
 2376 0549 05       		.uleb128 0x5
 2377 054a 03       		.byte	0x3
 2378 054b 00000000 		.4byte	UART_1_initVar
 2379 054f 14       		.uleb128 0x14
 2380 0550 D8010000 		.4byte	.LASF64
 2381 0554 01       		.byte	0x1
 2382 0555 24       		.byte	0x24
 2383 0556 6B000000 		.4byte	0x6b
 2384 055a 05       		.uleb128 0x5
 2385 055b 03       		.byte	0x3
 2386 055c 00000000 		.4byte	UART_1_errorStatus
 2387 0560 15       		.uleb128 0x15
 2388 0561 6B000000 		.4byte	0x6b
 2389 0565 70050000 		.4byte	0x570
 2390 0569 16       		.uleb128 0x16
 2391 056a B2000000 		.4byte	0xb2
 2392 056e 0C       		.byte	0xc
 2393 056f 00       		.byte	0
 2394 0570 14       		.uleb128 0x14
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 71


 2395 0571 54040000 		.4byte	.LASF65
 2396 0575 01       		.byte	0x1
 2397 0576 25       		.byte	0x25
 2398 0577 81050000 		.4byte	0x581
 2399 057b 05       		.uleb128 0x5
 2400 057c 03       		.byte	0x3
 2401 057d 00000000 		.4byte	UART_1_rxBuffer
 2402 0581 06       		.uleb128 0x6
 2403 0582 60050000 		.4byte	0x560
 2404 0586 14       		.uleb128 0x14
 2405 0587 4B010000 		.4byte	.LASF66
 2406 058b 01       		.byte	0x1
 2407 058c 26       		.byte	0x26
 2408 058d AD000000 		.4byte	0xad
 2409 0591 05       		.uleb128 0x5
 2410 0592 03       		.byte	0x3
 2411 0593 00000000 		.4byte	UART_1_rxBufferRead
 2412 0597 14       		.uleb128 0x14
 2413 0598 A3040000 		.4byte	.LASF67
 2414 059c 01       		.byte	0x1
 2415 059d 27       		.byte	0x27
 2416 059e AD000000 		.4byte	0xad
 2417 05a2 05       		.uleb128 0x5
 2418 05a3 03       		.byte	0x3
 2419 05a4 00000000 		.4byte	UART_1_rxBufferWrite
 2420 05a8 14       		.uleb128 0x14
 2421 05a9 E7020000 		.4byte	.LASF68
 2422 05ad 01       		.byte	0x1
 2423 05ae 28       		.byte	0x28
 2424 05af AD000000 		.4byte	0xad
 2425 05b3 05       		.uleb128 0x5
 2426 05b4 03       		.byte	0x3
 2427 05b5 00000000 		.4byte	UART_1_rxBufferLoopDetect
 2428 05b9 14       		.uleb128 0x14
 2429 05ba 77000000 		.4byte	.LASF69
 2430 05be 01       		.byte	0x1
 2431 05bf 29       		.byte	0x29
 2432 05c0 AD000000 		.4byte	0xad
 2433 05c4 05       		.uleb128 0x5
 2434 05c5 03       		.byte	0x3
 2435 05c6 00000000 		.4byte	UART_1_rxBufferOverflow
 2436 05ca 00       		.byte	0
 2437              		.section	.debug_abbrev,"",%progbits
 2438              	.Ldebug_abbrev0:
 2439 0000 01       		.uleb128 0x1
 2440 0001 11       		.uleb128 0x11
 2441 0002 01       		.byte	0x1
 2442 0003 25       		.uleb128 0x25
 2443 0004 0E       		.uleb128 0xe
 2444 0005 13       		.uleb128 0x13
 2445 0006 0B       		.uleb128 0xb
 2446 0007 03       		.uleb128 0x3
 2447 0008 0E       		.uleb128 0xe
 2448 0009 1B       		.uleb128 0x1b
 2449 000a 0E       		.uleb128 0xe
 2450 000b 55       		.uleb128 0x55
 2451 000c 17       		.uleb128 0x17
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 72


 2452 000d 11       		.uleb128 0x11
 2453 000e 01       		.uleb128 0x1
 2454 000f 10       		.uleb128 0x10
 2455 0010 17       		.uleb128 0x17
 2456 0011 00       		.byte	0
 2457 0012 00       		.byte	0
 2458 0013 02       		.uleb128 0x2
 2459 0014 24       		.uleb128 0x24
 2460 0015 00       		.byte	0
 2461 0016 0B       		.uleb128 0xb
 2462 0017 0B       		.uleb128 0xb
 2463 0018 3E       		.uleb128 0x3e
 2464 0019 0B       		.uleb128 0xb
 2465 001a 03       		.uleb128 0x3
 2466 001b 0E       		.uleb128 0xe
 2467 001c 00       		.byte	0
 2468 001d 00       		.byte	0
 2469 001e 03       		.uleb128 0x3
 2470 001f 24       		.uleb128 0x24
 2471 0020 00       		.byte	0
 2472 0021 0B       		.uleb128 0xb
 2473 0022 0B       		.uleb128 0xb
 2474 0023 3E       		.uleb128 0x3e
 2475 0024 0B       		.uleb128 0xb
 2476 0025 03       		.uleb128 0x3
 2477 0026 08       		.uleb128 0x8
 2478 0027 00       		.byte	0
 2479 0028 00       		.byte	0
 2480 0029 04       		.uleb128 0x4
 2481 002a 16       		.uleb128 0x16
 2482 002b 00       		.byte	0
 2483 002c 03       		.uleb128 0x3
 2484 002d 0E       		.uleb128 0xe
 2485 002e 3A       		.uleb128 0x3a
 2486 002f 0B       		.uleb128 0xb
 2487 0030 3B       		.uleb128 0x3b
 2488 0031 0B       		.uleb128 0xb
 2489 0032 49       		.uleb128 0x49
 2490 0033 13       		.uleb128 0x13
 2491 0034 00       		.byte	0
 2492 0035 00       		.byte	0
 2493 0036 05       		.uleb128 0x5
 2494 0037 16       		.uleb128 0x16
 2495 0038 00       		.byte	0
 2496 0039 03       		.uleb128 0x3
 2497 003a 0E       		.uleb128 0xe
 2498 003b 3A       		.uleb128 0x3a
 2499 003c 0B       		.uleb128 0xb
 2500 003d 3B       		.uleb128 0x3b
 2501 003e 05       		.uleb128 0x5
 2502 003f 49       		.uleb128 0x49
 2503 0040 13       		.uleb128 0x13
 2504 0041 00       		.byte	0
 2505 0042 00       		.byte	0
 2506 0043 06       		.uleb128 0x6
 2507 0044 35       		.uleb128 0x35
 2508 0045 00       		.byte	0
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 73


 2509 0046 49       		.uleb128 0x49
 2510 0047 13       		.uleb128 0x13
 2511 0048 00       		.byte	0
 2512 0049 00       		.byte	0
 2513 004a 07       		.uleb128 0x7
 2514 004b 2E       		.uleb128 0x2e
 2515 004c 00       		.byte	0
 2516 004d 3F       		.uleb128 0x3f
 2517 004e 19       		.uleb128 0x19
 2518 004f 03       		.uleb128 0x3
 2519 0050 0E       		.uleb128 0xe
 2520 0051 3A       		.uleb128 0x3a
 2521 0052 0B       		.uleb128 0xb
 2522 0053 3B       		.uleb128 0x3b
 2523 0054 0B       		.uleb128 0xb
 2524 0055 27       		.uleb128 0x27
 2525 0056 19       		.uleb128 0x19
 2526 0057 11       		.uleb128 0x11
 2527 0058 01       		.uleb128 0x1
 2528 0059 12       		.uleb128 0x12
 2529 005a 06       		.uleb128 0x6
 2530 005b 40       		.uleb128 0x40
 2531 005c 18       		.uleb128 0x18
 2532 005d 9642     		.uleb128 0x2116
 2533 005f 19       		.uleb128 0x19
 2534 0060 00       		.byte	0
 2535 0061 00       		.byte	0
 2536 0062 08       		.uleb128 0x8
 2537 0063 2E       		.uleb128 0x2e
 2538 0064 01       		.byte	0x1
 2539 0065 3F       		.uleb128 0x3f
 2540 0066 19       		.uleb128 0x19
 2541 0067 03       		.uleb128 0x3
 2542 0068 0E       		.uleb128 0xe
 2543 0069 3A       		.uleb128 0x3a
 2544 006a 0B       		.uleb128 0xb
 2545 006b 3B       		.uleb128 0x3b
 2546 006c 0B       		.uleb128 0xb
 2547 006d 27       		.uleb128 0x27
 2548 006e 19       		.uleb128 0x19
 2549 006f 11       		.uleb128 0x11
 2550 0070 01       		.uleb128 0x1
 2551 0071 12       		.uleb128 0x12
 2552 0072 06       		.uleb128 0x6
 2553 0073 40       		.uleb128 0x40
 2554 0074 18       		.uleb128 0x18
 2555 0075 9642     		.uleb128 0x2116
 2556 0077 19       		.uleb128 0x19
 2557 0078 01       		.uleb128 0x1
 2558 0079 13       		.uleb128 0x13
 2559 007a 00       		.byte	0
 2560 007b 00       		.byte	0
 2561 007c 09       		.uleb128 0x9
 2562 007d 34       		.uleb128 0x34
 2563 007e 00       		.byte	0
 2564 007f 03       		.uleb128 0x3
 2565 0080 0E       		.uleb128 0xe
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 74


 2566 0081 3A       		.uleb128 0x3a
 2567 0082 0B       		.uleb128 0xb
 2568 0083 3B       		.uleb128 0x3b
 2569 0084 0B       		.uleb128 0xb
 2570 0085 49       		.uleb128 0x49
 2571 0086 13       		.uleb128 0x13
 2572 0087 02       		.uleb128 0x2
 2573 0088 18       		.uleb128 0x18
 2574 0089 00       		.byte	0
 2575 008a 00       		.byte	0
 2576 008b 0A       		.uleb128 0xa
 2577 008c 2E       		.uleb128 0x2e
 2578 008d 00       		.byte	0
 2579 008e 3F       		.uleb128 0x3f
 2580 008f 19       		.uleb128 0x19
 2581 0090 03       		.uleb128 0x3
 2582 0091 0E       		.uleb128 0xe
 2583 0092 3A       		.uleb128 0x3a
 2584 0093 0B       		.uleb128 0xb
 2585 0094 3B       		.uleb128 0x3b
 2586 0095 05       		.uleb128 0x5
 2587 0096 27       		.uleb128 0x27
 2588 0097 19       		.uleb128 0x19
 2589 0098 49       		.uleb128 0x49
 2590 0099 13       		.uleb128 0x13
 2591 009a 11       		.uleb128 0x11
 2592 009b 01       		.uleb128 0x1
 2593 009c 12       		.uleb128 0x12
 2594 009d 06       		.uleb128 0x6
 2595 009e 40       		.uleb128 0x40
 2596 009f 18       		.uleb128 0x18
 2597 00a0 9742     		.uleb128 0x2117
 2598 00a2 19       		.uleb128 0x19
 2599 00a3 00       		.byte	0
 2600 00a4 00       		.byte	0
 2601 00a5 0B       		.uleb128 0xb
 2602 00a6 2E       		.uleb128 0x2e
 2603 00a7 01       		.byte	0x1
 2604 00a8 3F       		.uleb128 0x3f
 2605 00a9 19       		.uleb128 0x19
 2606 00aa 03       		.uleb128 0x3
 2607 00ab 0E       		.uleb128 0xe
 2608 00ac 3A       		.uleb128 0x3a
 2609 00ad 0B       		.uleb128 0xb
 2610 00ae 3B       		.uleb128 0x3b
 2611 00af 05       		.uleb128 0x5
 2612 00b0 27       		.uleb128 0x27
 2613 00b1 19       		.uleb128 0x19
 2614 00b2 11       		.uleb128 0x11
 2615 00b3 01       		.uleb128 0x1
 2616 00b4 12       		.uleb128 0x12
 2617 00b5 06       		.uleb128 0x6
 2618 00b6 40       		.uleb128 0x40
 2619 00b7 18       		.uleb128 0x18
 2620 00b8 9742     		.uleb128 0x2117
 2621 00ba 19       		.uleb128 0x19
 2622 00bb 01       		.uleb128 0x1
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 75


 2623 00bc 13       		.uleb128 0x13
 2624 00bd 00       		.byte	0
 2625 00be 00       		.byte	0
 2626 00bf 0C       		.uleb128 0xc
 2627 00c0 05       		.uleb128 0x5
 2628 00c1 00       		.byte	0
 2629 00c2 03       		.uleb128 0x3
 2630 00c3 0E       		.uleb128 0xe
 2631 00c4 3A       		.uleb128 0x3a
 2632 00c5 0B       		.uleb128 0xb
 2633 00c6 3B       		.uleb128 0x3b
 2634 00c7 05       		.uleb128 0x5
 2635 00c8 49       		.uleb128 0x49
 2636 00c9 13       		.uleb128 0x13
 2637 00ca 02       		.uleb128 0x2
 2638 00cb 18       		.uleb128 0x18
 2639 00cc 00       		.byte	0
 2640 00cd 00       		.byte	0
 2641 00ce 0D       		.uleb128 0xd
 2642 00cf 2E       		.uleb128 0x2e
 2643 00d0 01       		.byte	0x1
 2644 00d1 3F       		.uleb128 0x3f
 2645 00d2 19       		.uleb128 0x19
 2646 00d3 03       		.uleb128 0x3
 2647 00d4 0E       		.uleb128 0xe
 2648 00d5 3A       		.uleb128 0x3a
 2649 00d6 0B       		.uleb128 0xb
 2650 00d7 3B       		.uleb128 0x3b
 2651 00d8 05       		.uleb128 0x5
 2652 00d9 27       		.uleb128 0x27
 2653 00da 19       		.uleb128 0x19
 2654 00db 49       		.uleb128 0x49
 2655 00dc 13       		.uleb128 0x13
 2656 00dd 11       		.uleb128 0x11
 2657 00de 01       		.uleb128 0x1
 2658 00df 12       		.uleb128 0x12
 2659 00e0 06       		.uleb128 0x6
 2660 00e1 40       		.uleb128 0x40
 2661 00e2 18       		.uleb128 0x18
 2662 00e3 9642     		.uleb128 0x2116
 2663 00e5 19       		.uleb128 0x19
 2664 00e6 01       		.uleb128 0x1
 2665 00e7 13       		.uleb128 0x13
 2666 00e8 00       		.byte	0
 2667 00e9 00       		.byte	0
 2668 00ea 0E       		.uleb128 0xe
 2669 00eb 34       		.uleb128 0x34
 2670 00ec 00       		.byte	0
 2671 00ed 03       		.uleb128 0x3
 2672 00ee 0E       		.uleb128 0xe
 2673 00ef 3A       		.uleb128 0x3a
 2674 00f0 0B       		.uleb128 0xb
 2675 00f1 3B       		.uleb128 0x3b
 2676 00f2 05       		.uleb128 0x5
 2677 00f3 49       		.uleb128 0x49
 2678 00f4 13       		.uleb128 0x13
 2679 00f5 02       		.uleb128 0x2
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 76


 2680 00f6 18       		.uleb128 0x18
 2681 00f7 00       		.byte	0
 2682 00f8 00       		.byte	0
 2683 00f9 0F       		.uleb128 0xf
 2684 00fa 2E       		.uleb128 0x2e
 2685 00fb 01       		.byte	0x1
 2686 00fc 3F       		.uleb128 0x3f
 2687 00fd 19       		.uleb128 0x19
 2688 00fe 03       		.uleb128 0x3
 2689 00ff 0E       		.uleb128 0xe
 2690 0100 3A       		.uleb128 0x3a
 2691 0101 0B       		.uleb128 0xb
 2692 0102 3B       		.uleb128 0x3b
 2693 0103 05       		.uleb128 0x5
 2694 0104 27       		.uleb128 0x27
 2695 0105 19       		.uleb128 0x19
 2696 0106 49       		.uleb128 0x49
 2697 0107 13       		.uleb128 0x13
 2698 0108 11       		.uleb128 0x11
 2699 0109 01       		.uleb128 0x1
 2700 010a 12       		.uleb128 0x12
 2701 010b 06       		.uleb128 0x6
 2702 010c 40       		.uleb128 0x40
 2703 010d 18       		.uleb128 0x18
 2704 010e 9742     		.uleb128 0x2117
 2705 0110 19       		.uleb128 0x19
 2706 0111 01       		.uleb128 0x1
 2707 0112 13       		.uleb128 0x13
 2708 0113 00       		.byte	0
 2709 0114 00       		.byte	0
 2710 0115 10       		.uleb128 0x10
 2711 0116 2E       		.uleb128 0x2e
 2712 0117 01       		.byte	0x1
 2713 0118 3F       		.uleb128 0x3f
 2714 0119 19       		.uleb128 0x19
 2715 011a 03       		.uleb128 0x3
 2716 011b 0E       		.uleb128 0xe
 2717 011c 3A       		.uleb128 0x3a
 2718 011d 0B       		.uleb128 0xb
 2719 011e 3B       		.uleb128 0x3b
 2720 011f 05       		.uleb128 0x5
 2721 0120 27       		.uleb128 0x27
 2722 0121 19       		.uleb128 0x19
 2723 0122 11       		.uleb128 0x11
 2724 0123 01       		.uleb128 0x1
 2725 0124 12       		.uleb128 0x12
 2726 0125 06       		.uleb128 0x6
 2727 0126 40       		.uleb128 0x40
 2728 0127 18       		.uleb128 0x18
 2729 0128 9642     		.uleb128 0x2116
 2730 012a 19       		.uleb128 0x19
 2731 012b 01       		.uleb128 0x1
 2732 012c 13       		.uleb128 0x13
 2733 012d 00       		.byte	0
 2734 012e 00       		.byte	0
 2735 012f 11       		.uleb128 0x11
 2736 0130 0F       		.uleb128 0xf
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 77


 2737 0131 00       		.byte	0
 2738 0132 0B       		.uleb128 0xb
 2739 0133 0B       		.uleb128 0xb
 2740 0134 49       		.uleb128 0x49
 2741 0135 13       		.uleb128 0x13
 2742 0136 00       		.byte	0
 2743 0137 00       		.byte	0
 2744 0138 12       		.uleb128 0x12
 2745 0139 26       		.uleb128 0x26
 2746 013a 00       		.byte	0
 2747 013b 49       		.uleb128 0x49
 2748 013c 13       		.uleb128 0x13
 2749 013d 00       		.byte	0
 2750 013e 00       		.byte	0
 2751 013f 13       		.uleb128 0x13
 2752 0140 0B       		.uleb128 0xb
 2753 0141 01       		.byte	0x1
 2754 0142 11       		.uleb128 0x11
 2755 0143 01       		.uleb128 0x1
 2756 0144 12       		.uleb128 0x12
 2757 0145 06       		.uleb128 0x6
 2758 0146 00       		.byte	0
 2759 0147 00       		.byte	0
 2760 0148 14       		.uleb128 0x14
 2761 0149 34       		.uleb128 0x34
 2762 014a 00       		.byte	0
 2763 014b 03       		.uleb128 0x3
 2764 014c 0E       		.uleb128 0xe
 2765 014d 3A       		.uleb128 0x3a
 2766 014e 0B       		.uleb128 0xb
 2767 014f 3B       		.uleb128 0x3b
 2768 0150 0B       		.uleb128 0xb
 2769 0151 49       		.uleb128 0x49
 2770 0152 13       		.uleb128 0x13
 2771 0153 3F       		.uleb128 0x3f
 2772 0154 19       		.uleb128 0x19
 2773 0155 02       		.uleb128 0x2
 2774 0156 18       		.uleb128 0x18
 2775 0157 00       		.byte	0
 2776 0158 00       		.byte	0
 2777 0159 15       		.uleb128 0x15
 2778 015a 01       		.uleb128 0x1
 2779 015b 01       		.byte	0x1
 2780 015c 49       		.uleb128 0x49
 2781 015d 13       		.uleb128 0x13
 2782 015e 01       		.uleb128 0x1
 2783 015f 13       		.uleb128 0x13
 2784 0160 00       		.byte	0
 2785 0161 00       		.byte	0
 2786 0162 16       		.uleb128 0x16
 2787 0163 21       		.uleb128 0x21
 2788 0164 00       		.byte	0
 2789 0165 49       		.uleb128 0x49
 2790 0166 13       		.uleb128 0x13
 2791 0167 2F       		.uleb128 0x2f
 2792 0168 0B       		.uleb128 0xb
 2793 0169 00       		.byte	0
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 78


 2794 016a 00       		.byte	0
 2795 016b 00       		.byte	0
 2796              		.section	.debug_aranges,"",%progbits
 2797 0000 EC000000 		.4byte	0xec
 2798 0004 0200     		.2byte	0x2
 2799 0006 00000000 		.4byte	.Ldebug_info0
 2800 000a 04       		.byte	0x4
 2801 000b 00       		.byte	0
 2802 000c 0000     		.2byte	0
 2803 000e 0000     		.2byte	0
 2804 0010 00000000 		.4byte	.LFB0
 2805 0014 24000000 		.4byte	.LFE0-.LFB0
 2806 0018 00000000 		.4byte	.LFB1
 2807 001c 5C000000 		.4byte	.LFE1-.LFB1
 2808 0020 00000000 		.4byte	.LFB2
 2809 0024 68000000 		.4byte	.LFE2-.LFB2
 2810 0028 00000000 		.4byte	.LFB3
 2811 002c 68000000 		.4byte	.LFE3-.LFB3
 2812 0030 00000000 		.4byte	.LFB4
 2813 0034 0C000000 		.4byte	.LFE4-.LFB4
 2814 0038 00000000 		.4byte	.LFB5
 2815 003c 12000000 		.4byte	.LFE5-.LFB5
 2816 0040 00000000 		.4byte	.LFB6
 2817 0044 20000000 		.4byte	.LFE6-.LFB6
 2818 0048 00000000 		.4byte	.LFB7
 2819 004c A0000000 		.4byte	.LFE7-.LFB7
 2820 0050 00000000 		.4byte	.LFB8
 2821 0054 48000000 		.4byte	.LFE8-.LFB8
 2822 0058 00000000 		.4byte	.LFB9
 2823 005c CC000000 		.4byte	.LFE9-.LFB9
 2824 0060 00000000 		.4byte	.LFB10
 2825 0064 40000000 		.4byte	.LFE10-.LFB10
 2826 0068 00000000 		.4byte	.LFB11
 2827 006c 90000000 		.4byte	.LFE11-.LFB11
 2828 0070 00000000 		.4byte	.LFB12
 2829 0074 78000000 		.4byte	.LFE12-.LFB12
 2830 0078 00000000 		.4byte	.LFB13
 2831 007c 12000000 		.4byte	.LFE13-.LFB13
 2832 0080 00000000 		.4byte	.LFB14
 2833 0084 20000000 		.4byte	.LFE14-.LFB14
 2834 0088 00000000 		.4byte	.LFB15
 2835 008c 20000000 		.4byte	.LFE15-.LFB15
 2836 0090 00000000 		.4byte	.LFB16
 2837 0094 20000000 		.4byte	.LFE16-.LFB16
 2838 0098 00000000 		.4byte	.LFB17
 2839 009c 2C000000 		.4byte	.LFE17-.LFB17
 2840 00a0 00000000 		.4byte	.LFB18
 2841 00a4 14000000 		.4byte	.LFE18-.LFB18
 2842 00a8 00000000 		.4byte	.LFB19
 2843 00ac 34000000 		.4byte	.LFE19-.LFB19
 2844 00b0 00000000 		.4byte	.LFB20
 2845 00b4 54000000 		.4byte	.LFE20-.LFB20
 2846 00b8 00000000 		.4byte	.LFB21
 2847 00bc 58000000 		.4byte	.LFE21-.LFB21
 2848 00c0 00000000 		.4byte	.LFB22
 2849 00c4 34000000 		.4byte	.LFE22-.LFB22
 2850 00c8 00000000 		.4byte	.LFB23
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 79


 2851 00cc 48000000 		.4byte	.LFE23-.LFB23
 2852 00d0 00000000 		.4byte	.LFB24
 2853 00d4 44000000 		.4byte	.LFE24-.LFB24
 2854 00d8 00000000 		.4byte	.LFB25
 2855 00dc B8000000 		.4byte	.LFE25-.LFB25
 2856 00e0 00000000 		.4byte	.LFB26
 2857 00e4 12000000 		.4byte	.LFE26-.LFB26
 2858 00e8 00000000 		.4byte	0
 2859 00ec 00000000 		.4byte	0
 2860              		.section	.debug_ranges,"",%progbits
 2861              	.Ldebug_ranges0:
 2862 0000 00000000 		.4byte	.LFB0
 2863 0004 24000000 		.4byte	.LFE0
 2864 0008 00000000 		.4byte	.LFB1
 2865 000c 5C000000 		.4byte	.LFE1
 2866 0010 00000000 		.4byte	.LFB2
 2867 0014 68000000 		.4byte	.LFE2
 2868 0018 00000000 		.4byte	.LFB3
 2869 001c 68000000 		.4byte	.LFE3
 2870 0020 00000000 		.4byte	.LFB4
 2871 0024 0C000000 		.4byte	.LFE4
 2872 0028 00000000 		.4byte	.LFB5
 2873 002c 12000000 		.4byte	.LFE5
 2874 0030 00000000 		.4byte	.LFB6
 2875 0034 20000000 		.4byte	.LFE6
 2876 0038 00000000 		.4byte	.LFB7
 2877 003c A0000000 		.4byte	.LFE7
 2878 0040 00000000 		.4byte	.LFB8
 2879 0044 48000000 		.4byte	.LFE8
 2880 0048 00000000 		.4byte	.LFB9
 2881 004c CC000000 		.4byte	.LFE9
 2882 0050 00000000 		.4byte	.LFB10
 2883 0054 40000000 		.4byte	.LFE10
 2884 0058 00000000 		.4byte	.LFB11
 2885 005c 90000000 		.4byte	.LFE11
 2886 0060 00000000 		.4byte	.LFB12
 2887 0064 78000000 		.4byte	.LFE12
 2888 0068 00000000 		.4byte	.LFB13
 2889 006c 12000000 		.4byte	.LFE13
 2890 0070 00000000 		.4byte	.LFB14
 2891 0074 20000000 		.4byte	.LFE14
 2892 0078 00000000 		.4byte	.LFB15
 2893 007c 20000000 		.4byte	.LFE15
 2894 0080 00000000 		.4byte	.LFB16
 2895 0084 20000000 		.4byte	.LFE16
 2896 0088 00000000 		.4byte	.LFB17
 2897 008c 2C000000 		.4byte	.LFE17
 2898 0090 00000000 		.4byte	.LFB18
 2899 0094 14000000 		.4byte	.LFE18
 2900 0098 00000000 		.4byte	.LFB19
 2901 009c 34000000 		.4byte	.LFE19
 2902 00a0 00000000 		.4byte	.LFB20
 2903 00a4 54000000 		.4byte	.LFE20
 2904 00a8 00000000 		.4byte	.LFB21
 2905 00ac 58000000 		.4byte	.LFE21
 2906 00b0 00000000 		.4byte	.LFB22
 2907 00b4 34000000 		.4byte	.LFE22
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 80


 2908 00b8 00000000 		.4byte	.LFB23
 2909 00bc 48000000 		.4byte	.LFE23
 2910 00c0 00000000 		.4byte	.LFB24
 2911 00c4 44000000 		.4byte	.LFE24
 2912 00c8 00000000 		.4byte	.LFB25
 2913 00cc B8000000 		.4byte	.LFE25
 2914 00d0 00000000 		.4byte	.LFB26
 2915 00d4 12000000 		.4byte	.LFE26
 2916 00d8 00000000 		.4byte	0
 2917 00dc 00000000 		.4byte	0
 2918              		.section	.debug_line,"",%progbits
 2919              	.Ldebug_line0:
 2920 0000 20030000 		.section	.debug_str,"MS",%progbits,1
 2920      02004500 
 2920      00000201 
 2920      FB0E0D00 
 2920      01010101 
 2921              	.LASF10:
 2922 0000 75696E74 		.ascii	"uint16\000"
 2922      313600
 2923              	.LASF57:
 2924 0007 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 2924      5F315F43 
 2924      6C656172 
 2924      54784275 
 2924      66666572 
 2925              	.LASF46:
 2926 001c 74784461 		.ascii	"txDataByte\000"
 2926      74614279 
 2926      746500
 2927              	.LASF49:
 2928 0027 55415254 		.ascii	"UART_1_PutChar\000"
 2928      5F315F50 
 2928      75744368 
 2928      617200
 2929              	.LASF51:
 2930 0036 73747269 		.ascii	"string\000"
 2930      6E6700
 2931              	.LASF58:
 2932 003d 55415254 		.ascii	"UART_1_SendBreak\000"
 2932      5F315F53 
 2932      656E6442 
 2932      7265616B 
 2932      00
 2933              	.LASF29:
 2934 004e 55415254 		.ascii	"UART_1_ReadRxData\000"
 2934      5F315F52 
 2934      65616452 
 2934      78446174 
 2934      6100
 2935              	.LASF7:
 2936 0060 6C6F6E67 		.ascii	"long long unsigned int\000"
 2936      206C6F6E 
 2936      6720756E 
 2936      7369676E 
 2936      65642069 
 2937              	.LASF69:
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 81


 2938 0077 55415254 		.ascii	"UART_1_rxBufferOverflow\000"
 2938      5F315F72 
 2938      78427566 
 2938      6665724F 
 2938      76657266 
 2939              	.LASF56:
 2940 008f 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 2940      5F315F47 
 2940      65745478 
 2940      42756666 
 2940      65725369 
 2941              	.LASF6:
 2942 00a6 6C6F6E67 		.ascii	"long long int\000"
 2942      206C6F6E 
 2942      6720696E 
 2942      7400
 2943              	.LASF0:
 2944 00b4 7369676E 		.ascii	"signed char\000"
 2944      65642063 
 2944      68617200 
 2945              	.LASF61:
 2946 00c0 74785065 		.ascii	"txPeriod\000"
 2946      72696F64 
 2946      00
 2947              	.LASF55:
 2948 00c9 55415254 		.ascii	"UART_1_PutCRLF\000"
 2948      5F315F50 
 2948      75744352 
 2948      4C4600
 2949              	.LASF4:
 2950 00d8 6C6F6E67 		.ascii	"long int\000"
 2950      20696E74 
 2950      00
 2951              	.LASF17:
 2952 00e1 55415254 		.ascii	"UART_1_Start\000"
 2952      5F315F53 
 2952      74617274 
 2952      00
 2953              	.LASF9:
 2954 00ee 75696E74 		.ascii	"uint8\000"
 2954      3800
 2955              	.LASF12:
 2956 00f4 646F7562 		.ascii	"double\000"
 2956      6C6500
 2957              	.LASF40:
 2958 00fb 61646472 		.ascii	"addressMode\000"
 2958      6573734D 
 2958      6F646500 
 2959              	.LASF71:
 2960 0107 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART_1.c\000"
 2960      6E657261 
 2960      7465645F 
 2960      536F7572 
 2960      63655C50 
 2961              	.LASF24:
 2962 0129 636F6E74 		.ascii	"control\000"
 2962      726F6C00 
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 82


 2963              	.LASF23:
 2964 0131 55415254 		.ascii	"UART_1_SetRxInterruptMode\000"
 2964      5F315F53 
 2964      65745278 
 2964      496E7465 
 2964      72727570 
 2965              	.LASF66:
 2966 014b 55415254 		.ascii	"UART_1_rxBufferRead\000"
 2966      5F315F72 
 2966      78427566 
 2966      66657252 
 2966      65616400 
 2967              	.LASF59:
 2968 015f 7265744D 		.ascii	"retMode\000"
 2968      6F646500 
 2969              	.LASF8:
 2970 0167 756E7369 		.ascii	"unsigned int\000"
 2970      676E6564 
 2970      20696E74 
 2970      00
 2971              	.LASF48:
 2972 0174 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 2972      5F315F52 
 2972      65616454 
 2972      78537461 
 2972      74757300 
 2973              	.LASF35:
 2974 0188 6C6F6345 		.ascii	"locErrorStatus\000"
 2974      72726F72 
 2974      53746174 
 2974      757300
 2975              	.LASF5:
 2976 0197 6C6F6E67 		.ascii	"long unsigned int\000"
 2976      20756E73 
 2976      69676E65 
 2976      6420696E 
 2976      7400
 2977              	.LASF37:
 2978 01a9 73697A65 		.ascii	"size\000"
 2978      00
 2979              	.LASF3:
 2980 01ae 73686F72 		.ascii	"short unsigned int\000"
 2980      7420756E 
 2980      7369676E 
 2980      65642069 
 2980      6E7400
 2981              	.LASF19:
 2982 01c1 55415254 		.ascii	"UART_1_Enable\000"
 2982      5F315F45 
 2982      6E61626C 
 2982      6500
 2983              	.LASF52:
 2984 01cf 62756649 		.ascii	"bufIndex\000"
 2984      6E646578 
 2984      00
 2985              	.LASF64:
 2986 01d8 55415254 		.ascii	"UART_1_errorStatus\000"
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 83


 2986      5F315F65 
 2986      72726F72 
 2986      53746174 
 2986      757300
 2987              	.LASF62:
 2988 01eb 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 2988      5F315F53 
 2988      65745478 
 2988      41646472 
 2988      6573734D 
 2989              	.LASF25:
 2990 0203 696E7453 		.ascii	"intSrc\000"
 2990      726300
 2991              	.LASF47:
 2992 020a 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 2992      5F315F52 
 2992      65616443 
 2992      6F6E7472 
 2992      6F6C5265 
 2993              	.LASF20:
 2994 0225 55415254 		.ascii	"UART_1_Stop\000"
 2994      5F315F53 
 2994      746F7000 
 2995              	.LASF34:
 2996 0231 55415254 		.ascii	"UART_1_GetByte\000"
 2996      5F315F47 
 2996      65744279 
 2996      746500
 2997              	.LASF50:
 2998 0240 55415254 		.ascii	"UART_1_PutString\000"
 2998      5F315F50 
 2998      75745374 
 2998      72696E67 
 2998      00
 2999              	.LASF45:
 3000 0251 55415254 		.ascii	"UART_1_WriteTxData\000"
 3000      5F315F57 
 3000      72697465 
 3000      54784461 
 3000      746100
 3001              	.LASF72:
 3002 0264 433A5C55 		.ascii	"C:\\Users\\Eric\\Documents\\GitHub\\Shifting\\Shift"
 3002      73657273 
 3002      5C457269 
 3002      635C446F 
 3002      63756D65 
 3003 0291 696E675C 		.ascii	"ing\\Shifting.cydsn\000"
 3003      53686966 
 3003      74696E67 
 3003      2E637964 
 3003      736E00
 3004              	.LASF60:
 3005 02a4 746D7053 		.ascii	"tmpStat\000"
 3005      74617400 
 3006              	.LASF16:
 3007 02ac 73697A65 		.ascii	"sizetype\000"
 3007      74797065 
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 84


 3007      00
 3008              	.LASF41:
 3009 02b5 55415254 		.ascii	"UART_1_SetRxAddress1\000"
 3009      5F315F53 
 3009      65745278 
 3009      41646472 
 3009      65737331 
 3010              	.LASF43:
 3011 02ca 55415254 		.ascii	"UART_1_SetRxAddress2\000"
 3011      5F315F53 
 3011      65745278 
 3011      41646472 
 3011      65737332 
 3012              	.LASF42:
 3013 02df 61646472 		.ascii	"address\000"
 3013      65737300 
 3014              	.LASF68:
 3015 02e7 55415254 		.ascii	"UART_1_rxBufferLoopDetect\000"
 3015      5F315F72 
 3015      78427566 
 3015      6665724C 
 3015      6F6F7044 
 3016              	.LASF28:
 3017 0301 6C6F6352 		.ascii	"locRxBufferWrite\000"
 3017      78427566 
 3017      66657257 
 3017      72697465 
 3017      00
 3018              	.LASF33:
 3019 0312 72785374 		.ascii	"rxStatus\000"
 3019      61747573 
 3019      00
 3020              	.LASF44:
 3021 031b 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 3021      5F315F53 
 3021      65745478 
 3021      496E7465 
 3021      72727570 
 3022              	.LASF11:
 3023 0335 666C6F61 		.ascii	"float\000"
 3023      7400
 3024              	.LASF70:
 3025 033b 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 3025      4320342E 
 3025      382E3420 
 3025      32303134 
 3025      30353236 
 3026 036e 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m0 -mthumb -g -O"
 3026      20726576 
 3026      6973696F 
 3026      6E203231 
 3026      31333538 
 3027 03a1 30202D66 		.ascii	"0 -ffunction-sections\000"
 3027      66756E63 
 3027      74696F6E 
 3027      2D736563 
 3027      74696F6E 
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 85


 3028              	.LASF38:
 3029 03b7 55415254 		.ascii	"UART_1_ClearRxBuffer\000"
 3029      5F315F43 
 3029      6C656172 
 3029      52784275 
 3029      66666572 
 3030              	.LASF39:
 3031 03cc 55415254 		.ascii	"UART_1_SetRxAddressMode\000"
 3031      5F315F53 
 3031      65745278 
 3031      41646472 
 3031      6573734D 
 3032              	.LASF15:
 3033 03e4 72656738 		.ascii	"reg8\000"
 3033      00
 3034              	.LASF1:
 3035 03e9 756E7369 		.ascii	"unsigned char\000"
 3035      676E6564 
 3035      20636861 
 3035      7200
 3036              	.LASF2:
 3037 03f7 73686F72 		.ascii	"short int\000"
 3037      7420696E 
 3037      7400
 3038              	.LASF22:
 3039 0401 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 3039      5F315F57 
 3039      72697465 
 3039      436F6E74 
 3039      726F6C52 
 3040              	.LASF63:
 3041 041d 55415254 		.ascii	"UART_1_initVar\000"
 3041      5F315F69 
 3041      6E697456 
 3041      617200
 3042              	.LASF54:
 3043 042c 62797465 		.ascii	"byteCount\000"
 3043      436F756E 
 3043      7400
 3044              	.LASF36:
 3045 0436 55415254 		.ascii	"UART_1_GetRxBufferSize\000"
 3045      5F315F47 
 3045      65745278 
 3045      42756666 
 3045      65725369 
 3046              	.LASF26:
 3047 044d 72784461 		.ascii	"rxData\000"
 3047      746100
 3048              	.LASF65:
 3049 0454 55415254 		.ascii	"UART_1_rxBuffer\000"
 3049      5F315F72 
 3049      78427566 
 3049      66657200 
 3050              	.LASF14:
 3051 0464 63686172 		.ascii	"char\000"
 3051      00
 3052              	.LASF13:
ARM GAS  C:\Users\Eric\AppData\Local\Temp\cckkiDxD.s 			page 86


 3053 0469 63686172 		.ascii	"char8\000"
 3053      3800
 3054              	.LASF27:
 3055 046f 6C6F6352 		.ascii	"locRxBufferRead\000"
 3055      78427566 
 3055      66657252 
 3055      65616400 
 3056              	.LASF18:
 3057 047f 55415254 		.ascii	"UART_1_Init\000"
 3057      5F315F49 
 3057      6E697400 
 3058              	.LASF21:
 3059 048b 656E6162 		.ascii	"enableInterrupts\000"
 3059      6C65496E 
 3059      74657272 
 3059      75707473 
 3059      00
 3060              	.LASF31:
 3061 049c 73746174 		.ascii	"status\000"
 3061      757300
 3062              	.LASF67:
 3063 04a3 55415254 		.ascii	"UART_1_rxBufferWrite\000"
 3063      5F315F72 
 3063      78427566 
 3063      66657257 
 3063      72697465 
 3064              	.LASF30:
 3065 04b8 55415254 		.ascii	"UART_1_ReadRxStatus\000"
 3065      5F315F52 
 3065      65616452 
 3065      78537461 
 3065      74757300 
 3066              	.LASF32:
 3067 04cc 55415254 		.ascii	"UART_1_GetChar\000"
 3067      5F315F47 
 3067      65744368 
 3067      617200
 3068              	.LASF53:
 3069 04db 55415254 		.ascii	"UART_1_PutArray\000"
 3069      5F315F50 
 3069      75744172 
 3069      72617900 
 3070              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
