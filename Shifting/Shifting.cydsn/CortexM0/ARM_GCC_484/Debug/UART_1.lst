ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART_1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_1_initVar
  18              		.bss
  19              		.type	UART_1_initVar, %object
  20              		.size	UART_1_initVar, 1
  21              	UART_1_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_1_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_1_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_1_Start, %function
  29              	UART_1_Start:
  30              	.LFB0:
  31              		.file 1 ".\\Generated_Source\\PSoC4\\UART_1.c"
   1:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC4/UART_1.c **** * Version 2.30
   4:.\Generated_Source\PSoC4/UART_1.c **** *
   5:.\Generated_Source\PSoC4/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC4/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART_1.c **** *
   8:.\Generated_Source\PSoC4/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC4/UART_1.c **** *
  10:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART_1.c **** * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART_1.c **** 
  17:.\Generated_Source\PSoC4/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC4/UART_1.c **** #include "CyLib.h"
  19:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_INTERNAL_CLOCK_USED)
  20:.\Generated_Source\PSoC4/UART_1.c ****     #include "UART_1_IntClock.h"
  21:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  22:.\Generated_Source\PSoC4/UART_1.c **** 
  23:.\Generated_Source\PSoC4/UART_1.c **** 
  24:.\Generated_Source\PSoC4/UART_1.c **** /***************************************
  25:.\Generated_Source\PSoC4/UART_1.c **** * Global data allocation
  26:.\Generated_Source\PSoC4/UART_1.c **** ***************************************/
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 2


  27:.\Generated_Source\PSoC4/UART_1.c **** 
  28:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_initVar = 0u;
  29:.\Generated_Source\PSoC4/UART_1.c **** #if( UART_1_TX_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
  30:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TXBUFFERSIZE];
  31:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_TX_ENABLED */
  34:.\Generated_Source\PSoC4/UART_1.c **** #if( ( UART_1_RX_ENABLED || UART_1_HD_ENABLED ) && \
  35:.\Generated_Source\PSoC4/UART_1.c ****      (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
  36:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RXBUFFERSIZE];
  37:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferRead = 0u;
  38:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  39:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  40:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow = 0u;
  41:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  42:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RXADDRESSMODE;
  43:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  44:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End EnableHWAddress */
  45:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_RX_ENABLED */
  46:.\Generated_Source\PSoC4/UART_1.c **** 
  47:.\Generated_Source\PSoC4/UART_1.c **** 
  48:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  49:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Start
  50:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  51:.\Generated_Source\PSoC4/UART_1.c **** *
  52:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  53:.\Generated_Source\PSoC4/UART_1.c **** *  Initialize and Enable the UART component.
  54:.\Generated_Source\PSoC4/UART_1.c **** *  Enable the clock input to enable operation.
  55:.\Generated_Source\PSoC4/UART_1.c **** *
  56:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  57:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  58:.\Generated_Source\PSoC4/UART_1.c **** *
  59:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  60:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC4/UART_1.c **** *
  62:.\Generated_Source\PSoC4/UART_1.c **** * Global variables:
  63:.\Generated_Source\PSoC4/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  64:.\Generated_Source\PSoC4/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  65:.\Generated_Source\PSoC4/UART_1.c **** *  and set to one (1u) the first time UART_Start() is called. This allows for
  66:.\Generated_Source\PSoC4/UART_1.c **** *  component initialization without re-initialization in all subsequent calls
  67:.\Generated_Source\PSoC4/UART_1.c **** *  to the UART_1_Start() routine.
  68:.\Generated_Source\PSoC4/UART_1.c **** *
  69:.\Generated_Source\PSoC4/UART_1.c **** * Reentrant:
  70:.\Generated_Source\PSoC4/UART_1.c **** *  No.
  71:.\Generated_Source\PSoC4/UART_1.c **** *
  72:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  73:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Start(void) 
  74:.\Generated_Source\PSoC4/UART_1.c **** {
  32              		.loc 1 74 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  75:.\Generated_Source\PSoC4/UART_1.c ****     /* If not Initialized then initialize all required hardware and software */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 3


  76:.\Generated_Source\PSoC4/UART_1.c ****     if(UART_1_initVar == 0u)
  40              		.loc 1 76 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  77:.\Generated_Source\PSoC4/UART_1.c ****     {
  78:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_Init();
  45              		.loc 1 78 0
  46 000c FFF7FEFF 		bl	UART_1_Init
  79:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_initVar = 1u;
  47              		.loc 1 79 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  80:.\Generated_Source\PSoC4/UART_1.c ****     }
  81:.\Generated_Source\PSoC4/UART_1.c ****     UART_1_Enable();
  52              		.loc 1 81 0
  53 0016 FFF7FEFF 		bl	UART_1_Enable
  82:.\Generated_Source\PSoC4/UART_1.c **** }
  54              		.loc 1 82 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_1_initVar
  62              		.cfi_endproc
  63              	.LFE0:
  64              		.size	UART_1_Start, .-UART_1_Start
  65              		.section	.text.UART_1_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_1_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_1_Init, %function
  71              	UART_1_Init:
  72              	.LFB1:
  83:.\Generated_Source\PSoC4/UART_1.c **** 
  84:.\Generated_Source\PSoC4/UART_1.c **** 
  85:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  86:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Init
  87:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  88:.\Generated_Source\PSoC4/UART_1.c **** *
  89:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  90:.\Generated_Source\PSoC4/UART_1.c **** *  Initialize component's parameters to the parameters set by user in the
  91:.\Generated_Source\PSoC4/UART_1.c **** *  customizer of the component placed onto schematic. Usually called in
  92:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Start().
  93:.\Generated_Source\PSoC4/UART_1.c **** *
  94:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  95:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  96:.\Generated_Source\PSoC4/UART_1.c **** *
  97:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  98:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  99:.\Generated_Source\PSoC4/UART_1.c **** *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 4


 100:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 101:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Init(void) 
 102:.\Generated_Source\PSoC4/UART_1.c **** {
  73              		.loc 1 102 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 103:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 104:.\Generated_Source\PSoC4/UART_1.c **** 
 105:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 106:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the RX Interrupt. */
 107:.\Generated_Source\PSoC4/UART_1.c ****             (void)CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 108:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 109:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 110:.\Generated_Source\PSoC4/UART_1.c **** 
 111:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 112:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RXAddressMode);
 113:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RXHWADDRESS1);
 114:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RXHWADDRESS2);
 115:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 116:.\Generated_Source\PSoC4/UART_1.c **** 
 117:.\Generated_Source\PSoC4/UART_1.c ****         /* Init Count7 period */
 118:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
  81              		.loc 1 118 0
  82 0004 084B     		ldr	r3, .L6
  83 0006 7222     		mov	r2, #114
  84 0008 1A70     		strb	r2, [r3]
 119:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 120:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
  85              		.loc 1 120 0
  86 000a 084B     		ldr	r3, .L6+4
  87 000c 2022     		mov	r2, #32
  88 000e 1A70     		strb	r2, [r3]
 121:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 122:.\Generated_Source\PSoC4/UART_1.c **** 
 123:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 124:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 125:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the TX Interrupt. */
 126:.\Generated_Source\PSoC4/UART_1.c ****             (void)CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 127:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 128:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 129:.\Generated_Source\PSoC4/UART_1.c **** 
 130:.\Generated_Source\PSoC4/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 131:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXCLKGEN_DP)
 132:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  89              		.loc 1 132 0
  90 0010 074B     		ldr	r3, .L6+8
  91 0012 0722     		mov	r2, #7
  92 0014 1A70     		strb	r2, [r3]
 133:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = (UART_1_NUMBER_OF_DATA_BITS +
  93              		.loc 1 133 0
  94 0016 074B     		ldr	r3, .L6+12
  95 0018 4822     		mov	r2, #72
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 5


  96 001a 1A70     		strb	r2, [r3]
 134:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT;
 135:.\Generated_Source\PSoC4/UART_1.c ****         #else
 136:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 137:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 138:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 139:.\Generated_Source\PSoC4/UART_1.c **** 
 140:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 141:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 142:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 143:.\Generated_Source\PSoC4/UART_1.c ****         #else
 144:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  97              		.loc 1 144 0
  98 001c 064B     		ldr	r3, .L6+16
  99 001e 0022     		mov	r2, #0
 100 0020 1A70     		strb	r2, [r3]
 145:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 146:.\Generated_Source\PSoC4/UART_1.c **** 
 147:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 148:.\Generated_Source\PSoC4/UART_1.c **** 
 149:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 150:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_WriteControlRegister( \
 151:.\Generated_Source\PSoC4/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 152:.\Generated_Source\PSoC4/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 153:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 154:.\Generated_Source\PSoC4/UART_1.c **** }
 101              		.loc 1 154 0
 102 0022 BD46     		mov	sp, r7
 103              		@ sp needed
 104 0024 80BD     		pop	{r7, pc}
 105              	.L7:
 106 0026 C046     		.align	2
 107              	.L6:
 108 0028 80000F40 		.word	1074724992
 109 002c 82000F40 		.word	1074724994
 110 0030 20000F40 		.word	1074724896
 111 0034 30000F40 		.word	1074724912
 112 0038 81000F40 		.word	1074724993
 113              		.cfi_endproc
 114              	.LFE1:
 115              		.size	UART_1_Init, .-UART_1_Init
 116              		.section	.text.UART_1_Enable,"ax",%progbits
 117              		.align	2
 118              		.global	UART_1_Enable
 119              		.code	16
 120              		.thumb_func
 121              		.type	UART_1_Enable, %function
 122              	UART_1_Enable:
 123              	.LFB2:
 155:.\Generated_Source\PSoC4/UART_1.c **** 
 156:.\Generated_Source\PSoC4/UART_1.c **** 
 157:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 158:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Enable
 159:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 160:.\Generated_Source\PSoC4/UART_1.c **** *
 161:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 162:.\Generated_Source\PSoC4/UART_1.c **** *  Enables the UART block operation
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 6


 163:.\Generated_Source\PSoC4/UART_1.c **** *
 164:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 165:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 166:.\Generated_Source\PSoC4/UART_1.c **** *
 167:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 168:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 169:.\Generated_Source\PSoC4/UART_1.c **** *
 170:.\Generated_Source\PSoC4/UART_1.c **** * Global Variables:
 171:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 172:.\Generated_Source\PSoC4/UART_1.c **** *
 173:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 174:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Enable(void) 
 175:.\Generated_Source\PSoC4/UART_1.c **** {
 124              		.loc 1 175 0
 125              		.cfi_startproc
 126 0000 90B5     		push	{r4, r7, lr}
 127              		.cfi_def_cfa_offset 12
 128              		.cfi_offset 4, -12
 129              		.cfi_offset 7, -8
 130              		.cfi_offset 14, -4
 131 0002 83B0     		sub	sp, sp, #12
 132              		.cfi_def_cfa_offset 24
 133 0004 00AF     		add	r7, sp, #0
 134              		.cfi_def_cfa_register 7
 176:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 177:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 135              		.loc 1 177 0
 136 0006 FC1D     		add	r4, r7, #7
 137 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 138 000c 031C     		mov	r3, r0
 139 000e 2370     		strb	r3, [r4]
 178:.\Generated_Source\PSoC4/UART_1.c **** 
 179:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 180:.\Generated_Source\PSoC4/UART_1.c ****         /*RX Counter (Count7) Enable */
 181:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 140              		.loc 1 181 0
 141 0010 104B     		ldr	r3, .L9
 142 0012 104A     		ldr	r2, .L9
 143 0014 1278     		ldrb	r2, [r2]
 144 0016 D2B2     		uxtb	r2, r2
 145 0018 2021     		mov	r1, #32
 146 001a 0A43     		orr	r2, r1
 147 001c D2B2     		uxtb	r2, r2
 148 001e 1A70     		strb	r2, [r3]
 182:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the RX Interrupt. */
 183:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 149              		.loc 1 183 0
 150 0020 0D4B     		ldr	r3, .L9+4
 151 0022 0D4A     		ldr	r2, .L9+4
 152 0024 1278     		ldrb	r2, [r2]
 153 0026 D2B2     		uxtb	r2, r2
 154 0028 1021     		mov	r1, #16
 155 002a 0A43     		orr	r2, r1
 156 002c D2B2     		uxtb	r2, r2
 157 002e 1A70     		strb	r2, [r3]
 184:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 185:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 7


 186:.\Generated_Source\PSoC4/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 187:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 188:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 189:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 190:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 191:.\Generated_Source\PSoC4/UART_1.c **** 
 192:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 193:.\Generated_Source\PSoC4/UART_1.c ****         /*TX Counter (DP/Count7) Enable */
 194:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 195:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 196:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 197:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the TX Interrupt. */
 198:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 158              		.loc 1 198 0
 159 0030 0A4B     		ldr	r3, .L9+8
 160 0032 0A4A     		ldr	r2, .L9+8
 161 0034 1278     		ldrb	r2, [r2]
 162 0036 D2B2     		uxtb	r2, r2
 163 0038 1021     		mov	r1, #16
 164 003a 0A43     		orr	r2, r1
 165 003c D2B2     		uxtb	r2, r2
 166 003e 1A70     		strb	r2, [r3]
 199:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 200:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 201:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED*/
 202:.\Generated_Source\PSoC4/UART_1.c ****      #endif /* End UART_1_TX_ENABLED */
 203:.\Generated_Source\PSoC4/UART_1.c **** 
 204:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 205:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the clock. */
 206:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Start();
 167              		.loc 1 206 0
 168 0040 FFF7FEFF 		bl	UART_1_IntClock_Start
 207:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 208:.\Generated_Source\PSoC4/UART_1.c **** 
 209:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 169              		.loc 1 209 0
 170 0044 FB1D     		add	r3, r7, #7
 171 0046 1B78     		ldrb	r3, [r3]
 172 0048 181C     		mov	r0, r3
 173 004a FFF7FEFF 		bl	CyExitCriticalSection
 210:.\Generated_Source\PSoC4/UART_1.c **** }
 174              		.loc 1 210 0
 175 004e BD46     		mov	sp, r7
 176 0050 03B0     		add	sp, sp, #12
 177              		@ sp needed
 178 0052 90BD     		pop	{r4, r7, pc}
 179              	.L10:
 180              		.align	2
 181              	.L9:
 182 0054 90000F40 		.word	1074725008
 183 0058 92000F40 		.word	1074725010
 184 005c 91000F40 		.word	1074725009
 185              		.cfi_endproc
 186              	.LFE2:
 187              		.size	UART_1_Enable, .-UART_1_Enable
 188              		.section	.text.UART_1_Stop,"ax",%progbits
 189              		.align	2
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 8


 190              		.global	UART_1_Stop
 191              		.code	16
 192              		.thumb_func
 193              		.type	UART_1_Stop, %function
 194              	UART_1_Stop:
 195              	.LFB3:
 211:.\Generated_Source\PSoC4/UART_1.c **** 
 212:.\Generated_Source\PSoC4/UART_1.c **** 
 213:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 214:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Stop
 215:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 216:.\Generated_Source\PSoC4/UART_1.c **** *
 217:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 218:.\Generated_Source\PSoC4/UART_1.c **** *  Disable the UART component
 219:.\Generated_Source\PSoC4/UART_1.c **** *
 220:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 221:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 222:.\Generated_Source\PSoC4/UART_1.c **** *
 223:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 224:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 225:.\Generated_Source\PSoC4/UART_1.c **** *
 226:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 227:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Stop(void) 
 228:.\Generated_Source\PSoC4/UART_1.c **** {
 196              		.loc 1 228 0
 197              		.cfi_startproc
 198 0000 90B5     		push	{r4, r7, lr}
 199              		.cfi_def_cfa_offset 12
 200              		.cfi_offset 4, -12
 201              		.cfi_offset 7, -8
 202              		.cfi_offset 14, -4
 203 0002 83B0     		sub	sp, sp, #12
 204              		.cfi_def_cfa_offset 24
 205 0004 00AF     		add	r7, sp, #0
 206              		.cfi_def_cfa_register 7
 229:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 230:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 207              		.loc 1 230 0
 208 0006 FC1D     		add	r4, r7, #7
 209 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 210 000c 031C     		mov	r3, r0
 211 000e 2370     		strb	r3, [r4]
 231:.\Generated_Source\PSoC4/UART_1.c **** 
 232:.\Generated_Source\PSoC4/UART_1.c ****     /* Write Bit Counter Disable */
 233:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 234:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 212              		.loc 1 234 0
 213 0010 104B     		ldr	r3, .L12
 214 0012 104A     		ldr	r2, .L12
 215 0014 1278     		ldrb	r2, [r2]
 216 0016 D2B2     		uxtb	r2, r2
 217 0018 2021     		mov	r1, #32
 218 001a 8A43     		bic	r2, r1
 219 001c D2B2     		uxtb	r2, r2
 220 001e 1A70     		strb	r2, [r3]
 235:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 236:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 9


 237:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 238:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 239:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 240:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 241:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_ENABLED */
 242:.\Generated_Source\PSoC4/UART_1.c **** 
 243:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 244:.\Generated_Source\PSoC4/UART_1.c ****         /* Disable the clock. */
 245:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Stop();
 221              		.loc 1 245 0
 222 0020 FFF7FEFF 		bl	UART_1_IntClock_Stop
 246:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 247:.\Generated_Source\PSoC4/UART_1.c **** 
 248:.\Generated_Source\PSoC4/UART_1.c ****     /* Disable internal interrupt component */
 249:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 250:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8)~UART_1_INT_ENABLE;
 223              		.loc 1 250 0
 224 0024 0C4B     		ldr	r3, .L12+4
 225 0026 0C4A     		ldr	r2, .L12+4
 226 0028 1278     		ldrb	r2, [r2]
 227 002a D2B2     		uxtb	r2, r2
 228 002c 1021     		mov	r1, #16
 229 002e 8A43     		bic	r2, r1
 230 0030 D2B2     		uxtb	r2, r2
 231 0032 1A70     		strb	r2, [r3]
 251:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 252:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableRxInt();
 253:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 254:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 255:.\Generated_Source\PSoC4/UART_1.c **** 
 256:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 257:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8)~UART_1_INT_ENABLE;
 232              		.loc 1 257 0
 233 0034 094B     		ldr	r3, .L12+8
 234 0036 094A     		ldr	r2, .L12+8
 235 0038 1278     		ldrb	r2, [r2]
 236 003a D2B2     		uxtb	r2, r2
 237 003c 1021     		mov	r1, #16
 238 003e 8A43     		bic	r2, r1
 239 0040 D2B2     		uxtb	r2, r2
 240 0042 1A70     		strb	r2, [r3]
 258:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 259:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 260:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 261:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 262:.\Generated_Source\PSoC4/UART_1.c **** 
 263:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 241              		.loc 1 263 0
 242 0044 FB1D     		add	r3, r7, #7
 243 0046 1B78     		ldrb	r3, [r3]
 244 0048 181C     		mov	r0, r3
 245 004a FFF7FEFF 		bl	CyExitCriticalSection
 264:.\Generated_Source\PSoC4/UART_1.c **** }
 246              		.loc 1 264 0
 247 004e BD46     		mov	sp, r7
 248 0050 03B0     		add	sp, sp, #12
 249              		@ sp needed
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 10


 250 0052 90BD     		pop	{r4, r7, pc}
 251              	.L13:
 252              		.align	2
 253              	.L12:
 254 0054 90000F40 		.word	1074725008
 255 0058 92000F40 		.word	1074725010
 256 005c 91000F40 		.word	1074725009
 257              		.cfi_endproc
 258              	.LFE3:
 259              		.size	UART_1_Stop, .-UART_1_Stop
 260              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 261              		.align	2
 262              		.global	UART_1_ReadControlRegister
 263              		.code	16
 264              		.thumb_func
 265              		.type	UART_1_ReadControlRegister, %function
 266              	UART_1_ReadControlRegister:
 267              	.LFB4:
 265:.\Generated_Source\PSoC4/UART_1.c **** 
 266:.\Generated_Source\PSoC4/UART_1.c **** 
 267:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 268:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 269:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 270:.\Generated_Source\PSoC4/UART_1.c **** *
 271:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 272:.\Generated_Source\PSoC4/UART_1.c **** *  Read the current state of the control register
 273:.\Generated_Source\PSoC4/UART_1.c **** *
 274:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 275:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 276:.\Generated_Source\PSoC4/UART_1.c **** *
 277:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 278:.\Generated_Source\PSoC4/UART_1.c **** *  Current state of the control register.
 279:.\Generated_Source\PSoC4/UART_1.c **** *
 280:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 281:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 282:.\Generated_Source\PSoC4/UART_1.c **** {
 268              		.loc 1 282 0
 269              		.cfi_startproc
 270 0000 80B5     		push	{r7, lr}
 271              		.cfi_def_cfa_offset 8
 272              		.cfi_offset 7, -8
 273              		.cfi_offset 14, -4
 274 0002 00AF     		add	r7, sp, #0
 275              		.cfi_def_cfa_register 7
 283:.\Generated_Source\PSoC4/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 284:.\Generated_Source\PSoC4/UART_1.c ****         return(0u);
 276              		.loc 1 284 0
 277 0004 0023     		mov	r3, #0
 285:.\Generated_Source\PSoC4/UART_1.c ****     #else
 286:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_CONTROL_REG);
 287:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 288:.\Generated_Source\PSoC4/UART_1.c **** }
 278              		.loc 1 288 0
 279 0006 181C     		mov	r0, r3
 280 0008 BD46     		mov	sp, r7
 281              		@ sp needed
 282 000a 80BD     		pop	{r7, pc}
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 11


 283              		.cfi_endproc
 284              	.LFE4:
 285              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 286              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 287              		.align	2
 288              		.global	UART_1_WriteControlRegister
 289              		.code	16
 290              		.thumb_func
 291              		.type	UART_1_WriteControlRegister, %function
 292              	UART_1_WriteControlRegister:
 293              	.LFB5:
 289:.\Generated_Source\PSoC4/UART_1.c **** 
 290:.\Generated_Source\PSoC4/UART_1.c **** 
 291:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 292:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 293:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 294:.\Generated_Source\PSoC4/UART_1.c **** *
 295:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 296:.\Generated_Source\PSoC4/UART_1.c **** *  Writes an 8-bit value into the control register
 297:.\Generated_Source\PSoC4/UART_1.c **** *
 298:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 299:.\Generated_Source\PSoC4/UART_1.c **** *  control:  control register value
 300:.\Generated_Source\PSoC4/UART_1.c **** *
 301:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 302:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 303:.\Generated_Source\PSoC4/UART_1.c **** *
 304:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 305:.\Generated_Source\PSoC4/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 306:.\Generated_Source\PSoC4/UART_1.c **** {
 294              		.loc 1 306 0
 295              		.cfi_startproc
 296 0000 80B5     		push	{r7, lr}
 297              		.cfi_def_cfa_offset 8
 298              		.cfi_offset 7, -8
 299              		.cfi_offset 14, -4
 300 0002 82B0     		sub	sp, sp, #8
 301              		.cfi_def_cfa_offset 16
 302 0004 00AF     		add	r7, sp, #0
 303              		.cfi_def_cfa_register 7
 304 0006 021C     		mov	r2, r0
 305 0008 FB1D     		add	r3, r7, #7
 306 000a 1A70     		strb	r2, [r3]
 307:.\Generated_Source\PSoC4/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 308:.\Generated_Source\PSoC4/UART_1.c ****         if(control != 0u) { }      /* release compiler warning */
 309:.\Generated_Source\PSoC4/UART_1.c ****     #else
 310:.\Generated_Source\PSoC4/UART_1.c ****        UART_1_CONTROL_REG = control;
 311:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 312:.\Generated_Source\PSoC4/UART_1.c **** }
 307              		.loc 1 312 0
 308 000c BD46     		mov	sp, r7
 309 000e 02B0     		add	sp, sp, #8
 310              		@ sp needed
 311 0010 80BD     		pop	{r7, pc}
 312              		.cfi_endproc
 313              	.LFE5:
 314              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 315 0012 C046     		.section	.text.UART_1_SetRxInterruptMode,"ax",%progbits
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 12


 316              		.align	2
 317              		.global	UART_1_SetRxInterruptMode
 318              		.code	16
 319              		.thumb_func
 320              		.type	UART_1_SetRxInterruptMode, %function
 321              	UART_1_SetRxInterruptMode:
 322              	.LFB6:
 313:.\Generated_Source\PSoC4/UART_1.c **** 
 314:.\Generated_Source\PSoC4/UART_1.c **** 
 315:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 316:.\Generated_Source\PSoC4/UART_1.c **** 
 317:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_INTERRUPT_ENABLED)
 318:.\Generated_Source\PSoC4/UART_1.c **** 
 319:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 320:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_EnableRxInt
 321:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 322:.\Generated_Source\PSoC4/UART_1.c ****         *
 323:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 324:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable RX interrupt generation
 325:.\Generated_Source\PSoC4/UART_1.c ****         *
 326:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 327:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 328:.\Generated_Source\PSoC4/UART_1.c ****         *
 329:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 330:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 331:.\Generated_Source\PSoC4/UART_1.c ****         *
 332:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 333:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 334:.\Generated_Source\PSoC4/UART_1.c ****         *
 335:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 336:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_EnableRxInt(void) 
 337:.\Generated_Source\PSoC4/UART_1.c ****         {
 338:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
 339:.\Generated_Source\PSoC4/UART_1.c ****         }
 340:.\Generated_Source\PSoC4/UART_1.c **** 
 341:.\Generated_Source\PSoC4/UART_1.c **** 
 342:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 343:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_DisableRxInt
 344:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 345:.\Generated_Source\PSoC4/UART_1.c ****         *
 346:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 347:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable RX interrupt generation
 348:.\Generated_Source\PSoC4/UART_1.c ****         *
 349:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 350:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 351:.\Generated_Source\PSoC4/UART_1.c ****         *
 352:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 353:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 354:.\Generated_Source\PSoC4/UART_1.c ****         *
 355:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 356:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 357:.\Generated_Source\PSoC4/UART_1.c ****         *
 358:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_DisableRxInt(void) 
 360:.\Generated_Source\PSoC4/UART_1.c ****         {
 361:.\Generated_Source\PSoC4/UART_1.c ****             CyIntDisable(UART_1_RX_VECT_NUM);
 362:.\Generated_Source\PSoC4/UART_1.c ****         }
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 13


 363:.\Generated_Source\PSoC4/UART_1.c **** 
 364:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 365:.\Generated_Source\PSoC4/UART_1.c **** 
 366:.\Generated_Source\PSoC4/UART_1.c **** 
 367:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 368:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 369:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 370:.\Generated_Source\PSoC4/UART_1.c ****     *
 371:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 372:.\Generated_Source\PSoC4/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 373:.\Generated_Source\PSoC4/UART_1.c ****     *
 374:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 375:.\Generated_Source\PSoC4/UART_1.c ****     *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376:.\Generated_Source\PSoC4/UART_1.c ****     *           the header file)
 377:.\Generated_Source\PSoC4/UART_1.c ****     *
 378:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 379:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 380:.\Generated_Source\PSoC4/UART_1.c ****     *
 381:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 382:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 383:.\Generated_Source\PSoC4/UART_1.c ****     *
 384:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 385:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 386:.\Generated_Source\PSoC4/UART_1.c ****     {
 323              		.loc 1 386 0
 324              		.cfi_startproc
 325 0000 80B5     		push	{r7, lr}
 326              		.cfi_def_cfa_offset 8
 327              		.cfi_offset 7, -8
 328              		.cfi_offset 14, -4
 329 0002 82B0     		sub	sp, sp, #8
 330              		.cfi_def_cfa_offset 16
 331 0004 00AF     		add	r7, sp, #0
 332              		.cfi_def_cfa_register 7
 333 0006 021C     		mov	r2, r0
 334 0008 FB1D     		add	r3, r7, #7
 335 000a 1A70     		strb	r2, [r3]
 387:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 336              		.loc 1 387 0
 337 000c 034B     		ldr	r3, .L18
 338 000e FA1D     		add	r2, r7, #7
 339 0010 1278     		ldrb	r2, [r2]
 340 0012 1A70     		strb	r2, [r3]
 388:.\Generated_Source\PSoC4/UART_1.c ****     }
 341              		.loc 1 388 0
 342 0014 BD46     		mov	sp, r7
 343 0016 02B0     		add	sp, sp, #8
 344              		@ sp needed
 345 0018 80BD     		pop	{r7, pc}
 346              	.L19:
 347 001a C046     		.align	2
 348              	.L18:
 349 001c 82000F40 		.word	1074724994
 350              		.cfi_endproc
 351              	.LFE6:
 352              		.size	UART_1_SetRxInterruptMode, .-UART_1_SetRxInterruptMode
 353              		.section	.text.UART_1_ReadRxData,"ax",%progbits
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 14


 354              		.align	2
 355              		.global	UART_1_ReadRxData
 356              		.code	16
 357              		.thumb_func
 358              		.type	UART_1_ReadRxData, %function
 359              	UART_1_ReadRxData:
 360              	.LFB7:
 389:.\Generated_Source\PSoC4/UART_1.c **** 
 390:.\Generated_Source\PSoC4/UART_1.c **** 
 391:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 392:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxData
 393:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 394:.\Generated_Source\PSoC4/UART_1.c ****     *
 395:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 396:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns data in RX Data register without checking status register to
 397:.\Generated_Source\PSoC4/UART_1.c ****     *  determine if data is valid
 398:.\Generated_Source\PSoC4/UART_1.c ****     *
 399:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 400:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 401:.\Generated_Source\PSoC4/UART_1.c ****     *
 402:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 403:.\Generated_Source\PSoC4/UART_1.c ****     *  Received data from RX register
 404:.\Generated_Source\PSoC4/UART_1.c ****     *
 405:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 406:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 407:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 408:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 409:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 410:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 411:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 412:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 413:.\Generated_Source\PSoC4/UART_1.c ****     *
 414:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 415:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 416:.\Generated_Source\PSoC4/UART_1.c ****     *
 417:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 418:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 419:.\Generated_Source\PSoC4/UART_1.c ****     {
 361              		.loc 1 419 0
 362              		.cfi_startproc
 363 0000 80B5     		push	{r7, lr}
 364              		.cfi_def_cfa_offset 8
 365              		.cfi_offset 7, -8
 366              		.cfi_offset 14, -4
 367 0002 82B0     		sub	sp, sp, #8
 368              		.cfi_def_cfa_offset 16
 369 0004 00AF     		add	r7, sp, #0
 370              		.cfi_def_cfa_register 7
 420:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData;
 421:.\Generated_Source\PSoC4/UART_1.c **** 
 422:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 423:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferRead;
 424:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferWrite;
 425:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 426:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 427:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 428:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 15


 429:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 430:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 431:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 432:.\Generated_Source\PSoC4/UART_1.c **** 
 433:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 434:.\Generated_Source\PSoC4/UART_1.c ****             {
 435:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 436:.\Generated_Source\PSoC4/UART_1.c ****                 loc_rxBufferRead++;
 437:.\Generated_Source\PSoC4/UART_1.c **** 
 438:.\Generated_Source\PSoC4/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 439:.\Generated_Source\PSoC4/UART_1.c ****                 {
 440:.\Generated_Source\PSoC4/UART_1.c ****                     loc_rxBufferRead = 0u;
 441:.\Generated_Source\PSoC4/UART_1.c ****                 }
 442:.\Generated_Source\PSoC4/UART_1.c ****                 /* Update the real pointer */
 443:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 444:.\Generated_Source\PSoC4/UART_1.c **** 
 445:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect != 0u )
 446:.\Generated_Source\PSoC4/UART_1.c ****                 {
 447:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 448:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) && \
 449:.\Generated_Source\PSoC4/UART_1.c ****                          (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 450:.\Generated_Source\PSoC4/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 451:.\Generated_Source\PSoC4/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 452:.\Generated_Source\PSoC4/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 453:.\Generated_Source\PSoC4/UART_1.c ****                             {   /* In Half duplex mode return RX mask only in RX
 454:.\Generated_Source\PSoC4/UART_1.c ****                                 *  configuration set, otherwise
 455:.\Generated_Source\PSoC4/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 456:.\Generated_Source\PSoC4/UART_1.c ****                                 */
 457:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 458:.\Generated_Source\PSoC4/UART_1.c ****                             }
 459:.\Generated_Source\PSoC4/UART_1.c ****                         #else
 460:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 461:.\Generated_Source\PSoC4/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 462:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 463:.\Generated_Source\PSoC4/UART_1.c ****                 }
 464:.\Generated_Source\PSoC4/UART_1.c ****             }
 465:.\Generated_Source\PSoC4/UART_1.c ****             else
 466:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 467:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 468:.\Generated_Source\PSoC4/UART_1.c ****             }
 469:.\Generated_Source\PSoC4/UART_1.c **** 
 470:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 471:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 472:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 473:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 474:.\Generated_Source\PSoC4/UART_1.c **** 
 475:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 476:.\Generated_Source\PSoC4/UART_1.c **** 
 477:.\Generated_Source\PSoC4/UART_1.c ****             /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 371              		.loc 1 478 0
 372 0006 054A     		ldr	r2, .L22
 373 0008 FB1D     		add	r3, r7, #7
 374 000a 1278     		ldrb	r2, [r2]
 375 000c 1A70     		strb	r2, [r3]
 479:.\Generated_Source\PSoC4/UART_1.c **** 
 480:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 16


 481:.\Generated_Source\PSoC4/UART_1.c **** 
 482:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 376              		.loc 1 482 0
 377 000e FB1D     		add	r3, r7, #7
 378 0010 1B78     		ldrb	r3, [r3]
 483:.\Generated_Source\PSoC4/UART_1.c ****     }
 379              		.loc 1 483 0
 380 0012 181C     		mov	r0, r3
 381 0014 BD46     		mov	sp, r7
 382 0016 02B0     		add	sp, sp, #8
 383              		@ sp needed
 384 0018 80BD     		pop	{r7, pc}
 385              	.L23:
 386 001a C046     		.align	2
 387              	.L22:
 388 001c 43000F40 		.word	1074724931
 389              		.cfi_endproc
 390              	.LFE7:
 391              		.size	UART_1_ReadRxData, .-UART_1_ReadRxData
 392              		.section	.text.UART_1_ReadRxStatus,"ax",%progbits
 393              		.align	2
 394              		.global	UART_1_ReadRxStatus
 395              		.code	16
 396              		.thumb_func
 397              		.type	UART_1_ReadRxStatus, %function
 398              	UART_1_ReadRxStatus:
 399              	.LFB8:
 484:.\Generated_Source\PSoC4/UART_1.c **** 
 485:.\Generated_Source\PSoC4/UART_1.c **** 
 486:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 487:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 488:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 489:.\Generated_Source\PSoC4/UART_1.c ****     *
 490:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 491:.\Generated_Source\PSoC4/UART_1.c ****     *  Read the current state of the status register
 492:.\Generated_Source\PSoC4/UART_1.c ****     *  And detect software buffer overflow.
 493:.\Generated_Source\PSoC4/UART_1.c ****     *
 494:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 495:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 496:.\Generated_Source\PSoC4/UART_1.c ****     *
 497:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 498:.\Generated_Source\PSoC4/UART_1.c ****     *  Current state of the status register.
 499:.\Generated_Source\PSoC4/UART_1.c ****     *
 500:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 501:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 502:.\Generated_Source\PSoC4/UART_1.c ****     *   It set to one in RX interrupt when there isn?t free space in
 503:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 504:.\Generated_Source\PSoC4/UART_1.c ****     *   and cleared to zero by this API as an
 505:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506:.\Generated_Source\PSoC4/UART_1.c ****     *   bits.
 507:.\Generated_Source\PSoC4/UART_1.c ****     *
 508:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 509:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 510:.\Generated_Source\PSoC4/UART_1.c ****     {
 400              		.loc 1 510 0
 401              		.cfi_startproc
 402 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 17


 403              		.cfi_def_cfa_offset 8
 404              		.cfi_offset 7, -8
 405              		.cfi_offset 14, -4
 406 0002 82B0     		sub	sp, sp, #8
 407              		.cfi_def_cfa_offset 16
 408 0004 00AF     		add	r7, sp, #0
 409              		.cfi_def_cfa_register 7
 511:.\Generated_Source\PSoC4/UART_1.c ****         uint8 status;
 512:.\Generated_Source\PSoC4/UART_1.c **** 
 513:.\Generated_Source\PSoC4/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 410              		.loc 1 513 0
 411 0006 064B     		ldr	r3, .L26
 412 0008 1B78     		ldrb	r3, [r3]
 413 000a D9B2     		uxtb	r1, r3
 414 000c FB1D     		add	r3, r7, #7
 415 000e 7F22     		mov	r2, #127
 416 0010 0A40     		and	r2, r1
 417 0012 1A70     		strb	r2, [r3]
 514:.\Generated_Source\PSoC4/UART_1.c **** 
 515:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 516:.\Generated_Source\PSoC4/UART_1.c ****             if( UART_1_rxBufferOverflow != 0u )
 517:.\Generated_Source\PSoC4/UART_1.c ****             {
 518:.\Generated_Source\PSoC4/UART_1.c ****                 status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 519:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferOverflow = 0u;
 520:.\Generated_Source\PSoC4/UART_1.c ****             }
 521:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE */
 522:.\Generated_Source\PSoC4/UART_1.c **** 
 523:.\Generated_Source\PSoC4/UART_1.c ****         return(status);
 418              		.loc 1 523 0
 419 0014 FB1D     		add	r3, r7, #7
 420 0016 1B78     		ldrb	r3, [r3]
 524:.\Generated_Source\PSoC4/UART_1.c ****     }
 421              		.loc 1 524 0
 422 0018 181C     		mov	r0, r3
 423 001a BD46     		mov	sp, r7
 424 001c 02B0     		add	sp, sp, #8
 425              		@ sp needed
 426 001e 80BD     		pop	{r7, pc}
 427              	.L27:
 428              		.align	2
 429              	.L26:
 430 0020 62000F40 		.word	1074724962
 431              		.cfi_endproc
 432              	.LFE8:
 433              		.size	UART_1_ReadRxStatus, .-UART_1_ReadRxStatus
 434              		.section	.text.UART_1_GetChar,"ax",%progbits
 435              		.align	2
 436              		.global	UART_1_GetChar
 437              		.code	16
 438              		.thumb_func
 439              		.type	UART_1_GetChar, %function
 440              	UART_1_GetChar:
 441              	.LFB9:
 525:.\Generated_Source\PSoC4/UART_1.c **** 
 526:.\Generated_Source\PSoC4/UART_1.c **** 
 527:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 528:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetChar
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 18


 529:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 530:.\Generated_Source\PSoC4/UART_1.c ****     *
 531:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 532:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads UART RX buffer immediately, if data is not available or an error
 533:.\Generated_Source\PSoC4/UART_1.c ****     *  condition exists, zero is returned; otherwise, character is read and
 534:.\Generated_Source\PSoC4/UART_1.c ****     *  returned.
 535:.\Generated_Source\PSoC4/UART_1.c ****     *
 536:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 537:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 538:.\Generated_Source\PSoC4/UART_1.c ****     *
 539:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 540:.\Generated_Source\PSoC4/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541:.\Generated_Source\PSoC4/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 542:.\Generated_Source\PSoC4/UART_1.c ****     *
 543:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 544:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 545:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 546:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 547:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 548:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 549:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 550:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 551:.\Generated_Source\PSoC4/UART_1.c ****     *
 552:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 553:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 554:.\Generated_Source\PSoC4/UART_1.c ****     *
 555:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 556:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetChar(void) 
 557:.\Generated_Source\PSoC4/UART_1.c ****     {
 442              		.loc 1 557 0
 443              		.cfi_startproc
 444 0000 80B5     		push	{r7, lr}
 445              		.cfi_def_cfa_offset 8
 446              		.cfi_offset 7, -8
 447              		.cfi_offset 14, -4
 448 0002 82B0     		sub	sp, sp, #8
 449              		.cfi_def_cfa_offset 16
 450 0004 00AF     		add	r7, sp, #0
 451              		.cfi_def_cfa_register 7
 558:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData = 0u;
 452              		.loc 1 558 0
 453 0006 FB1D     		add	r3, r7, #7
 454 0008 0022     		mov	r2, #0
 455 000a 1A70     		strb	r2, [r3]
 559:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxStatus;
 560:.\Generated_Source\PSoC4/UART_1.c **** 
 561:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 562:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferRead;
 563:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferWrite;
 564:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 565:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 566:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 567:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 568:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 569:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 570:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 571:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 19


 572:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 573:.\Generated_Source\PSoC4/UART_1.c ****             {
 574:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 575:.\Generated_Source\PSoC4/UART_1.c ****                 loc_rxBufferRead++;
 576:.\Generated_Source\PSoC4/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 577:.\Generated_Source\PSoC4/UART_1.c ****                 {
 578:.\Generated_Source\PSoC4/UART_1.c ****                     loc_rxBufferRead = 0u;
 579:.\Generated_Source\PSoC4/UART_1.c ****                 }
 580:.\Generated_Source\PSoC4/UART_1.c ****                 /* Update the real pointer */
 581:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 582:.\Generated_Source\PSoC4/UART_1.c **** 
 583:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u )
 584:.\Generated_Source\PSoC4/UART_1.c ****                 {
 585:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 586:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 587:.\Generated_Source\PSoC4/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 588:.\Generated_Source\PSoC4/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 589:.\Generated_Source\PSoC4/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 590:.\Generated_Source\PSoC4/UART_1.c ****                             {   /* In Half duplex mode return RX mask only if
 591:.\Generated_Source\PSoC4/UART_1.c ****                                 *  RX configuration set, otherwise
 592:.\Generated_Source\PSoC4/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 593:.\Generated_Source\PSoC4/UART_1.c ****                                 */
 594:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 595:.\Generated_Source\PSoC4/UART_1.c ****                             }
 596:.\Generated_Source\PSoC4/UART_1.c ****                         #else
 597:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 598:.\Generated_Source\PSoC4/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 599:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 600:.\Generated_Source\PSoC4/UART_1.c ****                 }
 601:.\Generated_Source\PSoC4/UART_1.c **** 
 602:.\Generated_Source\PSoC4/UART_1.c ****             }
 603:.\Generated_Source\PSoC4/UART_1.c ****             else
 604:.\Generated_Source\PSoC4/UART_1.c ****             {   rxStatus = UART_1_RXSTATUS_REG;
 605:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 606:.\Generated_Source\PSoC4/UART_1.c ****                 {   /* Read received data from FIFO*/
 607:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = UART_1_RXDATA_REG;
 608:.\Generated_Source\PSoC4/UART_1.c ****                     /*Check status on error*/
 609:.\Generated_Source\PSoC4/UART_1.c ****                     if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 610:.\Generated_Source\PSoC4/UART_1.c ****                                    UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 611:.\Generated_Source\PSoC4/UART_1.c ****                     {
 612:.\Generated_Source\PSoC4/UART_1.c ****                         rxData = 0u;
 613:.\Generated_Source\PSoC4/UART_1.c ****                     }
 614:.\Generated_Source\PSoC4/UART_1.c ****                 }
 615:.\Generated_Source\PSoC4/UART_1.c ****             }
 616:.\Generated_Source\PSoC4/UART_1.c **** 
 617:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 618:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 619:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 620:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 621:.\Generated_Source\PSoC4/UART_1.c **** 
 622:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 623:.\Generated_Source\PSoC4/UART_1.c **** 
 624:.\Generated_Source\PSoC4/UART_1.c ****             rxStatus =UART_1_RXSTATUS_REG;
 456              		.loc 1 624 0
 457 000c 0D4A     		ldr	r2, .L31
 458 000e BB1D     		add	r3, r7, #6
 459 0010 1278     		ldrb	r2, [r2]
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 20


 460 0012 1A70     		strb	r2, [r3]
 625:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 461              		.loc 1 625 0
 462 0014 BB1D     		add	r3, r7, #6
 463 0016 1A78     		ldrb	r2, [r3]
 464 0018 2023     		mov	r3, #32
 465 001a 1340     		and	r3, r2
 466 001c 0BD0     		beq	.L29
 626:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Read received data from FIFO*/
 627:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 467              		.loc 1 627 0
 468 001e 0A4A     		ldr	r2, .L31+4
 469 0020 FB1D     		add	r3, r7, #7
 470 0022 1278     		ldrb	r2, [r2]
 471 0024 1A70     		strb	r2, [r3]
 628:.\Generated_Source\PSoC4/UART_1.c ****                 /*Check status on error*/
 629:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 630:.\Generated_Source\PSoC4/UART_1.c ****                                UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 472              		.loc 1 630 0
 473 0026 BB1D     		add	r3, r7, #6
 474 0028 1A78     		ldrb	r2, [r3]
 475 002a 1E23     		mov	r3, #30
 476 002c 1340     		and	r3, r2
 629:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 477              		.loc 1 629 0
 478 002e 02D0     		beq	.L29
 631:.\Generated_Source\PSoC4/UART_1.c ****                 {
 632:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = 0u;
 479              		.loc 1 632 0
 480 0030 FB1D     		add	r3, r7, #7
 481 0032 0022     		mov	r2, #0
 482 0034 1A70     		strb	r2, [r3]
 483              	.L29:
 633:.\Generated_Source\PSoC4/UART_1.c ****                 }
 634:.\Generated_Source\PSoC4/UART_1.c ****             }
 635:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 636:.\Generated_Source\PSoC4/UART_1.c **** 
 637:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 484              		.loc 1 637 0
 485 0036 FB1D     		add	r3, r7, #7
 486 0038 1B78     		ldrb	r3, [r3]
 638:.\Generated_Source\PSoC4/UART_1.c ****     }
 487              		.loc 1 638 0
 488 003a 181C     		mov	r0, r3
 489 003c BD46     		mov	sp, r7
 490 003e 02B0     		add	sp, sp, #8
 491              		@ sp needed
 492 0040 80BD     		pop	{r7, pc}
 493              	.L32:
 494 0042 C046     		.align	2
 495              	.L31:
 496 0044 62000F40 		.word	1074724962
 497 0048 43000F40 		.word	1074724931
 498              		.cfi_endproc
 499              	.LFE9:
 500              		.size	UART_1_GetChar, .-UART_1_GetChar
 501              		.section	.text.UART_1_GetByte,"ax",%progbits
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 21


 502              		.align	2
 503              		.global	UART_1_GetByte
 504              		.code	16
 505              		.thumb_func
 506              		.type	UART_1_GetByte, %function
 507              	UART_1_GetByte:
 508              	.LFB10:
 639:.\Generated_Source\PSoC4/UART_1.c **** 
 640:.\Generated_Source\PSoC4/UART_1.c **** 
 641:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 642:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetByte
 643:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 644:.\Generated_Source\PSoC4/UART_1.c ****     *
 645:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 646:.\Generated_Source\PSoC4/UART_1.c ****     *  Grab the next available byte of data from the recieve FIFO
 647:.\Generated_Source\PSoC4/UART_1.c ****     *
 648:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 649:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 650:.\Generated_Source\PSoC4/UART_1.c ****     *
 651:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 652:.\Generated_Source\PSoC4/UART_1.c ****     *  MSB contains Status Register and LSB contains UART RX data
 653:.\Generated_Source\PSoC4/UART_1.c ****     *
 654:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 655:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 656:.\Generated_Source\PSoC4/UART_1.c ****     *
 657:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 658:.\Generated_Source\PSoC4/UART_1.c ****     uint16 UART_1_GetByte(void) 
 659:.\Generated_Source\PSoC4/UART_1.c ****     {
 509              		.loc 1 659 0
 510              		.cfi_startproc
 511 0000 98B5     		push	{r3, r4, r7, lr}
 512              		.cfi_def_cfa_offset 16
 513              		.cfi_offset 3, -16
 514              		.cfi_offset 4, -12
 515              		.cfi_offset 7, -8
 516              		.cfi_offset 14, -4
 517 0002 00AF     		add	r7, sp, #0
 518              		.cfi_def_cfa_register 7
 660:.\Generated_Source\PSoC4/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 519              		.loc 1 660 0
 520 0004 FFF7FEFF 		bl	UART_1_ReadRxStatus
 521 0008 031C     		mov	r3, r0
 522 000a 1B02     		lsl	r3, r3, #8
 523 000c 9CB2     		uxth	r4, r3
 524 000e FFF7FEFF 		bl	UART_1_ReadRxData
 525 0012 031C     		mov	r3, r0
 526 0014 221C     		add	r2, r4, #0
 527 0016 1343     		orr	r3, r2
 528 0018 9BB2     		uxth	r3, r3
 529 001a 9BB2     		uxth	r3, r3
 661:.\Generated_Source\PSoC4/UART_1.c ****     }
 530              		.loc 1 661 0
 531 001c 181C     		mov	r0, r3
 532 001e BD46     		mov	sp, r7
 533              		@ sp needed
 534 0020 98BD     		pop	{r3, r4, r7, pc}
 535              		.cfi_endproc
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 22


 536              	.LFE10:
 537              		.size	UART_1_GetByte, .-UART_1_GetByte
 538 0022 C046     		.section	.text.UART_1_GetRxBufferSize,"ax",%progbits
 539              		.align	2
 540              		.global	UART_1_GetRxBufferSize
 541              		.code	16
 542              		.thumb_func
 543              		.type	UART_1_GetRxBufferSize, %function
 544              	UART_1_GetRxBufferSize:
 545              	.LFB11:
 662:.\Generated_Source\PSoC4/UART_1.c **** 
 663:.\Generated_Source\PSoC4/UART_1.c **** 
 664:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 665:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 666:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 667:.\Generated_Source\PSoC4/UART_1.c ****     *
 668:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 669:.\Generated_Source\PSoC4/UART_1.c ****     *  Determine the amount of bytes left in the RX buffer and return the count in
 670:.\Generated_Source\PSoC4/UART_1.c ****     *  bytes
 671:.\Generated_Source\PSoC4/UART_1.c ****     *
 672:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 673:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 674:.\Generated_Source\PSoC4/UART_1.c ****     *
 675:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 676:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8: Integer count of the number of bytes left
 677:.\Generated_Source\PSoC4/UART_1.c ****     *  in the RX buffer
 678:.\Generated_Source\PSoC4/UART_1.c ****     *
 679:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 680:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 681:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 682:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 683:.\Generated_Source\PSoC4/UART_1.c ****     *
 684:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 685:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 686:.\Generated_Source\PSoC4/UART_1.c ****     *
 687:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 688:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 689:.\Generated_Source\PSoC4/UART_1.c ****     *
 690:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 691:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 692:.\Generated_Source\PSoC4/UART_1.c ****                                                             
 693:.\Generated_Source\PSoC4/UART_1.c ****     {
 546              		.loc 1 693 0
 547              		.cfi_startproc
 548 0000 80B5     		push	{r7, lr}
 549              		.cfi_def_cfa_offset 8
 550              		.cfi_offset 7, -8
 551              		.cfi_offset 14, -4
 552 0002 82B0     		sub	sp, sp, #8
 553              		.cfi_def_cfa_offset 16
 554 0004 00AF     		add	r7, sp, #0
 555              		.cfi_def_cfa_register 7
 694:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
 695:.\Generated_Source\PSoC4/UART_1.c **** 
 696:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 697:.\Generated_Source\PSoC4/UART_1.c **** 
 698:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 23


 699:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 700:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 701:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 702:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 703:.\Generated_Source\PSoC4/UART_1.c **** 
 704:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC4/UART_1.c ****             {
 706:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u)
 707:.\Generated_Source\PSoC4/UART_1.c ****                 {
 708:.\Generated_Source\PSoC4/UART_1.c ****                     size = UART_1_RXBUFFERSIZE;
 709:.\Generated_Source\PSoC4/UART_1.c ****                 }
 710:.\Generated_Source\PSoC4/UART_1.c ****                 else
 711:.\Generated_Source\PSoC4/UART_1.c ****                 {
 712:.\Generated_Source\PSoC4/UART_1.c ****                     size = 0u;
 713:.\Generated_Source\PSoC4/UART_1.c ****                 }
 714:.\Generated_Source\PSoC4/UART_1.c ****             }
 715:.\Generated_Source\PSoC4/UART_1.c ****             else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 716:.\Generated_Source\PSoC4/UART_1.c ****             {
 717:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 718:.\Generated_Source\PSoC4/UART_1.c ****             }
 719:.\Generated_Source\PSoC4/UART_1.c ****             else
 720:.\Generated_Source\PSoC4/UART_1.c ****             {
 721:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_RXBUFFERSIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 722:.\Generated_Source\PSoC4/UART_1.c ****             }
 723:.\Generated_Source\PSoC4/UART_1.c **** 
 724:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 725:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 726:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 727:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 728:.\Generated_Source\PSoC4/UART_1.c **** 
 729:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 730:.\Generated_Source\PSoC4/UART_1.c **** 
 731:.\Generated_Source\PSoC4/UART_1.c ****             /* We can only know if there is data in the fifo. */
 732:.\Generated_Source\PSoC4/UART_1.c ****             size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 556              		.loc 1 732 0
 557 0006 094B     		ldr	r3, .L39
 558 0008 1B78     		ldrb	r3, [r3]
 559 000a DBB2     		uxtb	r3, r3
 560 000c 1A1C     		mov	r2, r3
 561 000e 2023     		mov	r3, #32
 562 0010 1340     		and	r3, r2
 563 0012 01D0     		beq	.L36
 564              		.loc 1 732 0 is_stmt 0 discriminator 1
 565 0014 0123     		mov	r3, #1
 566 0016 00E0     		b	.L37
 567              	.L36:
 568              		.loc 1 732 0 discriminator 2
 569 0018 0023     		mov	r3, #0
 570              	.L37:
 571              		.loc 1 732 0 discriminator 3
 572 001a FA1D     		add	r2, r7, #7
 573 001c 1370     		strb	r3, [r2]
 733:.\Generated_Source\PSoC4/UART_1.c **** 
 734:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 735:.\Generated_Source\PSoC4/UART_1.c **** 
 736:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 574              		.loc 1 736 0 is_stmt 1 discriminator 3
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 24


 575 001e FB1D     		add	r3, r7, #7
 576 0020 1B78     		ldrb	r3, [r3]
 737:.\Generated_Source\PSoC4/UART_1.c ****     }
 577              		.loc 1 737 0 discriminator 3
 578 0022 181C     		mov	r0, r3
 579 0024 BD46     		mov	sp, r7
 580 0026 02B0     		add	sp, sp, #8
 581              		@ sp needed
 582 0028 80BD     		pop	{r7, pc}
 583              	.L40:
 584 002a C046     		.align	2
 585              	.L39:
 586 002c 62000F40 		.word	1074724962
 587              		.cfi_endproc
 588              	.LFE11:
 589              		.size	UART_1_GetRxBufferSize, .-UART_1_GetRxBufferSize
 590              		.section	.text.UART_1_ClearRxBuffer,"ax",%progbits
 591              		.align	2
 592              		.global	UART_1_ClearRxBuffer
 593              		.code	16
 594              		.thumb_func
 595              		.type	UART_1_ClearRxBuffer, %function
 596              	UART_1_ClearRxBuffer:
 597              	.LFB12:
 738:.\Generated_Source\PSoC4/UART_1.c **** 
 739:.\Generated_Source\PSoC4/UART_1.c **** 
 740:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 741:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 742:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 743:.\Generated_Source\PSoC4/UART_1.c ****     *
 744:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 745:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears hardware RX FIFO.
 747:.\Generated_Source\PSoC4/UART_1.c ****     *
 748:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 749:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 750:.\Generated_Source\PSoC4/UART_1.c ****     *
 751:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 752:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 753:.\Generated_Source\PSoC4/UART_1.c ****     *
 754:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 755:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 756:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 757:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 758:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 759:.\Generated_Source\PSoC4/UART_1.c ****     *
 760:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 761:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 762:.\Generated_Source\PSoC4/UART_1.c ****     *
 763:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 764:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 765:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 766:.\Generated_Source\PSoC4/UART_1.c ****     *  have remained in the RAM.
 767:.\Generated_Source\PSoC4/UART_1.c ****     *
 768:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
 769:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 770:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 25


 771:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 772:.\Generated_Source\PSoC4/UART_1.c ****     {
 598              		.loc 1 772 0
 599              		.cfi_startproc
 600 0000 90B5     		push	{r4, r7, lr}
 601              		.cfi_def_cfa_offset 12
 602              		.cfi_offset 4, -12
 603              		.cfi_offset 7, -8
 604              		.cfi_offset 14, -4
 605 0002 83B0     		sub	sp, sp, #12
 606              		.cfi_def_cfa_offset 24
 607 0004 00AF     		add	r7, sp, #0
 608              		.cfi_def_cfa_register 7
 773:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
 774:.\Generated_Source\PSoC4/UART_1.c **** 
 775:.\Generated_Source\PSoC4/UART_1.c ****         /* clear the HW FIFO */
 776:.\Generated_Source\PSoC4/UART_1.c ****         /* Enter critical section */
 777:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 609              		.loc 1 777 0
 610 0006 FC1D     		add	r4, r7, #7
 611 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 612 000c 031C     		mov	r3, r0
 613 000e 2370     		strb	r3, [r4]
 778:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |=  UART_1_RX_FIFO_CLR;
 614              		.loc 1 778 0
 615 0010 0B4B     		ldr	r3, .L42
 616 0012 0B4A     		ldr	r2, .L42
 617 0014 1278     		ldrb	r2, [r2]
 618 0016 D2B2     		uxtb	r2, r2
 619 0018 0121     		mov	r1, #1
 620 001a 0A43     		orr	r2, r1
 621 001c D2B2     		uxtb	r2, r2
 622 001e 1A70     		strb	r2, [r3]
 779:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8)~UART_1_RX_FIFO_CLR;
 623              		.loc 1 779 0
 624 0020 074B     		ldr	r3, .L42
 625 0022 074A     		ldr	r2, .L42
 626 0024 1278     		ldrb	r2, [r2]
 627 0026 D2B2     		uxtb	r2, r2
 628 0028 0121     		mov	r1, #1
 629 002a 8A43     		bic	r2, r1
 630 002c D2B2     		uxtb	r2, r2
 631 002e 1A70     		strb	r2, [r3]
 780:.\Generated_Source\PSoC4/UART_1.c ****         /* Exit critical section */
 781:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 632              		.loc 1 781 0
 633 0030 FB1D     		add	r3, r7, #7
 634 0032 1B78     		ldrb	r3, [r3]
 635 0034 181C     		mov	r0, r3
 636 0036 FFF7FEFF 		bl	CyExitCriticalSection
 782:.\Generated_Source\PSoC4/UART_1.c **** 
 783:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 784:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 785:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 786:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 787:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 788:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 26


 789:.\Generated_Source\PSoC4/UART_1.c **** 
 790:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = 0u;
 791:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferWrite = 0u;
 792:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferLoopDetect = 0u;
 793:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 794:.\Generated_Source\PSoC4/UART_1.c **** 
 795:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 796:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 797:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 798:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 799:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 800:.\Generated_Source\PSoC4/UART_1.c **** 
 801:.\Generated_Source\PSoC4/UART_1.c ****     }
 637              		.loc 1 801 0
 638 003a BD46     		mov	sp, r7
 639 003c 03B0     		add	sp, sp, #12
 640              		@ sp needed
 641 003e 90BD     		pop	{r4, r7, pc}
 642              	.L43:
 643              		.align	2
 644              	.L42:
 645 0040 93000F40 		.word	1074725011
 646              		.cfi_endproc
 647              	.LFE12:
 648              		.size	UART_1_ClearRxBuffer, .-UART_1_ClearRxBuffer
 649              		.section	.text.UART_1_SetRxAddressMode,"ax",%progbits
 650              		.align	2
 651              		.global	UART_1_SetRxAddressMode
 652              		.code	16
 653              		.thumb_func
 654              		.type	UART_1_SetRxAddressMode, %function
 655              	UART_1_SetRxAddressMode:
 656              	.LFB13:
 802:.\Generated_Source\PSoC4/UART_1.c **** 
 803:.\Generated_Source\PSoC4/UART_1.c **** 
 804:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 805:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 806:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 807:.\Generated_Source\PSoC4/UART_1.c ****     *
 808:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 809:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the receive addressing mode
 810:.\Generated_Source\PSoC4/UART_1.c ****     *
 811:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 812:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 813:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 815:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 817:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 819:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 821:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 822:.\Generated_Source\PSoC4/UART_1.c ****     *
 823:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 824:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 825:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 27


 826:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 827:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 828:.\Generated_Source\PSoC4/UART_1.c ****     *   the farther usage in RX ISR.
 829:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 830:.\Generated_Source\PSoC4/UART_1.c ****     *
 831:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 832:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 833:.\Generated_Source\PSoC4/UART_1.c ****                                                         
 834:.\Generated_Source\PSoC4/UART_1.c ****     {
 657              		.loc 1 834 0
 658              		.cfi_startproc
 659 0000 80B5     		push	{r7, lr}
 660              		.cfi_def_cfa_offset 8
 661              		.cfi_offset 7, -8
 662              		.cfi_offset 14, -4
 663 0002 82B0     		sub	sp, sp, #8
 664              		.cfi_def_cfa_offset 16
 665 0004 00AF     		add	r7, sp, #0
 666              		.cfi_def_cfa_register 7
 667 0006 021C     		mov	r2, r0
 668 0008 FB1D     		add	r3, r7, #7
 669 000a 1A70     		strb	r2, [r3]
 835:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 836:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 837:.\Generated_Source\PSoC4/UART_1.c ****                 if(addressMode != 0u) { }     /* release compiler warning */
 838:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 839:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 tmpCtrl;
 840:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 841:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 842:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 843:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 844:.\Generated_Source\PSoC4/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 845:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 846:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 847:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 848:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 849:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 850:.\Generated_Source\PSoC4/UART_1.c ****             if(addressMode != 0u) { }     /* release compiler warning */
 851:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 852:.\Generated_Source\PSoC4/UART_1.c ****     }
 670              		.loc 1 852 0
 671 000c BD46     		mov	sp, r7
 672 000e 02B0     		add	sp, sp, #8
 673              		@ sp needed
 674 0010 80BD     		pop	{r7, pc}
 675              		.cfi_endproc
 676              	.LFE13:
 677              		.size	UART_1_SetRxAddressMode, .-UART_1_SetRxAddressMode
 678 0012 C046     		.section	.text.UART_1_SetRxAddress1,"ax",%progbits
 679              		.align	2
 680              		.global	UART_1_SetRxAddress1
 681              		.code	16
 682              		.thumb_func
 683              		.type	UART_1_SetRxAddress1, %function
 684              	UART_1_SetRxAddress1:
 685              	.LFB14:
 853:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 28


 854:.\Generated_Source\PSoC4/UART_1.c **** 
 855:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 856:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 857:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 858:.\Generated_Source\PSoC4/UART_1.c ****     *
 859:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 860:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the first hardware address compare value
 861:.\Generated_Source\PSoC4/UART_1.c ****     *
 862:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 863:.\Generated_Source\PSoC4/UART_1.c ****     *  address
 864:.\Generated_Source\PSoC4/UART_1.c ****     *
 865:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 866:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 867:.\Generated_Source\PSoC4/UART_1.c ****     *
 868:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 869:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 870:.\Generated_Source\PSoC4/UART_1.c **** 
 871:.\Generated_Source\PSoC4/UART_1.c ****     {
 686              		.loc 1 871 0
 687              		.cfi_startproc
 688 0000 80B5     		push	{r7, lr}
 689              		.cfi_def_cfa_offset 8
 690              		.cfi_offset 7, -8
 691              		.cfi_offset 14, -4
 692 0002 82B0     		sub	sp, sp, #8
 693              		.cfi_def_cfa_offset 16
 694 0004 00AF     		add	r7, sp, #0
 695              		.cfi_def_cfa_register 7
 696 0006 021C     		mov	r2, r0
 697 0008 FB1D     		add	r3, r7, #7
 698 000a 1A70     		strb	r2, [r3]
 872:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 699              		.loc 1 872 0
 700 000c 034B     		ldr	r3, .L46
 701 000e FA1D     		add	r2, r7, #7
 702 0010 1278     		ldrb	r2, [r2]
 703 0012 1A70     		strb	r2, [r3]
 873:.\Generated_Source\PSoC4/UART_1.c ****     }
 704              		.loc 1 873 0
 705 0014 BD46     		mov	sp, r7
 706 0016 02B0     		add	sp, sp, #8
 707              		@ sp needed
 708 0018 80BD     		pop	{r7, pc}
 709              	.L47:
 710 001a C046     		.align	2
 711              	.L46:
 712 001c 23000F40 		.word	1074724899
 713              		.cfi_endproc
 714              	.LFE14:
 715              		.size	UART_1_SetRxAddress1, .-UART_1_SetRxAddress1
 716              		.section	.text.UART_1_SetRxAddress2,"ax",%progbits
 717              		.align	2
 718              		.global	UART_1_SetRxAddress2
 719              		.code	16
 720              		.thumb_func
 721              		.type	UART_1_SetRxAddress2, %function
 722              	UART_1_SetRxAddress2:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 29


 723              	.LFB15:
 874:.\Generated_Source\PSoC4/UART_1.c **** 
 875:.\Generated_Source\PSoC4/UART_1.c **** 
 876:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 877:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 878:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 879:.\Generated_Source\PSoC4/UART_1.c ****     *
 880:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 881:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the second hardware address compare value
 882:.\Generated_Source\PSoC4/UART_1.c ****     *
 883:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 884:.\Generated_Source\PSoC4/UART_1.c ****     *  address
 885:.\Generated_Source\PSoC4/UART_1.c ****     *
 886:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 887:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 888:.\Generated_Source\PSoC4/UART_1.c ****     *
 889:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 890:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 891:.\Generated_Source\PSoC4/UART_1.c ****     {
 724              		.loc 1 891 0
 725              		.cfi_startproc
 726 0000 80B5     		push	{r7, lr}
 727              		.cfi_def_cfa_offset 8
 728              		.cfi_offset 7, -8
 729              		.cfi_offset 14, -4
 730 0002 82B0     		sub	sp, sp, #8
 731              		.cfi_def_cfa_offset 16
 732 0004 00AF     		add	r7, sp, #0
 733              		.cfi_def_cfa_register 7
 734 0006 021C     		mov	r2, r0
 735 0008 FB1D     		add	r3, r7, #7
 736 000a 1A70     		strb	r2, [r3]
 892:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 737              		.loc 1 892 0
 738 000c 034B     		ldr	r3, .L49
 739 000e FA1D     		add	r2, r7, #7
 740 0010 1278     		ldrb	r2, [r2]
 741 0012 1A70     		strb	r2, [r3]
 893:.\Generated_Source\PSoC4/UART_1.c ****     }
 742              		.loc 1 893 0
 743 0014 BD46     		mov	sp, r7
 744 0016 02B0     		add	sp, sp, #8
 745              		@ sp needed
 746 0018 80BD     		pop	{r7, pc}
 747              	.L50:
 748 001a C046     		.align	2
 749              	.L49:
 750 001c 33000F40 		.word	1074724915
 751              		.cfi_endproc
 752              	.LFE15:
 753              		.size	UART_1_SetRxAddress2, .-UART_1_SetRxAddress2
 754              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 755              		.align	2
 756              		.global	UART_1_SetTxInterruptMode
 757              		.code	16
 758              		.thumb_func
 759              		.type	UART_1_SetTxInterruptMode, %function
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 30


 760              	UART_1_SetTxInterruptMode:
 761              	.LFB16:
 894:.\Generated_Source\PSoC4/UART_1.c **** 
 895:.\Generated_Source\PSoC4/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 896:.\Generated_Source\PSoC4/UART_1.c **** 
 897:.\Generated_Source\PSoC4/UART_1.c **** 
 898:.\Generated_Source\PSoC4/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 899:.\Generated_Source\PSoC4/UART_1.c **** 
 900:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_INTERRUPT_ENABLED)
 901:.\Generated_Source\PSoC4/UART_1.c **** 
 902:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 903:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_EnableTxInt
 904:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 905:.\Generated_Source\PSoC4/UART_1.c ****         *
 906:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 907:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable TX interrupt generation
 908:.\Generated_Source\PSoC4/UART_1.c ****         *
 909:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 910:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 911:.\Generated_Source\PSoC4/UART_1.c ****         *
 912:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 913:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 914:.\Generated_Source\PSoC4/UART_1.c ****         *
 915:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 916:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 917:.\Generated_Source\PSoC4/UART_1.c ****         *
 918:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 919:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_EnableTxInt(void) 
 920:.\Generated_Source\PSoC4/UART_1.c ****         {
 921:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 922:.\Generated_Source\PSoC4/UART_1.c ****         }
 923:.\Generated_Source\PSoC4/UART_1.c **** 
 924:.\Generated_Source\PSoC4/UART_1.c **** 
 925:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 926:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_DisableTxInt
 927:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 928:.\Generated_Source\PSoC4/UART_1.c ****         *
 929:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 930:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable TX interrupt generation
 931:.\Generated_Source\PSoC4/UART_1.c ****         *
 932:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 933:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 934:.\Generated_Source\PSoC4/UART_1.c ****         *
 935:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 936:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 937:.\Generated_Source\PSoC4/UART_1.c ****         *
 938:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 939:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 940:.\Generated_Source\PSoC4/UART_1.c ****         *
 941:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_DisableTxInt(void) 
 943:.\Generated_Source\PSoC4/UART_1.c ****         {
 944:.\Generated_Source\PSoC4/UART_1.c ****             CyIntDisable(UART_1_TX_VECT_NUM);
 945:.\Generated_Source\PSoC4/UART_1.c ****         }
 946:.\Generated_Source\PSoC4/UART_1.c **** 
 947:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_INTERRUPT_ENABLED */
 948:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 31


 949:.\Generated_Source\PSoC4/UART_1.c **** 
 950:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 951:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 952:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 953:.\Generated_Source\PSoC4/UART_1.c ****     *
 954:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 955:.\Generated_Source\PSoC4/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 956:.\Generated_Source\PSoC4/UART_1.c ****     *
 957:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 958:.\Generated_Source\PSoC4/UART_1.c ****     *  intSrc: An or'd combination of the desired status bit masks (defined in
 959:.\Generated_Source\PSoC4/UART_1.c ****     *          the header file)
 960:.\Generated_Source\PSoC4/UART_1.c ****     *
 961:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 962:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 963:.\Generated_Source\PSoC4/UART_1.c ****     *
 964:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 965:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 966:.\Generated_Source\PSoC4/UART_1.c ****     *
 967:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 968:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 969:.\Generated_Source\PSoC4/UART_1.c ****     {
 762              		.loc 1 969 0
 763              		.cfi_startproc
 764 0000 80B5     		push	{r7, lr}
 765              		.cfi_def_cfa_offset 8
 766              		.cfi_offset 7, -8
 767              		.cfi_offset 14, -4
 768 0002 82B0     		sub	sp, sp, #8
 769              		.cfi_def_cfa_offset 16
 770 0004 00AF     		add	r7, sp, #0
 771              		.cfi_def_cfa_register 7
 772 0006 021C     		mov	r2, r0
 773 0008 FB1D     		add	r3, r7, #7
 774 000a 1A70     		strb	r2, [r3]
 970:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 775              		.loc 1 970 0
 776 000c 034B     		ldr	r3, .L52
 777 000e FA1D     		add	r2, r7, #7
 778 0010 1278     		ldrb	r2, [r2]
 779 0012 1A70     		strb	r2, [r3]
 971:.\Generated_Source\PSoC4/UART_1.c ****     }
 780              		.loc 1 971 0
 781 0014 BD46     		mov	sp, r7
 782 0016 02B0     		add	sp, sp, #8
 783              		@ sp needed
 784 0018 80BD     		pop	{r7, pc}
 785              	.L53:
 786 001a C046     		.align	2
 787              	.L52:
 788 001c 81000F40 		.word	1074724993
 789              		.cfi_endproc
 790              	.LFE16:
 791              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 792              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 793              		.align	2
 794              		.global	UART_1_WriteTxData
 795              		.code	16
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 32


 796              		.thumb_func
 797              		.type	UART_1_WriteTxData, %function
 798              	UART_1_WriteTxData:
 799              	.LFB17:
 972:.\Generated_Source\PSoC4/UART_1.c **** 
 973:.\Generated_Source\PSoC4/UART_1.c **** 
 974:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 975:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_WriteTxData
 976:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 977:.\Generated_Source\PSoC4/UART_1.c ****     *
 978:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 979:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980:.\Generated_Source\PSoC4/UART_1.c ****     *  bus is available. WriteTxData sends a byte without checking for buffer room
 981:.\Generated_Source\PSoC4/UART_1.c ****     *  or status. It is up to the user to separately check status.
 982:.\Generated_Source\PSoC4/UART_1.c ****     *
 983:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 984:.\Generated_Source\PSoC4/UART_1.c ****     *  TXDataByte: byte of data to place in the transmit FIFO
 985:.\Generated_Source\PSoC4/UART_1.c ****     *
 986:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 987:.\Generated_Source\PSoC4/UART_1.c ****     * void
 988:.\Generated_Source\PSoC4/UART_1.c ****     *
 989:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 990:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 991:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 992:.\Generated_Source\PSoC4/UART_1.c ****     *    incremented after each byte saved to buffer.
 993:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 994:.\Generated_Source\PSoC4/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 995:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 996:.\Generated_Source\PSoC4/UART_1.c ****     *    initialized.
 997:.\Generated_Source\PSoC4/UART_1.c ****     *
 998:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 999:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1000:.\Generated_Source\PSoC4/UART_1.c ****     *
1001:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1002:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
1003:.\Generated_Source\PSoC4/UART_1.c ****     {
 800              		.loc 1 1003 0
 801              		.cfi_startproc
 802 0000 80B5     		push	{r7, lr}
 803              		.cfi_def_cfa_offset 8
 804              		.cfi_offset 7, -8
 805              		.cfi_offset 14, -4
 806 0002 82B0     		sub	sp, sp, #8
 807              		.cfi_def_cfa_offset 16
 808 0004 00AF     		add	r7, sp, #0
 809              		.cfi_def_cfa_register 7
 810 0006 021C     		mov	r2, r0
 811 0008 FB1D     		add	r3, r7, #7
 812 000a 1A70     		strb	r2, [r3]
1004:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1005:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 813              		.loc 1 1005 0
 814 000c 054B     		ldr	r3, .L56
 815 000e 1B78     		ldrb	r3, [r3]
 816 0010 002B     		cmp	r3, #0
 817 0012 03D0     		beq	.L54
1006:.\Generated_Source\PSoC4/UART_1.c ****         {
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 33


1007:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1008:.\Generated_Source\PSoC4/UART_1.c **** 
1009:.\Generated_Source\PSoC4/UART_1.c ****                 /* Disable Tx interrupt. */
1010:.\Generated_Source\PSoC4/UART_1.c ****                 /* Protect variables that could change on interrupt. */
1011:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1012:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_DisableTxInt();
1013:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1014:.\Generated_Source\PSoC4/UART_1.c **** 
1015:.\Generated_Source\PSoC4/UART_1.c ****                 if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
1016:.\Generated_Source\PSoC4/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1017:.\Generated_Source\PSoC4/UART_1.c ****                 {
1018:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add directly to the FIFO. */
1019:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1020:.\Generated_Source\PSoC4/UART_1.c ****                 }
1021:.\Generated_Source\PSoC4/UART_1.c ****                 else
1022:.\Generated_Source\PSoC4/UART_1.c ****                 {
1023:.\Generated_Source\PSoC4/UART_1.c ****                     if(UART_1_txBufferWrite >= UART_1_TXBUFFERSIZE)
1024:.\Generated_Source\PSoC4/UART_1.c ****                     {
1025:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_txBufferWrite = 0u;
1026:.\Generated_Source\PSoC4/UART_1.c ****                     }
1027:.\Generated_Source\PSoC4/UART_1.c **** 
1028:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
1029:.\Generated_Source\PSoC4/UART_1.c **** 
1030:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add to the software buffer. */
1031:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite++;
1032:.\Generated_Source\PSoC4/UART_1.c **** 
1033:.\Generated_Source\PSoC4/UART_1.c ****                 }
1034:.\Generated_Source\PSoC4/UART_1.c **** 
1035:.\Generated_Source\PSoC4/UART_1.c ****                 /* Enable Tx interrupt. */
1036:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1037:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_EnableTxInt();
1038:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1039:.\Generated_Source\PSoC4/UART_1.c **** 
1040:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1041:.\Generated_Source\PSoC4/UART_1.c **** 
1042:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
1043:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 818              		.loc 1 1043 0
 819 0014 044B     		ldr	r3, .L56+4
 820 0016 FA1D     		add	r2, r7, #7
 821 0018 1278     		ldrb	r2, [r2]
 822 001a 1A70     		strb	r2, [r3]
 823              	.L54:
1044:.\Generated_Source\PSoC4/UART_1.c **** 
1045:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1046:.\Generated_Source\PSoC4/UART_1.c ****         }
1047:.\Generated_Source\PSoC4/UART_1.c ****     }
 824              		.loc 1 1047 0
 825 001c BD46     		mov	sp, r7
 826 001e 02B0     		add	sp, sp, #8
 827              		@ sp needed
 828 0020 80BD     		pop	{r7, pc}
 829              	.L57:
 830 0022 C046     		.align	2
 831              	.L56:
 832 0024 00000000 		.word	UART_1_initVar
 833 0028 41000F40 		.word	1074724929
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 34


 834              		.cfi_endproc
 835              	.LFE17:
 836              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 837              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 838              		.align	2
 839              		.global	UART_1_ReadTxStatus
 840              		.code	16
 841              		.thumb_func
 842              		.type	UART_1_ReadTxStatus, %function
 843              	UART_1_ReadTxStatus:
 844              	.LFB18:
1048:.\Generated_Source\PSoC4/UART_1.c **** 
1049:.\Generated_Source\PSoC4/UART_1.c **** 
1050:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1051:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
1052:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1053:.\Generated_Source\PSoC4/UART_1.c ****     *
1054:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1055:.\Generated_Source\PSoC4/UART_1.c ****     *  Read the status register for the component
1056:.\Generated_Source\PSoC4/UART_1.c ****     *
1057:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1058:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1059:.\Generated_Source\PSoC4/UART_1.c ****     *
1060:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1061:.\Generated_Source\PSoC4/UART_1.c ****     *  Contents of the status register
1062:.\Generated_Source\PSoC4/UART_1.c ****     *
1063:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1064:.\Generated_Source\PSoC4/UART_1.c ****     *  This function reads the status register which is clear on read. It is up to
1065:.\Generated_Source\PSoC4/UART_1.c ****     *  the user to handle all bits in this return value accordingly, even if the bit
1066:.\Generated_Source\PSoC4/UART_1.c ****     *  was not enabled as an interrupt source the event happened and must be handled
1067:.\Generated_Source\PSoC4/UART_1.c ****     *  accordingly.
1068:.\Generated_Source\PSoC4/UART_1.c ****     *
1069:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1070:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1071:.\Generated_Source\PSoC4/UART_1.c ****     {
 845              		.loc 1 1071 0
 846              		.cfi_startproc
 847 0000 80B5     		push	{r7, lr}
 848              		.cfi_def_cfa_offset 8
 849              		.cfi_offset 7, -8
 850              		.cfi_offset 14, -4
 851 0002 00AF     		add	r7, sp, #0
 852              		.cfi_def_cfa_register 7
1072:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 853              		.loc 1 1072 0
 854 0004 024B     		ldr	r3, .L60
 855 0006 1B78     		ldrb	r3, [r3]
 856 0008 DBB2     		uxtb	r3, r3
1073:.\Generated_Source\PSoC4/UART_1.c ****     }
 857              		.loc 1 1073 0
 858 000a 181C     		mov	r0, r3
 859 000c BD46     		mov	sp, r7
 860              		@ sp needed
 861 000e 80BD     		pop	{r7, pc}
 862              	.L61:
 863              		.align	2
 864              	.L60:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 35


 865 0010 61000F40 		.word	1074724961
 866              		.cfi_endproc
 867              	.LFE18:
 868              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 869              		.section	.text.UART_1_PutChar,"ax",%progbits
 870              		.align	2
 871              		.global	UART_1_PutChar
 872              		.code	16
 873              		.thumb_func
 874              		.type	UART_1_PutChar, %function
 875              	UART_1_PutChar:
 876              	.LFB19:
1074:.\Generated_Source\PSoC4/UART_1.c **** 
1075:.\Generated_Source\PSoC4/UART_1.c **** 
1076:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1077:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutChar
1078:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1079:.\Generated_Source\PSoC4/UART_1.c ****     *
1080:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1081:.\Generated_Source\PSoC4/UART_1.c ****     *  Wait to send byte until TX register or buffer has room.
1082:.\Generated_Source\PSoC4/UART_1.c ****     *
1083:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1084:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: The 8-bit data value to send across the UART.
1085:.\Generated_Source\PSoC4/UART_1.c ****     *
1086:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1087:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1088:.\Generated_Source\PSoC4/UART_1.c ****     *
1089:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1090:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1091:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1092:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1093:.\Generated_Source\PSoC4/UART_1.c ****     *     saved to buffer.
1094:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1095:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer.
1096:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1097:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1098:.\Generated_Source\PSoC4/UART_1.c ****     *
1099:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1100:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1101:.\Generated_Source\PSoC4/UART_1.c ****     *
1102:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1103:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1104:.\Generated_Source\PSoC4/UART_1.c ****     *
1105:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1106:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1107:.\Generated_Source\PSoC4/UART_1.c ****     {
 877              		.loc 1 1107 0
 878              		.cfi_startproc
 879 0000 80B5     		push	{r7, lr}
 880              		.cfi_def_cfa_offset 8
 881              		.cfi_offset 7, -8
 882              		.cfi_offset 14, -4
 883 0002 82B0     		sub	sp, sp, #8
 884              		.cfi_def_cfa_offset 16
 885 0004 00AF     		add	r7, sp, #0
 886              		.cfi_def_cfa_register 7
 887 0006 021C     		mov	r2, r0
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 36


 888 0008 FB1D     		add	r3, r7, #7
 889 000a 1A70     		strb	r2, [r3]
1108:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1109:.\Generated_Source\PSoC4/UART_1.c ****                 /* The temporary output pointer is used since it takes two instructions
1110:.\Generated_Source\PSoC4/UART_1.c ****                 *  to increment with a wrap, and we can't risk doing that with the real
1111:.\Generated_Source\PSoC4/UART_1.c ****                 *  pointer and getting an interrupt in between instructions.
1112:.\Generated_Source\PSoC4/UART_1.c ****                 */
1113:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 loc_txBufferWrite;
1114:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 loc_txBufferRead;
1115:.\Generated_Source\PSoC4/UART_1.c **** 
1116:.\Generated_Source\PSoC4/UART_1.c ****                 do{
1117:.\Generated_Source\PSoC4/UART_1.c ****                     /* Block if software buffer is full, so we don't overwrite. */
1118:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1119:.\Generated_Source\PSoC4/UART_1.c ****                         /* Disable TX interrupt to protect variables that could change on interrupt
1120:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1121:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1122:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferWrite = UART_1_txBufferWrite;
1123:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferRead = UART_1_txBufferRead;
1124:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1125:.\Generated_Source\PSoC4/UART_1.c ****                         /* Enable interrupt to continue transmission */
1126:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1127:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1128:.\Generated_Source\PSoC4/UART_1.c ****                 }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBuffe
1129:.\Generated_Source\PSoC4/UART_1.c ****                                         ((loc_txBufferWrite - loc_txBufferRead) ==
1130:.\Generated_Source\PSoC4/UART_1.c ****                                         (uint8)(UART_1_TXBUFFERSIZE - 1u)) );
1131:.\Generated_Source\PSoC4/UART_1.c **** 
1132:.\Generated_Source\PSoC4/UART_1.c ****                 if( (loc_txBufferRead == loc_txBufferWrite) &&
1133:.\Generated_Source\PSoC4/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1134:.\Generated_Source\PSoC4/UART_1.c ****                 {
1135:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add directly to the FIFO. */
1136:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1137:.\Generated_Source\PSoC4/UART_1.c ****                 }
1138:.\Generated_Source\PSoC4/UART_1.c ****                 else
1139:.\Generated_Source\PSoC4/UART_1.c ****                 {
1140:.\Generated_Source\PSoC4/UART_1.c ****                     if(loc_txBufferWrite >= UART_1_TXBUFFERSIZE)
1141:.\Generated_Source\PSoC4/UART_1.c ****                     {
1142:.\Generated_Source\PSoC4/UART_1.c ****                         loc_txBufferWrite = 0u;
1143:.\Generated_Source\PSoC4/UART_1.c ****                     }
1144:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add to the software buffer. */
1145:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBuffer[loc_txBufferWrite] = txDataByte;
1146:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferWrite++;
1147:.\Generated_Source\PSoC4/UART_1.c **** 
1148:.\Generated_Source\PSoC4/UART_1.c ****                     /* Finally, update the real output pointer */
1149:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1150:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1151:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1152:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite = loc_txBufferWrite;
1153:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1154:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1155:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1156:.\Generated_Source\PSoC4/UART_1.c ****                 }
1157:.\Generated_Source\PSoC4/UART_1.c **** 
1158:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1159:.\Generated_Source\PSoC4/UART_1.c **** 
1160:.\Generated_Source\PSoC4/UART_1.c ****                 while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 890              		.loc 1 1160 0
 891 000c C046     		mov	r8, r8
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 37


 892              	.L63:
 893              		.loc 1 1160 0 is_stmt 0 discriminator 1
 894 000e 074B     		ldr	r3, .L64
 895 0010 1B78     		ldrb	r3, [r3]
 896 0012 DBB2     		uxtb	r3, r3
 897 0014 1A1C     		mov	r2, r3
 898 0016 0423     		mov	r3, #4
 899 0018 1340     		and	r3, r2
 900 001a F8D1     		bne	.L63
1161:.\Generated_Source\PSoC4/UART_1.c ****                 {
1162:.\Generated_Source\PSoC4/UART_1.c ****                     ; /* Wait for room in the FIFO. */
1163:.\Generated_Source\PSoC4/UART_1.c ****                 }
1164:.\Generated_Source\PSoC4/UART_1.c **** 
1165:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
1166:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 901              		.loc 1 1166 0 is_stmt 1
 902 001c 044B     		ldr	r3, .L64+4
 903 001e FA1D     		add	r2, r7, #7
 904 0020 1278     		ldrb	r2, [r2]
 905 0022 1A70     		strb	r2, [r3]
1167:.\Generated_Source\PSoC4/UART_1.c **** 
1168:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1169:.\Generated_Source\PSoC4/UART_1.c ****     }
 906              		.loc 1 1169 0
 907 0024 BD46     		mov	sp, r7
 908 0026 02B0     		add	sp, sp, #8
 909              		@ sp needed
 910 0028 80BD     		pop	{r7, pc}
 911              	.L65:
 912 002a C046     		.align	2
 913              	.L64:
 914 002c 61000F40 		.word	1074724961
 915 0030 41000F40 		.word	1074724929
 916              		.cfi_endproc
 917              	.LFE19:
 918              		.size	UART_1_PutChar, .-UART_1_PutChar
 919              		.section	.text.UART_1_PutString,"ax",%progbits
 920              		.align	2
 921              		.global	UART_1_PutString
 922              		.code	16
 923              		.thumb_func
 924              		.type	UART_1_PutString, %function
 925              	UART_1_PutString:
 926              	.LFB20:
1170:.\Generated_Source\PSoC4/UART_1.c **** 
1171:.\Generated_Source\PSoC4/UART_1.c **** 
1172:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1173:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutString
1174:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1175:.\Generated_Source\PSoC4/UART_1.c ****     *
1176:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1177:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178:.\Generated_Source\PSoC4/UART_1.c ****     *
1179:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1180:.\Generated_Source\PSoC4/UART_1.c ****     *  string: char pointer to character string of Data to Send.
1181:.\Generated_Source\PSoC4/UART_1.c ****     *
1182:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 38


1183:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1184:.\Generated_Source\PSoC4/UART_1.c ****     *
1185:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1186:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1187:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1188:.\Generated_Source\PSoC4/UART_1.c ****     *
1189:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1190:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1191:.\Generated_Source\PSoC4/UART_1.c ****     *
1192:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1193:.\Generated_Source\PSoC4/UART_1.c ****     *  This function will block if there is not enough memory to place the whole
1194:.\Generated_Source\PSoC4/UART_1.c ****     *  string, it will block until the entire string has been written to the
1195:.\Generated_Source\PSoC4/UART_1.c ****     *  transmit buffer.
1196:.\Generated_Source\PSoC4/UART_1.c ****     *
1197:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1198:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1199:.\Generated_Source\PSoC4/UART_1.c ****     {
 927              		.loc 1 1199 0
 928              		.cfi_startproc
 929 0000 80B5     		push	{r7, lr}
 930              		.cfi_def_cfa_offset 8
 931              		.cfi_offset 7, -8
 932              		.cfi_offset 14, -4
 933 0002 84B0     		sub	sp, sp, #16
 934              		.cfi_def_cfa_offset 24
 935 0004 00AF     		add	r7, sp, #0
 936              		.cfi_def_cfa_register 7
 937 0006 7860     		str	r0, [r7, #4]
1200:.\Generated_Source\PSoC4/UART_1.c ****         uint16 buf_index = 0u;
 938              		.loc 1 1200 0
 939 0008 3B1C     		mov	r3, r7
 940 000a 0E33     		add	r3, r3, #14
 941 000c 0022     		mov	r2, #0
 942 000e 1A80     		strh	r2, [r3]
1201:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1202:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 943              		.loc 1 1202 0
 944 0010 0F4B     		ldr	r3, .L70
 945 0012 1B78     		ldrb	r3, [r3]
 946 0014 002B     		cmp	r3, #0
 947 0016 18D0     		beq	.L66
1203:.\Generated_Source\PSoC4/UART_1.c ****         {
1204:.\Generated_Source\PSoC4/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent*/
1205:.\Generated_Source\PSoC4/UART_1.c ****             while(string[buf_index] != (char8)0)
 948              		.loc 1 1205 0
 949 0018 0FE0     		b	.L68
 950              	.L69:
1206:.\Generated_Source\PSoC4/UART_1.c ****             {
1207:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar((uint8)string[buf_index]);
 951              		.loc 1 1207 0
 952 001a 3B1C     		mov	r3, r7
 953 001c 0E33     		add	r3, r3, #14
 954 001e 1B88     		ldrh	r3, [r3]
 955 0020 7A68     		ldr	r2, [r7, #4]
 956 0022 D318     		add	r3, r2, r3
 957 0024 1B78     		ldrb	r3, [r3]
 958 0026 181C     		mov	r0, r3
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 39


 959 0028 FFF7FEFF 		bl	UART_1_PutChar
1208:.\Generated_Source\PSoC4/UART_1.c ****                 buf_index++;
 960              		.loc 1 1208 0
 961 002c 3B1C     		mov	r3, r7
 962 002e 0E33     		add	r3, r3, #14
 963 0030 1A88     		ldrh	r2, [r3]
 964 0032 3B1C     		mov	r3, r7
 965 0034 0E33     		add	r3, r3, #14
 966 0036 0132     		add	r2, r2, #1
 967 0038 1A80     		strh	r2, [r3]
 968              	.L68:
1205:.\Generated_Source\PSoC4/UART_1.c ****             while(string[buf_index] != (char8)0)
 969              		.loc 1 1205 0 discriminator 1
 970 003a 3B1C     		mov	r3, r7
 971 003c 0E33     		add	r3, r3, #14
 972 003e 1B88     		ldrh	r3, [r3]
 973 0040 7A68     		ldr	r2, [r7, #4]
 974 0042 D318     		add	r3, r2, r3
 975 0044 1B78     		ldrb	r3, [r3]
 976 0046 002B     		cmp	r3, #0
 977 0048 E7D1     		bne	.L69
 978              	.L66:
1209:.\Generated_Source\PSoC4/UART_1.c ****             }
1210:.\Generated_Source\PSoC4/UART_1.c ****         }
1211:.\Generated_Source\PSoC4/UART_1.c ****     }
 979              		.loc 1 1211 0
 980 004a BD46     		mov	sp, r7
 981 004c 04B0     		add	sp, sp, #16
 982              		@ sp needed
 983 004e 80BD     		pop	{r7, pc}
 984              	.L71:
 985              		.align	2
 986              	.L70:
 987 0050 00000000 		.word	UART_1_initVar
 988              		.cfi_endproc
 989              	.LFE20:
 990              		.size	UART_1_PutString, .-UART_1_PutString
 991              		.section	.text.UART_1_PutArray,"ax",%progbits
 992              		.align	2
 993              		.global	UART_1_PutArray
 994              		.code	16
 995              		.thumb_func
 996              		.type	UART_1_PutArray, %function
 997              	UART_1_PutArray:
 998              	.LFB21:
1212:.\Generated_Source\PSoC4/UART_1.c **** 
1213:.\Generated_Source\PSoC4/UART_1.c **** 
1214:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1215:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutArray
1216:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1217:.\Generated_Source\PSoC4/UART_1.c ****     *
1218:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1219:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220:.\Generated_Source\PSoC4/UART_1.c ****     *
1221:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1222:.\Generated_Source\PSoC4/UART_1.c ****     *  string: Address of the memory array residing in RAM or ROM.
1223:.\Generated_Source\PSoC4/UART_1.c ****     *  byteCount: Number of Bytes to be transmitted.
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 40


1224:.\Generated_Source\PSoC4/UART_1.c ****     *
1225:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1226:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1227:.\Generated_Source\PSoC4/UART_1.c ****     *
1228:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1229:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1230:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1231:.\Generated_Source\PSoC4/UART_1.c ****     *
1232:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1233:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1234:.\Generated_Source\PSoC4/UART_1.c ****     *
1235:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1236:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1237:.\Generated_Source\PSoC4/UART_1.c ****                                                                     
1238:.\Generated_Source\PSoC4/UART_1.c ****     {
 999              		.loc 1 1238 0
 1000              		.cfi_startproc
 1001 0000 80B5     		push	{r7, lr}
 1002              		.cfi_def_cfa_offset 8
 1003              		.cfi_offset 7, -8
 1004              		.cfi_offset 14, -4
 1005 0002 84B0     		sub	sp, sp, #16
 1006              		.cfi_def_cfa_offset 24
 1007 0004 00AF     		add	r7, sp, #0
 1008              		.cfi_def_cfa_register 7
 1009 0006 7860     		str	r0, [r7, #4]
 1010 0008 0A1C     		mov	r2, r1
 1011 000a FB1C     		add	r3, r7, #3
 1012 000c 1A70     		strb	r2, [r3]
1239:.\Generated_Source\PSoC4/UART_1.c ****         uint8 buf_index = 0u;
 1013              		.loc 1 1239 0
 1014 000e 3B1C     		mov	r3, r7
 1015 0010 0F33     		add	r3, r3, #15
 1016 0012 0022     		mov	r2, #0
 1017 0014 1A70     		strb	r2, [r3]
1240:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1241:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1018              		.loc 1 1241 0
 1019 0016 0F4B     		ldr	r3, .L75
 1020 0018 1B78     		ldrb	r3, [r3]
 1021 001a 002B     		cmp	r3, #0
 1022 001c 16D0     		beq	.L72
 1023              	.L74:
1242:.\Generated_Source\PSoC4/UART_1.c ****         {
1243:.\Generated_Source\PSoC4/UART_1.c ****             do
1244:.\Generated_Source\PSoC4/UART_1.c ****             {
1245:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar(string[buf_index]);
 1024              		.loc 1 1245 0 discriminator 1
 1025 001e 3B1C     		mov	r3, r7
 1026 0020 0F33     		add	r3, r3, #15
 1027 0022 1B78     		ldrb	r3, [r3]
 1028 0024 7A68     		ldr	r2, [r7, #4]
 1029 0026 D318     		add	r3, r2, r3
 1030 0028 1B78     		ldrb	r3, [r3]
 1031 002a 181C     		mov	r0, r3
 1032 002c FFF7FEFF 		bl	UART_1_PutChar
1246:.\Generated_Source\PSoC4/UART_1.c ****                 buf_index++;
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 41


 1033              		.loc 1 1246 0 discriminator 1
 1034 0030 3B1C     		mov	r3, r7
 1035 0032 0F33     		add	r3, r3, #15
 1036 0034 1A78     		ldrb	r2, [r3]
 1037 0036 3B1C     		mov	r3, r7
 1038 0038 0F33     		add	r3, r3, #15
 1039 003a 0132     		add	r2, r2, #1
 1040 003c 1A70     		strb	r2, [r3]
1247:.\Generated_Source\PSoC4/UART_1.c ****             }while(buf_index < byteCount);
 1041              		.loc 1 1247 0 discriminator 1
 1042 003e 3A1C     		mov	r2, r7
 1043 0040 0F32     		add	r2, r2, #15
 1044 0042 FB1C     		add	r3, r7, #3
 1045 0044 1278     		ldrb	r2, [r2]
 1046 0046 1B78     		ldrb	r3, [r3]
 1047 0048 9A42     		cmp	r2, r3
 1048 004a E8D3     		bcc	.L74
 1049              	.L72:
1248:.\Generated_Source\PSoC4/UART_1.c ****         }
1249:.\Generated_Source\PSoC4/UART_1.c ****     }
 1050              		.loc 1 1249 0
 1051 004c BD46     		mov	sp, r7
 1052 004e 04B0     		add	sp, sp, #16
 1053              		@ sp needed
 1054 0050 80BD     		pop	{r7, pc}
 1055              	.L76:
 1056 0052 C046     		.align	2
 1057              	.L75:
 1058 0054 00000000 		.word	UART_1_initVar
 1059              		.cfi_endproc
 1060              	.LFE21:
 1061              		.size	UART_1_PutArray, .-UART_1_PutArray
 1062              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 1063              		.align	2
 1064              		.global	UART_1_PutCRLF
 1065              		.code	16
 1066              		.thumb_func
 1067              		.type	UART_1_PutCRLF, %function
 1068              	UART_1_PutCRLF:
 1069              	.LFB22:
1250:.\Generated_Source\PSoC4/UART_1.c **** 
1251:.\Generated_Source\PSoC4/UART_1.c **** 
1252:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1253:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutCRLF
1254:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1255:.\Generated_Source\PSoC4/UART_1.c ****     *
1256:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1257:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a character and then carriage return and line feed.
1258:.\Generated_Source\PSoC4/UART_1.c ****     *
1259:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1260:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: uint8 Character to send.
1261:.\Generated_Source\PSoC4/UART_1.c ****     *
1262:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1263:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1264:.\Generated_Source\PSoC4/UART_1.c ****     *
1265:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1266:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 42


1267:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1268:.\Generated_Source\PSoC4/UART_1.c ****     *
1269:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1270:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1271:.\Generated_Source\PSoC4/UART_1.c ****     *
1272:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1274:.\Generated_Source\PSoC4/UART_1.c ****     {
 1070              		.loc 1 1274 0
 1071              		.cfi_startproc
 1072 0000 80B5     		push	{r7, lr}
 1073              		.cfi_def_cfa_offset 8
 1074              		.cfi_offset 7, -8
 1075              		.cfi_offset 14, -4
 1076 0002 82B0     		sub	sp, sp, #8
 1077              		.cfi_def_cfa_offset 16
 1078 0004 00AF     		add	r7, sp, #0
 1079              		.cfi_def_cfa_register 7
 1080 0006 021C     		mov	r2, r0
 1081 0008 FB1D     		add	r3, r7, #7
 1082 000a 1A70     		strb	r2, [r3]
1275:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1276:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1083              		.loc 1 1276 0
 1084 000c 084B     		ldr	r3, .L79
 1085 000e 1B78     		ldrb	r3, [r3]
 1086 0010 002B     		cmp	r3, #0
 1087 0012 0AD0     		beq	.L77
1277:.\Generated_Source\PSoC4/UART_1.c ****         {
1278:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(txDataByte);
 1088              		.loc 1 1278 0
 1089 0014 FB1D     		add	r3, r7, #7
 1090 0016 1B78     		ldrb	r3, [r3]
 1091 0018 181C     		mov	r0, r3
 1092 001a FFF7FEFF 		bl	UART_1_PutChar
1279:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Du);
 1093              		.loc 1 1279 0
 1094 001e 0D20     		mov	r0, #13
 1095 0020 FFF7FEFF 		bl	UART_1_PutChar
1280:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Au);
 1096              		.loc 1 1280 0
 1097 0024 0A20     		mov	r0, #10
 1098 0026 FFF7FEFF 		bl	UART_1_PutChar
 1099              	.L77:
1281:.\Generated_Source\PSoC4/UART_1.c ****         }
1282:.\Generated_Source\PSoC4/UART_1.c ****     }
 1100              		.loc 1 1282 0
 1101 002a BD46     		mov	sp, r7
 1102 002c 02B0     		add	sp, sp, #8
 1103              		@ sp needed
 1104 002e 80BD     		pop	{r7, pc}
 1105              	.L80:
 1106              		.align	2
 1107              	.L79:
 1108 0030 00000000 		.word	UART_1_initVar
 1109              		.cfi_endproc
 1110              	.LFE22:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 43


 1111              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 1112              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 1113              		.align	2
 1114              		.global	UART_1_GetTxBufferSize
 1115              		.code	16
 1116              		.thumb_func
 1117              		.type	UART_1_GetTxBufferSize, %function
 1118              	UART_1_GetTxBufferSize:
 1119              	.LFB23:
1283:.\Generated_Source\PSoC4/UART_1.c **** 
1284:.\Generated_Source\PSoC4/UART_1.c **** 
1285:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1286:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1287:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1288:.\Generated_Source\PSoC4/UART_1.c ****     *
1289:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1290:.\Generated_Source\PSoC4/UART_1.c ****     *  Determine the amount of space left in the TX buffer and return the count in
1291:.\Generated_Source\PSoC4/UART_1.c ****     *  bytes
1292:.\Generated_Source\PSoC4/UART_1.c ****     *
1293:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1294:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1295:.\Generated_Source\PSoC4/UART_1.c ****     *
1296:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1297:.\Generated_Source\PSoC4/UART_1.c ****     *  Integer count of the number of bytes left in the TX buffer
1298:.\Generated_Source\PSoC4/UART_1.c ****     *
1299:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1300:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1301:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1302:.\Generated_Source\PSoC4/UART_1.c ****     *
1303:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1304:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1305:.\Generated_Source\PSoC4/UART_1.c ****     *
1306:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1307:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1308:.\Generated_Source\PSoC4/UART_1.c ****     *
1309:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1310:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1311:.\Generated_Source\PSoC4/UART_1.c ****                                                             
1312:.\Generated_Source\PSoC4/UART_1.c ****     {
 1120              		.loc 1 1312 0
 1121              		.cfi_startproc
 1122 0000 80B5     		push	{r7, lr}
 1123              		.cfi_def_cfa_offset 8
 1124              		.cfi_offset 7, -8
 1125              		.cfi_offset 14, -4
 1126 0002 82B0     		sub	sp, sp, #8
 1127              		.cfi_def_cfa_offset 16
 1128 0004 00AF     		add	r7, sp, #0
 1129              		.cfi_def_cfa_register 7
1313:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
1314:.\Generated_Source\PSoC4/UART_1.c **** 
1315:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1316:.\Generated_Source\PSoC4/UART_1.c **** 
1317:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Tx interrupt. */
1318:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
1319:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1320:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableTxInt();
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 44


1321:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1322:.\Generated_Source\PSoC4/UART_1.c **** 
1323:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_txBufferRead == UART_1_txBufferWrite)
1324:.\Generated_Source\PSoC4/UART_1.c ****             {
1325:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
1326:.\Generated_Source\PSoC4/UART_1.c ****             }
1327:.\Generated_Source\PSoC4/UART_1.c ****             else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1328:.\Generated_Source\PSoC4/UART_1.c ****             {
1329:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1330:.\Generated_Source\PSoC4/UART_1.c ****             }
1331:.\Generated_Source\PSoC4/UART_1.c ****             else
1332:.\Generated_Source\PSoC4/UART_1.c ****             {
1333:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_TXBUFFERSIZE - UART_1_txBufferRead) + UART_1_txBufferWrite;
1334:.\Generated_Source\PSoC4/UART_1.c ****             }
1335:.\Generated_Source\PSoC4/UART_1.c **** 
1336:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Tx interrupt. */
1337:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1338:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableTxInt();
1339:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1340:.\Generated_Source\PSoC4/UART_1.c **** 
1341:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1342:.\Generated_Source\PSoC4/UART_1.c **** 
1343:.\Generated_Source\PSoC4/UART_1.c ****             size = UART_1_TXSTATUS_REG;
 1130              		.loc 1 1343 0
 1131 0006 0F4A     		ldr	r2, .L86
 1132 0008 FB1D     		add	r3, r7, #7
 1133 000a 1278     		ldrb	r2, [r2]
 1134 000c 1A70     		strb	r2, [r3]
1344:.\Generated_Source\PSoC4/UART_1.c **** 
1345:.\Generated_Source\PSoC4/UART_1.c ****             /* Is the fifo is full. */
1346:.\Generated_Source\PSoC4/UART_1.c ****             if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 1135              		.loc 1 1346 0
 1136 000e FB1D     		add	r3, r7, #7
 1137 0010 1A78     		ldrb	r2, [r3]
 1138 0012 0423     		mov	r3, #4
 1139 0014 1340     		and	r3, r2
 1140 0016 03D0     		beq	.L82
1347:.\Generated_Source\PSoC4/UART_1.c ****             {
1348:.\Generated_Source\PSoC4/UART_1.c ****                 size = UART_1_FIFO_LENGTH;
 1141              		.loc 1 1348 0
 1142 0018 FB1D     		add	r3, r7, #7
 1143 001a 0422     		mov	r2, #4
 1144 001c 1A70     		strb	r2, [r3]
 1145 001e 0BE0     		b	.L83
 1146              	.L82:
1349:.\Generated_Source\PSoC4/UART_1.c ****             }
1350:.\Generated_Source\PSoC4/UART_1.c ****             else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 1147              		.loc 1 1350 0
 1148 0020 FB1D     		add	r3, r7, #7
 1149 0022 1A78     		ldrb	r2, [r3]
 1150 0024 0223     		mov	r3, #2
 1151 0026 1340     		and	r3, r2
 1152 0028 03D0     		beq	.L84
1351:.\Generated_Source\PSoC4/UART_1.c ****             {
1352:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
 1153              		.loc 1 1352 0
 1154 002a FB1D     		add	r3, r7, #7
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 45


 1155 002c 0022     		mov	r2, #0
 1156 002e 1A70     		strb	r2, [r3]
 1157 0030 02E0     		b	.L83
 1158              	.L84:
1353:.\Generated_Source\PSoC4/UART_1.c ****             }
1354:.\Generated_Source\PSoC4/UART_1.c ****             else
1355:.\Generated_Source\PSoC4/UART_1.c ****             {
1356:.\Generated_Source\PSoC4/UART_1.c ****                 /* We only know there is data in the fifo. */
1357:.\Generated_Source\PSoC4/UART_1.c ****                 size = 1u;
 1159              		.loc 1 1357 0
 1160 0032 FB1D     		add	r3, r7, #7
 1161 0034 0122     		mov	r2, #1
 1162 0036 1A70     		strb	r2, [r3]
 1163              	.L83:
1358:.\Generated_Source\PSoC4/UART_1.c ****             }
1359:.\Generated_Source\PSoC4/UART_1.c **** 
1360:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1361:.\Generated_Source\PSoC4/UART_1.c **** 
1362:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 1164              		.loc 1 1362 0
 1165 0038 FB1D     		add	r3, r7, #7
 1166 003a 1B78     		ldrb	r3, [r3]
1363:.\Generated_Source\PSoC4/UART_1.c ****     }
 1167              		.loc 1 1363 0
 1168 003c 181C     		mov	r0, r3
 1169 003e BD46     		mov	sp, r7
 1170 0040 02B0     		add	sp, sp, #8
 1171              		@ sp needed
 1172 0042 80BD     		pop	{r7, pc}
 1173              	.L87:
 1174              		.align	2
 1175              	.L86:
 1176 0044 61000F40 		.word	1074724961
 1177              		.cfi_endproc
 1178              	.LFE23:
 1179              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 1180              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 1181              		.align	2
 1182              		.global	UART_1_ClearTxBuffer
 1183              		.code	16
 1184              		.thumb_func
 1185              		.type	UART_1_ClearTxBuffer, %function
 1186              	UART_1_ClearTxBuffer:
 1187              	.LFB24:
1364:.\Generated_Source\PSoC4/UART_1.c **** 
1365:.\Generated_Source\PSoC4/UART_1.c **** 
1366:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1367:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1368:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1369:.\Generated_Source\PSoC4/UART_1.c ****     *
1370:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1371:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373:.\Generated_Source\PSoC4/UART_1.c ****     *
1374:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1375:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1376:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 46


1377:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1378:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1379:.\Generated_Source\PSoC4/UART_1.c ****     *
1380:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1381:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1382:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1383:.\Generated_Source\PSoC4/UART_1.c ****     *
1384:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1385:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1386:.\Generated_Source\PSoC4/UART_1.c ****     *
1387:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1388:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1389:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1390:.\Generated_Source\PSoC4/UART_1.c ****     *  remained in the RAM.
1391:.\Generated_Source\PSoC4/UART_1.c ****     *
1392:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1393:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM buffer will be lost when overwritten.
1394:.\Generated_Source\PSoC4/UART_1.c ****     *
1395:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1396:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1397:.\Generated_Source\PSoC4/UART_1.c ****     {
 1188              		.loc 1 1397 0
 1189              		.cfi_startproc
 1190 0000 90B5     		push	{r4, r7, lr}
 1191              		.cfi_def_cfa_offset 12
 1192              		.cfi_offset 4, -12
 1193              		.cfi_offset 7, -8
 1194              		.cfi_offset 14, -4
 1195 0002 83B0     		sub	sp, sp, #12
 1196              		.cfi_def_cfa_offset 24
 1197 0004 00AF     		add	r7, sp, #0
 1198              		.cfi_def_cfa_register 7
1398:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
1399:.\Generated_Source\PSoC4/UART_1.c **** 
1400:.\Generated_Source\PSoC4/UART_1.c ****         /* Enter critical section */
1401:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 1199              		.loc 1 1401 0
 1200 0006 FC1D     		add	r4, r7, #7
 1201 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 1202 000c 031C     		mov	r3, r0
 1203 000e 2370     		strb	r3, [r4]
1402:.\Generated_Source\PSoC4/UART_1.c ****         /* clear the HW FIFO */
1403:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |=  UART_1_TX_FIFO_CLR;
 1204              		.loc 1 1403 0
 1205 0010 0B4B     		ldr	r3, .L89
 1206 0012 0B4A     		ldr	r2, .L89
 1207 0014 1278     		ldrb	r2, [r2]
 1208 0016 D2B2     		uxtb	r2, r2
 1209 0018 0121     		mov	r1, #1
 1210 001a 0A43     		orr	r2, r1
 1211 001c D2B2     		uxtb	r2, r2
 1212 001e 1A70     		strb	r2, [r3]
1404:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8)~UART_1_TX_FIFO_CLR;
 1213              		.loc 1 1404 0
 1214 0020 074B     		ldr	r3, .L89
 1215 0022 074A     		ldr	r2, .L89
 1216 0024 1278     		ldrb	r2, [r2]
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 47


 1217 0026 D2B2     		uxtb	r2, r2
 1218 0028 0121     		mov	r1, #1
 1219 002a 8A43     		bic	r2, r1
 1220 002c D2B2     		uxtb	r2, r2
 1221 002e 1A70     		strb	r2, [r3]
1405:.\Generated_Source\PSoC4/UART_1.c ****         /* Exit critical section */
1406:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 1222              		.loc 1 1406 0
 1223 0030 FB1D     		add	r3, r7, #7
 1224 0032 1B78     		ldrb	r3, [r3]
 1225 0034 181C     		mov	r0, r3
 1226 0036 FFF7FEFF 		bl	CyExitCriticalSection
1407:.\Generated_Source\PSoC4/UART_1.c **** 
1408:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1409:.\Generated_Source\PSoC4/UART_1.c **** 
1410:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Tx interrupt. */
1411:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
1412:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1413:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableTxInt();
1414:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1415:.\Generated_Source\PSoC4/UART_1.c **** 
1416:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferRead = 0u;
1417:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferWrite = 0u;
1418:.\Generated_Source\PSoC4/UART_1.c **** 
1419:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Tx interrupt. */
1420:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1421:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableTxInt();
1422:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1423:.\Generated_Source\PSoC4/UART_1.c **** 
1424:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1425:.\Generated_Source\PSoC4/UART_1.c ****     }
 1227              		.loc 1 1425 0
 1228 003a BD46     		mov	sp, r7
 1229 003c 03B0     		add	sp, sp, #12
 1230              		@ sp needed
 1231 003e 90BD     		pop	{r4, r7, pc}
 1232              	.L90:
 1233              		.align	2
 1234              	.L89:
 1235 0040 91000F40 		.word	1074725009
 1236              		.cfi_endproc
 1237              	.LFE24:
 1238              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 1239              		.section	.text.UART_1_SendBreak,"ax",%progbits
 1240              		.align	2
 1241              		.global	UART_1_SendBreak
 1242              		.code	16
 1243              		.thumb_func
 1244              		.type	UART_1_SendBreak, %function
 1245              	UART_1_SendBreak:
 1246              	.LFB25:
1426:.\Generated_Source\PSoC4/UART_1.c **** 
1427:.\Generated_Source\PSoC4/UART_1.c **** 
1428:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1429:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SendBreak
1430:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1431:.\Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 48


1432:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1433:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Break command to the UART
1434:.\Generated_Source\PSoC4/UART_1.c ****     *
1435:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1436:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8 retMode:  Wait mode,
1437:.\Generated_Source\PSoC4/UART_1.c ****     *   0 - Initialize registers for Break, sends the Break signal and return
1438:.\Generated_Source\PSoC4/UART_1.c ****     *       imediately.
1439:.\Generated_Source\PSoC4/UART_1.c ****     *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440:.\Generated_Source\PSoC4/UART_1.c ****     *       transmission mode then return.
1441:.\Generated_Source\PSoC4/UART_1.c ****     *   2 - Reinitialize registers to normal transmission mode then return.
1442:.\Generated_Source\PSoC4/UART_1.c ****     *   3 - both steps: 0 and 1
1443:.\Generated_Source\PSoC4/UART_1.c ****     *       init registers for Break, send Break signal
1444:.\Generated_Source\PSoC4/UART_1.c ****     *       wait until Break sending is complete, reinit registers to normal
1445:.\Generated_Source\PSoC4/UART_1.c ****     *       transmission mode then return.
1446:.\Generated_Source\PSoC4/UART_1.c ****     *
1447:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1448:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1449:.\Generated_Source\PSoC4/UART_1.c ****     *
1450:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1451:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1452:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1453:.\Generated_Source\PSoC4/UART_1.c ****     *  tx_period - static variable, used for keeping TX period configuration.
1454:.\Generated_Source\PSoC4/UART_1.c ****     *
1455:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1456:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1457:.\Generated_Source\PSoC4/UART_1.c ****     *
1458:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1459:.\Generated_Source\PSoC4/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1460:.\Generated_Source\PSoC4/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1461:.\Generated_Source\PSoC4/UART_1.c ****     *  operation.
1462:.\Generated_Source\PSoC4/UART_1.c ****     *  Trere are 3 variants for this API usage:
1463:.\Generated_Source\PSoC4/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1464:.\Generated_Source\PSoC4/UART_1.c ****     *     configuration returning. Funcition will block CPU untill transmition
1465:.\Generated_Source\PSoC4/UART_1.c ****     *     complete.
1466:.\Generated_Source\PSoC4/UART_1.c ****     *  2) User may want to use bloking time if UART configured to the low speed
1467:.\Generated_Source\PSoC4/UART_1.c ****     *     operation
1468:.\Generated_Source\PSoC4/UART_1.c ****     *     Emample for this case:
1469:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1470:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1471:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1472:.\Generated_Source\PSoC4/UART_1.c ****     *  3) Same to 2) but user may want to init and use the interrupt for complete
1473:.\Generated_Source\PSoC4/UART_1.c ****     *     break operation.
1474:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1475:.\Generated_Source\PSoC4/UART_1.c ****     *     Init TX interrupt whith "TX - On TX Complete" parameter
1476:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1477:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1478:.\Generated_Source\PSoC4/UART_1.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1479:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1480:.\Generated_Source\PSoC4/UART_1.c ****     *
1481:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1482:.\Generated_Source\PSoC4/UART_1.c ****     *   Uses static variable to keep registers configuration.
1483:.\Generated_Source\PSoC4/UART_1.c ****     *
1484:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1485:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1486:.\Generated_Source\PSoC4/UART_1.c ****     {
 1247              		.loc 1 1486 0
 1248              		.cfi_startproc
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 49


 1249 0000 80B5     		push	{r7, lr}
 1250              		.cfi_def_cfa_offset 8
 1251              		.cfi_offset 7, -8
 1252              		.cfi_offset 14, -4
 1253 0002 84B0     		sub	sp, sp, #16
 1254              		.cfi_def_cfa_offset 24
 1255 0004 00AF     		add	r7, sp, #0
 1256              		.cfi_def_cfa_register 7
 1257 0006 021C     		mov	r2, r0
 1258 0008 FB1D     		add	r3, r7, #7
 1259 000a 1A70     		strb	r2, [r3]
1487:.\Generated_Source\PSoC4/UART_1.c **** 
1488:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1489:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1260              		.loc 1 1489 0
 1261 000c 254B     		ldr	r3, .L99
 1262 000e 1B78     		ldrb	r3, [r3]
 1263 0010 002B     		cmp	r3, #0
 1264 0012 43D0     		beq	.L91
 1265              	.LBB2:
1490:.\Generated_Source\PSoC4/UART_1.c ****         {
1491:.\Generated_Source\PSoC4/UART_1.c ****             /*Set the Counter to 13-bits and transmit a 00 byte*/
1492:.\Generated_Source\PSoC4/UART_1.c ****             /*When that is done then reset the counter value back*/
1493:.\Generated_Source\PSoC4/UART_1.c ****             uint8 tmpStat;
1494:.\Generated_Source\PSoC4/UART_1.c **** 
1495:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1496:.\Generated_Source\PSoC4/UART_1.c **** 
1497:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
1498:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT ) )
1499:.\Generated_Source\PSoC4/UART_1.c ****                 {
1500:.\Generated_Source\PSoC4/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
1501:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1502:.\Generated_Source\PSoC4/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1503:.\Generated_Source\PSoC4/UART_1.c ****                     /* Send zeros*/
1504:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
1505:.\Generated_Source\PSoC4/UART_1.c **** 
1506:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit starts*/
1507:.\Generated_Source\PSoC4/UART_1.c ****                     {
1508:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1509:.\Generated_Source\PSoC4/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1510:.\Generated_Source\PSoC4/UART_1.c ****                 }
1511:.\Generated_Source\PSoC4/UART_1.c **** 
1512:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1513:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1514:.\Generated_Source\PSoC4/UART_1.c ****                 {
1515:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit complete*/
1516:.\Generated_Source\PSoC4/UART_1.c ****                     {
1517:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1518:.\Generated_Source\PSoC4/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1519:.\Generated_Source\PSoC4/UART_1.c ****                 }
1520:.\Generated_Source\PSoC4/UART_1.c **** 
1521:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1522:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_REINIT) ||
1523:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1524:.\Generated_Source\PSoC4/UART_1.c ****                 {
1525:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1526:.\Generated_Source\PSoC4/UART_1.c ****                                                   (uint8)~UART_1_CTRL_HD_SEND_BREAK);
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 50


1527:.\Generated_Source\PSoC4/UART_1.c ****                 }
1528:.\Generated_Source\PSoC4/UART_1.c **** 
1529:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_HD_ENABLED Full Duplex mode */
1530:.\Generated_Source\PSoC4/UART_1.c **** 
1531:.\Generated_Source\PSoC4/UART_1.c ****                 static uint8 tx_period;
1532:.\Generated_Source\PSoC4/UART_1.c **** 
1533:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
 1266              		.loc 1 1533 0
 1267 0014 FB1D     		add	r3, r7, #7
 1268 0016 1B78     		ldrb	r3, [r3]
 1269 0018 002B     		cmp	r3, #0
 1270 001a 03D0     		beq	.L93
 1271              		.loc 1 1533 0 is_stmt 0 discriminator 1
 1272 001c FB1D     		add	r3, r7, #7
 1273 001e 1B78     		ldrb	r3, [r3]
 1274 0020 032B     		cmp	r3, #3
 1275 0022 15D1     		bne	.L94
 1276              	.L93:
1534:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1535:.\Generated_Source\PSoC4/UART_1.c ****                 {
1536:.\Generated_Source\PSoC4/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex 
1537:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1538:.\Generated_Source\PSoC4/UART_1.c ****                                         (UART_1_PARITY_TYPE_SW != 0u) )
1539:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1540:.\Generated_Source\PSoC4/UART_1.c ****                                                               UART_1_CTRL_HD_SEND_BREAK);
1541:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1542:.\Generated_Source\PSoC4/UART_1.c **** 
1543:.\Generated_Source\PSoC4/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1544:.\Generated_Source\PSoC4/UART_1.c ****                         tx_period = UART_1_TXBITCLKTX_COMPLETE_REG;
 1277              		.loc 1 1544 0 is_stmt 1
 1278 0024 204B     		ldr	r3, .L99+4
 1279 0026 1B78     		ldrb	r3, [r3]
 1280 0028 DAB2     		uxtb	r2, r3
 1281 002a 204B     		ldr	r3, .L99+8
 1282 002c 1A70     		strb	r2, [r3]
1545:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 1283              		.loc 1 1545 0
 1284 002e 1E4B     		ldr	r3, .L99+4
 1285 0030 6722     		mov	r2, #103
 1286 0032 1A70     		strb	r2, [r3]
1546:.\Generated_Source\PSoC4/UART_1.c ****                     #else
1547:.\Generated_Source\PSoC4/UART_1.c ****                         tx_period = UART_1_TXBITCTR_PERIOD_REG;
1548:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1549:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1550:.\Generated_Source\PSoC4/UART_1.c **** 
1551:.\Generated_Source\PSoC4/UART_1.c ****                     /* Send zeros*/
1552:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
 1287              		.loc 1 1552 0
 1288 0034 1E4B     		ldr	r3, .L99+12
 1289 0036 0022     		mov	r2, #0
 1290 0038 1A70     		strb	r2, [r3]
 1291              	.L95:
1553:.\Generated_Source\PSoC4/UART_1.c **** 
1554:.\Generated_Source\PSoC4/UART_1.c ****                     do /* wait until transmit starts */
1555:.\Generated_Source\PSoC4/UART_1.c ****                     {
1556:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 1292              		.loc 1 1556 0 discriminator 1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 51


 1293 003a 1E4A     		ldr	r2, .L99+16
 1294 003c 3B1C     		mov	r3, r7
 1295 003e 0F33     		add	r3, r3, #15
 1296 0040 1278     		ldrb	r2, [r2]
 1297 0042 1A70     		strb	r2, [r3]
1557:.\Generated_Source\PSoC4/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 1298              		.loc 1 1557 0 discriminator 1
 1299 0044 3B1C     		mov	r3, r7
 1300 0046 0F33     		add	r3, r3, #15
 1301 0048 1A78     		ldrb	r2, [r3]
 1302 004a 0223     		mov	r3, #2
 1303 004c 1340     		and	r3, r2
 1304 004e F4D1     		bne	.L95
 1305              	.L94:
1558:.\Generated_Source\PSoC4/UART_1.c ****                 }
1559:.\Generated_Source\PSoC4/UART_1.c **** 
1560:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1306              		.loc 1 1560 0
 1307 0050 FB1D     		add	r3, r7, #7
 1308 0052 1B78     		ldrb	r3, [r3]
 1309 0054 012B     		cmp	r3, #1
 1310 0056 03D0     		beq	.L96
 1311              		.loc 1 1560 0 is_stmt 0 discriminator 1
 1312 0058 FB1D     		add	r3, r7, #7
 1313 005a 1B78     		ldrb	r3, [r3]
 1314 005c 032B     		cmp	r3, #3
 1315 005e 0DD1     		bne	.L97
 1316              	.L96:
1561:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1562:.\Generated_Source\PSoC4/UART_1.c ****                 {
1563:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit complete*/
1564:.\Generated_Source\PSoC4/UART_1.c ****                     {
1565:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 1317              		.loc 1 1565 0 is_stmt 1 discriminator 1
 1318 0060 144A     		ldr	r2, .L99+16
 1319 0062 3B1C     		mov	r3, r7
 1320 0064 0F33     		add	r3, r3, #15
 1321 0066 1278     		ldrb	r2, [r2]
 1322 0068 1A70     		strb	r2, [r3]
1566:.\Generated_Source\PSoC4/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 1323              		.loc 1 1566 0 discriminator 1
 1324 006a 3B1C     		mov	r3, r7
 1325 006c 0F33     		add	r3, r3, #15
 1326 006e 1B78     		ldrb	r3, [r3]
 1327 0070 DB43     		mvn	r3, r3
 1328 0072 DBB2     		uxtb	r3, r3
 1329 0074 1A1C     		mov	r2, r3
 1330 0076 0123     		mov	r3, #1
 1331 0078 1340     		and	r3, r2
 1332 007a F1D1     		bne	.L96
 1333              	.L97:
1567:.\Generated_Source\PSoC4/UART_1.c ****                 }
1568:.\Generated_Source\PSoC4/UART_1.c **** 
1569:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1334              		.loc 1 1569 0
 1335 007c FB1D     		add	r3, r7, #7
 1336 007e 1B78     		ldrb	r3, [r3]
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 52


 1337 0080 012B     		cmp	r3, #1
 1338 0082 07D0     		beq	.L98
 1339              		.loc 1 1569 0 is_stmt 0 discriminator 1
 1340 0084 FB1D     		add	r3, r7, #7
 1341 0086 1B78     		ldrb	r3, [r3]
 1342 0088 022B     		cmp	r3, #2
 1343 008a 03D0     		beq	.L98
1570:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_REINIT) ||
 1344              		.loc 1 1570 0 is_stmt 1
 1345 008c FB1D     		add	r3, r7, #7
 1346 008e 1B78     		ldrb	r3, [r3]
 1347 0090 032B     		cmp	r3, #3
 1348 0092 03D1     		bne	.L91
 1349              	.L98:
1571:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1572:.\Generated_Source\PSoC4/UART_1.c ****                 {
1573:.\Generated_Source\PSoC4/UART_1.c **** 
1574:.\Generated_Source\PSoC4/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1575:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = tx_period;
 1350              		.loc 1 1575 0
 1351 0094 044B     		ldr	r3, .L99+4
 1352 0096 054A     		ldr	r2, .L99+8
 1353 0098 1278     		ldrb	r2, [r2]
 1354 009a 1A70     		strb	r2, [r3]
 1355              	.L91:
 1356              	.LBE2:
1576:.\Generated_Source\PSoC4/UART_1.c ****                     #else
1577:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = tx_period;
1578:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1579:.\Generated_Source\PSoC4/UART_1.c **** 
1580:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1581:.\Generated_Source\PSoC4/UART_1.c ****                          (UART_1_PARITY_TYPE_SW != 0u) )
1582:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1583:.\Generated_Source\PSoC4/UART_1.c ****                                                       (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1584:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != NONE */
1585:.\Generated_Source\PSoC4/UART_1.c ****                 }
1586:.\Generated_Source\PSoC4/UART_1.c ****             #endif    /* End UART_1_HD_ENABLED */
1587:.\Generated_Source\PSoC4/UART_1.c ****         }
1588:.\Generated_Source\PSoC4/UART_1.c ****     }
 1357              		.loc 1 1588 0
 1358 009c BD46     		mov	sp, r7
 1359 009e 04B0     		add	sp, sp, #16
 1360              		@ sp needed
 1361 00a0 80BD     		pop	{r7, pc}
 1362              	.L100:
 1363 00a2 C046     		.align	2
 1364              	.L99:
 1365 00a4 00000000 		.word	UART_1_initVar
 1366 00a8 30000F40 		.word	1074724912
 1367 00ac 01000000 		.word	tx_period.4828
 1368 00b0 41000F40 		.word	1074724929
 1369 00b4 61000F40 		.word	1074724961
 1370              		.cfi_endproc
 1371              	.LFE25:
 1372              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 1373              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 1374              		.align	2
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 53


 1375              		.global	UART_1_SetTxAddressMode
 1376              		.code	16
 1377              		.thumb_func
 1378              		.type	UART_1_SetTxAddressMode, %function
 1379              	UART_1_SetTxAddressMode:
 1380              	.LFB26:
1589:.\Generated_Source\PSoC4/UART_1.c **** 
1590:.\Generated_Source\PSoC4/UART_1.c **** 
1591:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1592:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1593:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1594:.\Generated_Source\PSoC4/UART_1.c ****     *
1595:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1596:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the transmit addressing mode
1597:.\Generated_Source\PSoC4/UART_1.c ****     *
1598:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1599:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: 0 -> Space
1600:.\Generated_Source\PSoC4/UART_1.c ****     *               1 -> Mark
1601:.\Generated_Source\PSoC4/UART_1.c ****     *
1602:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1603:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1604:.\Generated_Source\PSoC4/UART_1.c ****     *
1605:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1606:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1607:.\Generated_Source\PSoC4/UART_1.c ****     {
 1381              		.loc 1 1607 0
 1382              		.cfi_startproc
 1383 0000 80B5     		push	{r7, lr}
 1384              		.cfi_def_cfa_offset 8
 1385              		.cfi_offset 7, -8
 1386              		.cfi_offset 14, -4
 1387 0002 82B0     		sub	sp, sp, #8
 1388              		.cfi_def_cfa_offset 16
 1389 0004 00AF     		add	r7, sp, #0
 1390              		.cfi_def_cfa_register 7
 1391 0006 021C     		mov	r2, r0
 1392 0008 FB1D     		add	r3, r7, #7
 1393 000a 1A70     		strb	r2, [r3]
1608:.\Generated_Source\PSoC4/UART_1.c ****         /* Mark/Space sending enable*/
1609:.\Generated_Source\PSoC4/UART_1.c ****         if(addressMode != 0u)
1610:.\Generated_Source\PSoC4/UART_1.c ****         {
1611:.\Generated_Source\PSoC4/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1612:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1613:.\Generated_Source\PSoC4/UART_1.c ****                                                       UART_1_CTRL_MARK);
1614:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1615:.\Generated_Source\PSoC4/UART_1.c ****         }
1616:.\Generated_Source\PSoC4/UART_1.c ****         else
1617:.\Generated_Source\PSoC4/UART_1.c ****         {
1618:.\Generated_Source\PSoC4/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1619:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1620:.\Generated_Source\PSoC4/UART_1.c ****                                                     (uint8)~UART_1_CTRL_MARK);
1621:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1622:.\Generated_Source\PSoC4/UART_1.c ****         }
1623:.\Generated_Source\PSoC4/UART_1.c ****     }
 1394              		.loc 1 1623 0
 1395 000c BD46     		mov	sp, r7
 1396 000e 02B0     		add	sp, sp, #8
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 54


 1397              		@ sp needed
 1398 0010 80BD     		pop	{r7, pc}
 1399              		.cfi_endproc
 1400              	.LFE26:
 1401              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 1402 0012 C046     		.bss
 1403              	tx_period.4828:
 1404 0001 00       		.space	1
 1405              		.text
 1406              	.Letext0:
 1407              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 1408              		.section	.debug_info,"",%progbits
 1409              	.Ldebug_info0:
 1410 0000 FC040000 		.4byte	0x4fc
 1411 0004 0400     		.2byte	0x4
 1412 0006 00000000 		.4byte	.Ldebug_abbrev0
 1413 000a 04       		.byte	0x4
 1414 000b 01       		.uleb128 0x1
 1415 000c BF020000 		.4byte	.LASF60
 1416 0010 01       		.byte	0x1
 1417 0011 E6000000 		.4byte	.LASF61
 1418 0015 1F020000 		.4byte	.LASF62
 1419 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1420 001d 00000000 		.4byte	0
 1421 0021 00000000 		.4byte	.Ldebug_line0
 1422 0025 02       		.uleb128 0x2
 1423 0026 01       		.byte	0x1
 1424 0027 06       		.byte	0x6
 1425 0028 9C000000 		.4byte	.LASF0
 1426 002c 02       		.uleb128 0x2
 1427 002d 01       		.byte	0x1
 1428 002e 08       		.byte	0x8
 1429 002f 6D030000 		.4byte	.LASF1
 1430 0033 02       		.uleb128 0x2
 1431 0034 02       		.byte	0x2
 1432 0035 05       		.byte	0x5
 1433 0036 7B030000 		.4byte	.LASF2
 1434 003a 02       		.uleb128 0x2
 1435 003b 02       		.byte	0x2
 1436 003c 07       		.byte	0x7
 1437 003d 6A010000 		.4byte	.LASF3
 1438 0041 02       		.uleb128 0x2
 1439 0042 04       		.byte	0x4
 1440 0043 05       		.byte	0x5
 1441 0044 B7000000 		.4byte	.LASF4
 1442 0048 02       		.uleb128 0x2
 1443 0049 04       		.byte	0x4
 1444 004a 07       		.byte	0x7
 1445 004b 53010000 		.4byte	.LASF5
 1446 004f 02       		.uleb128 0x2
 1447 0050 08       		.byte	0x8
 1448 0051 05       		.byte	0x5
 1449 0052 8E000000 		.4byte	.LASF6
 1450 0056 02       		.uleb128 0x2
 1451 0057 08       		.byte	0x8
 1452 0058 07       		.byte	0x7
 1453 0059 60000000 		.4byte	.LASF7
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 55


 1454 005d 03       		.uleb128 0x3
 1455 005e 04       		.byte	0x4
 1456 005f 05       		.byte	0x5
 1457 0060 696E7400 		.ascii	"int\000"
 1458 0064 02       		.uleb128 0x2
 1459 0065 04       		.byte	0x4
 1460 0066 07       		.byte	0x7
 1461 0067 32010000 		.4byte	.LASF8
 1462 006b 04       		.uleb128 0x4
 1463 006c CD000000 		.4byte	.LASF9
 1464 0070 02       		.byte	0x2
 1465 0071 A1       		.byte	0xa1
 1466 0072 2C000000 		.4byte	0x2c
 1467 0076 04       		.uleb128 0x4
 1468 0077 00000000 		.4byte	.LASF10
 1469 007b 02       		.byte	0x2
 1470 007c A2       		.byte	0xa2
 1471 007d 3A000000 		.4byte	0x3a
 1472 0081 02       		.uleb128 0x2
 1473 0082 04       		.byte	0x4
 1474 0083 04       		.byte	0x4
 1475 0084 B9020000 		.4byte	.LASF11
 1476 0088 02       		.uleb128 0x2
 1477 0089 08       		.byte	0x8
 1478 008a 04       		.byte	0x4
 1479 008b D3000000 		.4byte	.LASF12
 1480 008f 04       		.uleb128 0x4
 1481 0090 DD030000 		.4byte	.LASF13
 1482 0094 02       		.byte	0x2
 1483 0095 B2       		.byte	0xb2
 1484 0096 9A000000 		.4byte	0x9a
 1485 009a 02       		.uleb128 0x2
 1486 009b 01       		.byte	0x1
 1487 009c 08       		.byte	0x8
 1488 009d D8030000 		.4byte	.LASF14
 1489 00a1 05       		.uleb128 0x5
 1490 00a2 68030000 		.4byte	.LASF15
 1491 00a6 02       		.byte	0x2
 1492 00a7 4B01     		.2byte	0x14b
 1493 00a9 AD000000 		.4byte	0xad
 1494 00ad 06       		.uleb128 0x6
 1495 00ae 6B000000 		.4byte	0x6b
 1496 00b2 02       		.uleb128 0x2
 1497 00b3 04       		.byte	0x4
 1498 00b4 07       		.byte	0x7
 1499 00b5 16020000 		.4byte	.LASF16
 1500 00b9 07       		.uleb128 0x7
 1501 00ba C0000000 		.4byte	.LASF17
 1502 00be 01       		.byte	0x1
 1503 00bf 49       		.byte	0x49
 1504 00c0 00000000 		.4byte	.LFB0
 1505 00c4 24000000 		.4byte	.LFE0-.LFB0
 1506 00c8 01       		.uleb128 0x1
 1507 00c9 9C       		.byte	0x9c
 1508 00ca 08       		.uleb128 0x8
 1509 00cb E3030000 		.4byte	.LASF18
 1510 00cf 01       		.byte	0x1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 56


 1511 00d0 65       		.byte	0x65
 1512 00d1 00000000 		.4byte	.LFB1
 1513 00d5 3C000000 		.4byte	.LFE1-.LFB1
 1514 00d9 01       		.uleb128 0x1
 1515 00da 9C       		.byte	0x9c
 1516 00db 09       		.uleb128 0x9
 1517 00dc 7D010000 		.4byte	.LASF19
 1518 00e0 01       		.byte	0x1
 1519 00e1 AE       		.byte	0xae
 1520 00e2 00000000 		.4byte	.LFB2
 1521 00e6 60000000 		.4byte	.LFE2-.LFB2
 1522 00ea 01       		.uleb128 0x1
 1523 00eb 9C       		.byte	0x9c
 1524 00ec FF000000 		.4byte	0xff
 1525 00f0 0A       		.uleb128 0xa
 1526 00f1 EF030000 		.4byte	.LASF21
 1527 00f5 01       		.byte	0x1
 1528 00f6 B0       		.byte	0xb0
 1529 00f7 6B000000 		.4byte	0x6b
 1530 00fb 02       		.uleb128 0x2
 1531 00fc 91       		.byte	0x91
 1532 00fd 6F       		.sleb128 -17
 1533 00fe 00       		.byte	0
 1534 00ff 09       		.uleb128 0x9
 1535 0100 CF010000 		.4byte	.LASF20
 1536 0104 01       		.byte	0x1
 1537 0105 E3       		.byte	0xe3
 1538 0106 00000000 		.4byte	.LFB3
 1539 010a 60000000 		.4byte	.LFE3-.LFB3
 1540 010e 01       		.uleb128 0x1
 1541 010f 9C       		.byte	0x9c
 1542 0110 23010000 		.4byte	0x123
 1543 0114 0A       		.uleb128 0xa
 1544 0115 EF030000 		.4byte	.LASF21
 1545 0119 01       		.byte	0x1
 1546 011a E5       		.byte	0xe5
 1547 011b 6B000000 		.4byte	0x6b
 1548 011f 02       		.uleb128 0x2
 1549 0120 91       		.byte	0x91
 1550 0121 6F       		.sleb128 -17
 1551 0122 00       		.byte	0
 1552 0123 0B       		.uleb128 0xb
 1553 0124 B4010000 		.4byte	.LASF32
 1554 0128 01       		.byte	0x1
 1555 0129 1901     		.2byte	0x119
 1556 012b 6B000000 		.4byte	0x6b
 1557 012f 00000000 		.4byte	.LFB4
 1558 0133 0C000000 		.4byte	.LFE4-.LFB4
 1559 0137 01       		.uleb128 0x1
 1560 0138 9C       		.byte	0x9c
 1561 0139 0C       		.uleb128 0xc
 1562 013a 85030000 		.4byte	.LASF22
 1563 013e 01       		.byte	0x1
 1564 013f 3101     		.2byte	0x131
 1565 0141 00000000 		.4byte	.LFB5
 1566 0145 12000000 		.4byte	.LFE5-.LFB5
 1567 0149 01       		.uleb128 0x1
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 57


 1568 014a 9C       		.byte	0x9c
 1569 014b 5F010000 		.4byte	0x15f
 1570 014f 0D       		.uleb128 0xd
 1571 0150 08010000 		.4byte	.LASF24
 1572 0154 01       		.byte	0x1
 1573 0155 3101     		.2byte	0x131
 1574 0157 6B000000 		.4byte	0x6b
 1575 015b 02       		.uleb128 0x2
 1576 015c 91       		.byte	0x91
 1577 015d 77       		.sleb128 -9
 1578 015e 00       		.byte	0
 1579 015f 0C       		.uleb128 0xc
 1580 0160 10010000 		.4byte	.LASF23
 1581 0164 01       		.byte	0x1
 1582 0165 8101     		.2byte	0x181
 1583 0167 00000000 		.4byte	.LFB6
 1584 016b 20000000 		.4byte	.LFE6-.LFB6
 1585 016f 01       		.uleb128 0x1
 1586 0170 9C       		.byte	0x9c
 1587 0171 85010000 		.4byte	0x185
 1588 0175 0D       		.uleb128 0xd
 1589 0176 AD010000 		.4byte	.LASF25
 1590 017a 01       		.byte	0x1
 1591 017b 8101     		.2byte	0x181
 1592 017d 6B000000 		.4byte	0x6b
 1593 0181 02       		.uleb128 0x2
 1594 0182 91       		.byte	0x91
 1595 0183 77       		.sleb128 -9
 1596 0184 00       		.byte	0
 1597 0185 0E       		.uleb128 0xe
 1598 0186 4E000000 		.4byte	.LASF27
 1599 018a 01       		.byte	0x1
 1600 018b A201     		.2byte	0x1a2
 1601 018d 6B000000 		.4byte	0x6b
 1602 0191 00000000 		.4byte	.LFB7
 1603 0195 20000000 		.4byte	.LFE7-.LFB7
 1604 0199 01       		.uleb128 0x1
 1605 019a 9C       		.byte	0x9c
 1606 019b AF010000 		.4byte	0x1af
 1607 019f 0F       		.uleb128 0xf
 1608 01a0 D1030000 		.4byte	.LASF26
 1609 01a4 01       		.byte	0x1
 1610 01a5 A401     		.2byte	0x1a4
 1611 01a7 6B000000 		.4byte	0x6b
 1612 01ab 02       		.uleb128 0x2
 1613 01ac 91       		.byte	0x91
 1614 01ad 77       		.sleb128 -9
 1615 01ae 00       		.byte	0
 1616 01af 0E       		.uleb128 0xe
 1617 01b0 07040000 		.4byte	.LASF28
 1618 01b4 01       		.byte	0x1
 1619 01b5 FD01     		.2byte	0x1fd
 1620 01b7 6B000000 		.4byte	0x6b
 1621 01bb 00000000 		.4byte	.LFB8
 1622 01bf 24000000 		.4byte	.LFE8-.LFB8
 1623 01c3 01       		.uleb128 0x1
 1624 01c4 9C       		.byte	0x9c
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 58


 1625 01c5 D9010000 		.4byte	0x1d9
 1626 01c9 0F       		.uleb128 0xf
 1627 01ca 00040000 		.4byte	.LASF29
 1628 01ce 01       		.byte	0x1
 1629 01cf FF01     		.2byte	0x1ff
 1630 01d1 6B000000 		.4byte	0x6b
 1631 01d5 02       		.uleb128 0x2
 1632 01d6 91       		.byte	0x91
 1633 01d7 77       		.sleb128 -9
 1634 01d8 00       		.byte	0
 1635 01d9 0E       		.uleb128 0xe
 1636 01da 1B040000 		.4byte	.LASF30
 1637 01de 01       		.byte	0x1
 1638 01df 2C02     		.2byte	0x22c
 1639 01e1 6B000000 		.4byte	0x6b
 1640 01e5 00000000 		.4byte	.LFB9
 1641 01e9 4C000000 		.4byte	.LFE9-.LFB9
 1642 01ed 01       		.uleb128 0x1
 1643 01ee 9C       		.byte	0x9c
 1644 01ef 12020000 		.4byte	0x212
 1645 01f3 0F       		.uleb128 0xf
 1646 01f4 D1030000 		.4byte	.LASF26
 1647 01f8 01       		.byte	0x1
 1648 01f9 2E02     		.2byte	0x22e
 1649 01fb 6B000000 		.4byte	0x6b
 1650 01ff 02       		.uleb128 0x2
 1651 0200 91       		.byte	0x91
 1652 0201 77       		.sleb128 -9
 1653 0202 0F       		.uleb128 0xf
 1654 0203 96020000 		.4byte	.LASF31
 1655 0207 01       		.byte	0x1
 1656 0208 2F02     		.2byte	0x22f
 1657 020a 6B000000 		.4byte	0x6b
 1658 020e 02       		.uleb128 0x2
 1659 020f 91       		.byte	0x91
 1660 0210 76       		.sleb128 -10
 1661 0211 00       		.byte	0
 1662 0212 10       		.uleb128 0x10
 1663 0213 DB010000 		.4byte	.LASF33
 1664 0217 01       		.byte	0x1
 1665 0218 9202     		.2byte	0x292
 1666 021a 76000000 		.4byte	0x76
 1667 021e 00000000 		.4byte	.LFB10
 1668 0222 22000000 		.4byte	.LFE10-.LFB10
 1669 0226 01       		.uleb128 0x1
 1670 0227 9C       		.byte	0x9c
 1671 0228 0E       		.uleb128 0xe
 1672 0229 BA030000 		.4byte	.LASF34
 1673 022d 01       		.byte	0x1
 1674 022e B302     		.2byte	0x2b3
 1675 0230 6B000000 		.4byte	0x6b
 1676 0234 00000000 		.4byte	.LFB11
 1677 0238 30000000 		.4byte	.LFE11-.LFB11
 1678 023c 01       		.uleb128 0x1
 1679 023d 9C       		.byte	0x9c
 1680 023e 52020000 		.4byte	0x252
 1681 0242 0F       		.uleb128 0xf
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 59


 1682 0243 65010000 		.4byte	.LASF35
 1683 0247 01       		.byte	0x1
 1684 0248 B602     		.2byte	0x2b6
 1685 024a 6B000000 		.4byte	0x6b
 1686 024e 02       		.uleb128 0x2
 1687 024f 91       		.byte	0x91
 1688 0250 77       		.sleb128 -9
 1689 0251 00       		.byte	0
 1690 0252 11       		.uleb128 0x11
 1691 0253 3B030000 		.4byte	.LASF36
 1692 0257 01       		.byte	0x1
 1693 0258 0303     		.2byte	0x303
 1694 025a 00000000 		.4byte	.LFB12
 1695 025e 44000000 		.4byte	.LFE12-.LFB12
 1696 0262 01       		.uleb128 0x1
 1697 0263 9C       		.byte	0x9c
 1698 0264 78020000 		.4byte	0x278
 1699 0268 0F       		.uleb128 0xf
 1700 0269 EF030000 		.4byte	.LASF21
 1701 026d 01       		.byte	0x1
 1702 026e 0503     		.2byte	0x305
 1703 0270 6B000000 		.4byte	0x6b
 1704 0274 02       		.uleb128 0x2
 1705 0275 91       		.byte	0x91
 1706 0276 6F       		.sleb128 -17
 1707 0277 00       		.byte	0
 1708 0278 0C       		.uleb128 0xc
 1709 0279 50030000 		.4byte	.LASF37
 1710 027d 01       		.byte	0x1
 1711 027e 4003     		.2byte	0x340
 1712 0280 00000000 		.4byte	.LFB13
 1713 0284 12000000 		.4byte	.LFE13-.LFB13
 1714 0288 01       		.uleb128 0x1
 1715 0289 9C       		.byte	0x9c
 1716 028a 9E020000 		.4byte	0x29e
 1717 028e 0D       		.uleb128 0xd
 1718 028f DA000000 		.4byte	.LASF38
 1719 0293 01       		.byte	0x1
 1720 0294 4003     		.2byte	0x340
 1721 0296 6B000000 		.4byte	0x6b
 1722 029a 02       		.uleb128 0x2
 1723 029b 91       		.byte	0x91
 1724 029c 77       		.sleb128 -9
 1725 029d 00       		.byte	0
 1726 029e 0C       		.uleb128 0xc
 1727 029f 81020000 		.4byte	.LASF39
 1728 02a3 01       		.byte	0x1
 1729 02a4 6503     		.2byte	0x365
 1730 02a6 00000000 		.4byte	.LFB14
 1731 02aa 20000000 		.4byte	.LFE14-.LFB14
 1732 02ae 01       		.uleb128 0x1
 1733 02af 9C       		.byte	0x9c
 1734 02b0 C4020000 		.4byte	0x2c4
 1735 02b4 0D       		.uleb128 0xd
 1736 02b5 79020000 		.4byte	.LASF40
 1737 02b9 01       		.byte	0x1
 1738 02ba 6503     		.2byte	0x365
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 60


 1739 02bc 6B000000 		.4byte	0x6b
 1740 02c0 02       		.uleb128 0x2
 1741 02c1 91       		.byte	0x91
 1742 02c2 77       		.sleb128 -9
 1743 02c3 00       		.byte	0
 1744 02c4 0C       		.uleb128 0xc
 1745 02c5 64020000 		.4byte	.LASF41
 1746 02c9 01       		.byte	0x1
 1747 02ca 7A03     		.2byte	0x37a
 1748 02cc 00000000 		.4byte	.LFB15
 1749 02d0 20000000 		.4byte	.LFE15-.LFB15
 1750 02d4 01       		.uleb128 0x1
 1751 02d5 9C       		.byte	0x9c
 1752 02d6 EA020000 		.4byte	0x2ea
 1753 02da 0D       		.uleb128 0xd
 1754 02db 79020000 		.4byte	.LASF40
 1755 02df 01       		.byte	0x1
 1756 02e0 7A03     		.2byte	0x37a
 1757 02e2 6B000000 		.4byte	0x6b
 1758 02e6 02       		.uleb128 0x2
 1759 02e7 91       		.byte	0x91
 1760 02e8 77       		.sleb128 -9
 1761 02e9 00       		.byte	0
 1762 02ea 0C       		.uleb128 0xc
 1763 02eb 9F020000 		.4byte	.LASF42
 1764 02ef 01       		.byte	0x1
 1765 02f0 C803     		.2byte	0x3c8
 1766 02f2 00000000 		.4byte	.LFB16
 1767 02f6 20000000 		.4byte	.LFE16-.LFB16
 1768 02fa 01       		.uleb128 0x1
 1769 02fb 9C       		.byte	0x9c
 1770 02fc 10030000 		.4byte	0x310
 1771 0300 0D       		.uleb128 0xd
 1772 0301 AD010000 		.4byte	.LASF25
 1773 0305 01       		.byte	0x1
 1774 0306 C803     		.2byte	0x3c8
 1775 0308 6B000000 		.4byte	0x6b
 1776 030c 02       		.uleb128 0x2
 1777 030d 91       		.byte	0x91
 1778 030e 77       		.sleb128 -9
 1779 030f 00       		.byte	0
 1780 0310 0C       		.uleb128 0xc
 1781 0311 FB010000 		.4byte	.LASF43
 1782 0315 01       		.byte	0x1
 1783 0316 EA03     		.2byte	0x3ea
 1784 0318 00000000 		.4byte	.LFB17
 1785 031c 2C000000 		.4byte	.LFE17-.LFB17
 1786 0320 01       		.uleb128 0x1
 1787 0321 9C       		.byte	0x9c
 1788 0322 36030000 		.4byte	0x336
 1789 0326 0D       		.uleb128 0xd
 1790 0327 1C000000 		.4byte	.LASF44
 1791 032b 01       		.byte	0x1
 1792 032c EA03     		.2byte	0x3ea
 1793 032e 6B000000 		.4byte	0x6b
 1794 0332 02       		.uleb128 0x2
 1795 0333 91       		.byte	0x91
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 61


 1796 0334 77       		.sleb128 -9
 1797 0335 00       		.byte	0
 1798 0336 0B       		.uleb128 0xb
 1799 0337 3F010000 		.4byte	.LASF45
 1800 033b 01       		.byte	0x1
 1801 033c 2E04     		.2byte	0x42e
 1802 033e 6B000000 		.4byte	0x6b
 1803 0342 00000000 		.4byte	.LFB18
 1804 0346 14000000 		.4byte	.LFE18-.LFB18
 1805 034a 01       		.uleb128 0x1
 1806 034b 9C       		.byte	0x9c
 1807 034c 0C       		.uleb128 0xc
 1808 034d 27000000 		.4byte	.LASF46
 1809 0351 01       		.byte	0x1
 1810 0352 5204     		.2byte	0x452
 1811 0354 00000000 		.4byte	.LFB19
 1812 0358 34000000 		.4byte	.LFE19-.LFB19
 1813 035c 01       		.uleb128 0x1
 1814 035d 9C       		.byte	0x9c
 1815 035e 72030000 		.4byte	0x372
 1816 0362 0D       		.uleb128 0xd
 1817 0363 1C000000 		.4byte	.LASF44
 1818 0367 01       		.byte	0x1
 1819 0368 5204     		.2byte	0x452
 1820 036a 6B000000 		.4byte	0x6b
 1821 036e 02       		.uleb128 0x2
 1822 036f 91       		.byte	0x91
 1823 0370 77       		.sleb128 -9
 1824 0371 00       		.byte	0
 1825 0372 11       		.uleb128 0x11
 1826 0373 EA010000 		.4byte	.LASF47
 1827 0377 01       		.byte	0x1
 1828 0378 AE04     		.2byte	0x4ae
 1829 037a 00000000 		.4byte	.LFB20
 1830 037e 54000000 		.4byte	.LFE20-.LFB20
 1831 0382 01       		.uleb128 0x1
 1832 0383 9C       		.byte	0x9c
 1833 0384 A7030000 		.4byte	0x3a7
 1834 0388 0D       		.uleb128 0xd
 1835 0389 36000000 		.4byte	.LASF48
 1836 038d 01       		.byte	0x1
 1837 038e AE04     		.2byte	0x4ae
 1838 0390 A7030000 		.4byte	0x3a7
 1839 0394 02       		.uleb128 0x2
 1840 0395 91       		.byte	0x91
 1841 0396 6C       		.sleb128 -20
 1842 0397 0F       		.uleb128 0xf
 1843 0398 2A040000 		.4byte	.LASF49
 1844 039c 01       		.byte	0x1
 1845 039d B004     		.2byte	0x4b0
 1846 039f 76000000 		.4byte	0x76
 1847 03a3 02       		.uleb128 0x2
 1848 03a4 91       		.byte	0x91
 1849 03a5 76       		.sleb128 -10
 1850 03a6 00       		.byte	0
 1851 03a7 12       		.uleb128 0x12
 1852 03a8 04       		.byte	0x4
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 62


 1853 03a9 AD030000 		.4byte	0x3ad
 1854 03ad 13       		.uleb128 0x13
 1855 03ae 8F000000 		.4byte	0x8f
 1856 03b2 11       		.uleb128 0x11
 1857 03b3 34040000 		.4byte	.LASF50
 1858 03b7 01       		.byte	0x1
 1859 03b8 D404     		.2byte	0x4d4
 1860 03ba 00000000 		.4byte	.LFB21
 1861 03be 58000000 		.4byte	.LFE21-.LFB21
 1862 03c2 01       		.uleb128 0x1
 1863 03c3 9C       		.byte	0x9c
 1864 03c4 F6030000 		.4byte	0x3f6
 1865 03c8 0D       		.uleb128 0xd
 1866 03c9 36000000 		.4byte	.LASF48
 1867 03cd 01       		.byte	0x1
 1868 03ce D404     		.2byte	0x4d4
 1869 03d0 F6030000 		.4byte	0x3f6
 1870 03d4 02       		.uleb128 0x2
 1871 03d5 91       		.byte	0x91
 1872 03d6 6C       		.sleb128 -20
 1873 03d7 0D       		.uleb128 0xd
 1874 03d8 B0030000 		.4byte	.LASF51
 1875 03dc 01       		.byte	0x1
 1876 03dd D404     		.2byte	0x4d4
 1877 03df 6B000000 		.4byte	0x6b
 1878 03e3 02       		.uleb128 0x2
 1879 03e4 91       		.byte	0x91
 1880 03e5 6B       		.sleb128 -21
 1881 03e6 0F       		.uleb128 0xf
 1882 03e7 2A040000 		.4byte	.LASF49
 1883 03eb 01       		.byte	0x1
 1884 03ec D704     		.2byte	0x4d7
 1885 03ee 6B000000 		.4byte	0x6b
 1886 03f2 02       		.uleb128 0x2
 1887 03f3 91       		.byte	0x91
 1888 03f4 77       		.sleb128 -9
 1889 03f5 00       		.byte	0
 1890 03f6 12       		.uleb128 0x12
 1891 03f7 04       		.byte	0x4
 1892 03f8 FC030000 		.4byte	0x3fc
 1893 03fc 13       		.uleb128 0x13
 1894 03fd 6B000000 		.4byte	0x6b
 1895 0401 11       		.uleb128 0x11
 1896 0402 A8000000 		.4byte	.LASF52
 1897 0406 01       		.byte	0x1
 1898 0407 F904     		.2byte	0x4f9
 1899 0409 00000000 		.4byte	.LFB22
 1900 040d 34000000 		.4byte	.LFE22-.LFB22
 1901 0411 01       		.uleb128 0x1
 1902 0412 9C       		.byte	0x9c
 1903 0413 27040000 		.4byte	0x427
 1904 0417 0D       		.uleb128 0xd
 1905 0418 1C000000 		.4byte	.LASF44
 1906 041c 01       		.byte	0x1
 1907 041d F904     		.2byte	0x4f9
 1908 041f 6B000000 		.4byte	0x6b
 1909 0423 02       		.uleb128 0x2
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 63


 1910 0424 91       		.byte	0x91
 1911 0425 77       		.sleb128 -9
 1912 0426 00       		.byte	0
 1913 0427 0E       		.uleb128 0xe
 1914 0428 77000000 		.4byte	.LASF53
 1915 042c 01       		.byte	0x1
 1916 042d 1E05     		.2byte	0x51e
 1917 042f 6B000000 		.4byte	0x6b
 1918 0433 00000000 		.4byte	.LFB23
 1919 0437 48000000 		.4byte	.LFE23-.LFB23
 1920 043b 01       		.uleb128 0x1
 1921 043c 9C       		.byte	0x9c
 1922 043d 51040000 		.4byte	0x451
 1923 0441 0F       		.uleb128 0xf
 1924 0442 65010000 		.4byte	.LASF35
 1925 0446 01       		.byte	0x1
 1926 0447 2105     		.2byte	0x521
 1927 0449 6B000000 		.4byte	0x6b
 1928 044d 02       		.uleb128 0x2
 1929 044e 91       		.byte	0x91
 1930 044f 77       		.sleb128 -9
 1931 0450 00       		.byte	0
 1932 0451 11       		.uleb128 0x11
 1933 0452 07000000 		.4byte	.LASF54
 1934 0456 01       		.byte	0x1
 1935 0457 7405     		.2byte	0x574
 1936 0459 00000000 		.4byte	.LFB24
 1937 045d 44000000 		.4byte	.LFE24-.LFB24
 1938 0461 01       		.uleb128 0x1
 1939 0462 9C       		.byte	0x9c
 1940 0463 77040000 		.4byte	0x477
 1941 0467 0F       		.uleb128 0xf
 1942 0468 EF030000 		.4byte	.LASF21
 1943 046c 01       		.byte	0x1
 1944 046d 7605     		.2byte	0x576
 1945 046f 6B000000 		.4byte	0x6b
 1946 0473 02       		.uleb128 0x2
 1947 0474 91       		.byte	0x91
 1948 0475 6F       		.sleb128 -17
 1949 0476 00       		.byte	0
 1950 0477 0C       		.uleb128 0xc
 1951 0478 3D000000 		.4byte	.LASF55
 1952 047c 01       		.byte	0x1
 1953 047d CD05     		.2byte	0x5cd
 1954 047f 00000000 		.4byte	.LFB25
 1955 0483 B8000000 		.4byte	.LFE25-.LFB25
 1956 0487 01       		.uleb128 0x1
 1957 0488 9C       		.byte	0x9c
 1958 0489 C8040000 		.4byte	0x4c8
 1959 048d 0D       		.uleb128 0xd
 1960 048e 2A010000 		.4byte	.LASF56
 1961 0492 01       		.byte	0x1
 1962 0493 CD05     		.2byte	0x5cd
 1963 0495 6B000000 		.4byte	0x6b
 1964 0499 02       		.uleb128 0x2
 1965 049a 91       		.byte	0x91
 1966 049b 6F       		.sleb128 -17
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 64


 1967 049c 14       		.uleb128 0x14
 1968 049d 14000000 		.4byte	.LBB2
 1969 04a1 88000000 		.4byte	.LBE2-.LBB2
 1970 04a5 0F       		.uleb128 0xf
 1971 04a6 0E020000 		.4byte	.LASF57
 1972 04aa 01       		.byte	0x1
 1973 04ab D505     		.2byte	0x5d5
 1974 04ad 6B000000 		.4byte	0x6b
 1975 04b1 02       		.uleb128 0x2
 1976 04b2 91       		.byte	0x91
 1977 04b3 77       		.sleb128 -9
 1978 04b4 0F       		.uleb128 0xf
 1979 04b5 A3010000 		.4byte	.LASF58
 1980 04b9 01       		.byte	0x1
 1981 04ba FB05     		.2byte	0x5fb
 1982 04bc 6B000000 		.4byte	0x6b
 1983 04c0 05       		.uleb128 0x5
 1984 04c1 03       		.byte	0x3
 1985 04c2 01000000 		.4byte	tx_period.4828
 1986 04c6 00       		.byte	0
 1987 04c7 00       		.byte	0
 1988 04c8 0C       		.uleb128 0xc
 1989 04c9 8B010000 		.4byte	.LASF59
 1990 04cd 01       		.byte	0x1
 1991 04ce 4606     		.2byte	0x646
 1992 04d0 00000000 		.4byte	.LFB26
 1993 04d4 12000000 		.4byte	.LFE26-.LFB26
 1994 04d8 01       		.uleb128 0x1
 1995 04d9 9C       		.byte	0x9c
 1996 04da EE040000 		.4byte	0x4ee
 1997 04de 0D       		.uleb128 0xd
 1998 04df DA000000 		.4byte	.LASF38
 1999 04e3 01       		.byte	0x1
 2000 04e4 4606     		.2byte	0x646
 2001 04e6 6B000000 		.4byte	0x6b
 2002 04ea 02       		.uleb128 0x2
 2003 04eb 91       		.byte	0x91
 2004 04ec 77       		.sleb128 -9
 2005 04ed 00       		.byte	0
 2006 04ee 15       		.uleb128 0x15
 2007 04ef A1030000 		.4byte	.LASF63
 2008 04f3 01       		.byte	0x1
 2009 04f4 1C       		.byte	0x1c
 2010 04f5 6B000000 		.4byte	0x6b
 2011 04f9 05       		.uleb128 0x5
 2012 04fa 03       		.byte	0x3
 2013 04fb 00000000 		.4byte	UART_1_initVar
 2014 04ff 00       		.byte	0
 2015              		.section	.debug_abbrev,"",%progbits
 2016              	.Ldebug_abbrev0:
 2017 0000 01       		.uleb128 0x1
 2018 0001 11       		.uleb128 0x11
 2019 0002 01       		.byte	0x1
 2020 0003 25       		.uleb128 0x25
 2021 0004 0E       		.uleb128 0xe
 2022 0005 13       		.uleb128 0x13
 2023 0006 0B       		.uleb128 0xb
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 65


 2024 0007 03       		.uleb128 0x3
 2025 0008 0E       		.uleb128 0xe
 2026 0009 1B       		.uleb128 0x1b
 2027 000a 0E       		.uleb128 0xe
 2028 000b 55       		.uleb128 0x55
 2029 000c 17       		.uleb128 0x17
 2030 000d 11       		.uleb128 0x11
 2031 000e 01       		.uleb128 0x1
 2032 000f 10       		.uleb128 0x10
 2033 0010 17       		.uleb128 0x17
 2034 0011 00       		.byte	0
 2035 0012 00       		.byte	0
 2036 0013 02       		.uleb128 0x2
 2037 0014 24       		.uleb128 0x24
 2038 0015 00       		.byte	0
 2039 0016 0B       		.uleb128 0xb
 2040 0017 0B       		.uleb128 0xb
 2041 0018 3E       		.uleb128 0x3e
 2042 0019 0B       		.uleb128 0xb
 2043 001a 03       		.uleb128 0x3
 2044 001b 0E       		.uleb128 0xe
 2045 001c 00       		.byte	0
 2046 001d 00       		.byte	0
 2047 001e 03       		.uleb128 0x3
 2048 001f 24       		.uleb128 0x24
 2049 0020 00       		.byte	0
 2050 0021 0B       		.uleb128 0xb
 2051 0022 0B       		.uleb128 0xb
 2052 0023 3E       		.uleb128 0x3e
 2053 0024 0B       		.uleb128 0xb
 2054 0025 03       		.uleb128 0x3
 2055 0026 08       		.uleb128 0x8
 2056 0027 00       		.byte	0
 2057 0028 00       		.byte	0
 2058 0029 04       		.uleb128 0x4
 2059 002a 16       		.uleb128 0x16
 2060 002b 00       		.byte	0
 2061 002c 03       		.uleb128 0x3
 2062 002d 0E       		.uleb128 0xe
 2063 002e 3A       		.uleb128 0x3a
 2064 002f 0B       		.uleb128 0xb
 2065 0030 3B       		.uleb128 0x3b
 2066 0031 0B       		.uleb128 0xb
 2067 0032 49       		.uleb128 0x49
 2068 0033 13       		.uleb128 0x13
 2069 0034 00       		.byte	0
 2070 0035 00       		.byte	0
 2071 0036 05       		.uleb128 0x5
 2072 0037 16       		.uleb128 0x16
 2073 0038 00       		.byte	0
 2074 0039 03       		.uleb128 0x3
 2075 003a 0E       		.uleb128 0xe
 2076 003b 3A       		.uleb128 0x3a
 2077 003c 0B       		.uleb128 0xb
 2078 003d 3B       		.uleb128 0x3b
 2079 003e 05       		.uleb128 0x5
 2080 003f 49       		.uleb128 0x49
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 66


 2081 0040 13       		.uleb128 0x13
 2082 0041 00       		.byte	0
 2083 0042 00       		.byte	0
 2084 0043 06       		.uleb128 0x6
 2085 0044 35       		.uleb128 0x35
 2086 0045 00       		.byte	0
 2087 0046 49       		.uleb128 0x49
 2088 0047 13       		.uleb128 0x13
 2089 0048 00       		.byte	0
 2090 0049 00       		.byte	0
 2091 004a 07       		.uleb128 0x7
 2092 004b 2E       		.uleb128 0x2e
 2093 004c 00       		.byte	0
 2094 004d 3F       		.uleb128 0x3f
 2095 004e 19       		.uleb128 0x19
 2096 004f 03       		.uleb128 0x3
 2097 0050 0E       		.uleb128 0xe
 2098 0051 3A       		.uleb128 0x3a
 2099 0052 0B       		.uleb128 0xb
 2100 0053 3B       		.uleb128 0x3b
 2101 0054 0B       		.uleb128 0xb
 2102 0055 27       		.uleb128 0x27
 2103 0056 19       		.uleb128 0x19
 2104 0057 11       		.uleb128 0x11
 2105 0058 01       		.uleb128 0x1
 2106 0059 12       		.uleb128 0x12
 2107 005a 06       		.uleb128 0x6
 2108 005b 40       		.uleb128 0x40
 2109 005c 18       		.uleb128 0x18
 2110 005d 9642     		.uleb128 0x2116
 2111 005f 19       		.uleb128 0x19
 2112 0060 00       		.byte	0
 2113 0061 00       		.byte	0
 2114 0062 08       		.uleb128 0x8
 2115 0063 2E       		.uleb128 0x2e
 2116 0064 00       		.byte	0
 2117 0065 3F       		.uleb128 0x3f
 2118 0066 19       		.uleb128 0x19
 2119 0067 03       		.uleb128 0x3
 2120 0068 0E       		.uleb128 0xe
 2121 0069 3A       		.uleb128 0x3a
 2122 006a 0B       		.uleb128 0xb
 2123 006b 3B       		.uleb128 0x3b
 2124 006c 0B       		.uleb128 0xb
 2125 006d 27       		.uleb128 0x27
 2126 006e 19       		.uleb128 0x19
 2127 006f 11       		.uleb128 0x11
 2128 0070 01       		.uleb128 0x1
 2129 0071 12       		.uleb128 0x12
 2130 0072 06       		.uleb128 0x6
 2131 0073 40       		.uleb128 0x40
 2132 0074 18       		.uleb128 0x18
 2133 0075 9742     		.uleb128 0x2117
 2134 0077 19       		.uleb128 0x19
 2135 0078 00       		.byte	0
 2136 0079 00       		.byte	0
 2137 007a 09       		.uleb128 0x9
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 67


 2138 007b 2E       		.uleb128 0x2e
 2139 007c 01       		.byte	0x1
 2140 007d 3F       		.uleb128 0x3f
 2141 007e 19       		.uleb128 0x19
 2142 007f 03       		.uleb128 0x3
 2143 0080 0E       		.uleb128 0xe
 2144 0081 3A       		.uleb128 0x3a
 2145 0082 0B       		.uleb128 0xb
 2146 0083 3B       		.uleb128 0x3b
 2147 0084 0B       		.uleb128 0xb
 2148 0085 27       		.uleb128 0x27
 2149 0086 19       		.uleb128 0x19
 2150 0087 11       		.uleb128 0x11
 2151 0088 01       		.uleb128 0x1
 2152 0089 12       		.uleb128 0x12
 2153 008a 06       		.uleb128 0x6
 2154 008b 40       		.uleb128 0x40
 2155 008c 18       		.uleb128 0x18
 2156 008d 9642     		.uleb128 0x2116
 2157 008f 19       		.uleb128 0x19
 2158 0090 01       		.uleb128 0x1
 2159 0091 13       		.uleb128 0x13
 2160 0092 00       		.byte	0
 2161 0093 00       		.byte	0
 2162 0094 0A       		.uleb128 0xa
 2163 0095 34       		.uleb128 0x34
 2164 0096 00       		.byte	0
 2165 0097 03       		.uleb128 0x3
 2166 0098 0E       		.uleb128 0xe
 2167 0099 3A       		.uleb128 0x3a
 2168 009a 0B       		.uleb128 0xb
 2169 009b 3B       		.uleb128 0x3b
 2170 009c 0B       		.uleb128 0xb
 2171 009d 49       		.uleb128 0x49
 2172 009e 13       		.uleb128 0x13
 2173 009f 02       		.uleb128 0x2
 2174 00a0 18       		.uleb128 0x18
 2175 00a1 00       		.byte	0
 2176 00a2 00       		.byte	0
 2177 00a3 0B       		.uleb128 0xb
 2178 00a4 2E       		.uleb128 0x2e
 2179 00a5 00       		.byte	0
 2180 00a6 3F       		.uleb128 0x3f
 2181 00a7 19       		.uleb128 0x19
 2182 00a8 03       		.uleb128 0x3
 2183 00a9 0E       		.uleb128 0xe
 2184 00aa 3A       		.uleb128 0x3a
 2185 00ab 0B       		.uleb128 0xb
 2186 00ac 3B       		.uleb128 0x3b
 2187 00ad 05       		.uleb128 0x5
 2188 00ae 27       		.uleb128 0x27
 2189 00af 19       		.uleb128 0x19
 2190 00b0 49       		.uleb128 0x49
 2191 00b1 13       		.uleb128 0x13
 2192 00b2 11       		.uleb128 0x11
 2193 00b3 01       		.uleb128 0x1
 2194 00b4 12       		.uleb128 0x12
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 68


 2195 00b5 06       		.uleb128 0x6
 2196 00b6 40       		.uleb128 0x40
 2197 00b7 18       		.uleb128 0x18
 2198 00b8 9742     		.uleb128 0x2117
 2199 00ba 19       		.uleb128 0x19
 2200 00bb 00       		.byte	0
 2201 00bc 00       		.byte	0
 2202 00bd 0C       		.uleb128 0xc
 2203 00be 2E       		.uleb128 0x2e
 2204 00bf 01       		.byte	0x1
 2205 00c0 3F       		.uleb128 0x3f
 2206 00c1 19       		.uleb128 0x19
 2207 00c2 03       		.uleb128 0x3
 2208 00c3 0E       		.uleb128 0xe
 2209 00c4 3A       		.uleb128 0x3a
 2210 00c5 0B       		.uleb128 0xb
 2211 00c6 3B       		.uleb128 0x3b
 2212 00c7 05       		.uleb128 0x5
 2213 00c8 27       		.uleb128 0x27
 2214 00c9 19       		.uleb128 0x19
 2215 00ca 11       		.uleb128 0x11
 2216 00cb 01       		.uleb128 0x1
 2217 00cc 12       		.uleb128 0x12
 2218 00cd 06       		.uleb128 0x6
 2219 00ce 40       		.uleb128 0x40
 2220 00cf 18       		.uleb128 0x18
 2221 00d0 9742     		.uleb128 0x2117
 2222 00d2 19       		.uleb128 0x19
 2223 00d3 01       		.uleb128 0x1
 2224 00d4 13       		.uleb128 0x13
 2225 00d5 00       		.byte	0
 2226 00d6 00       		.byte	0
 2227 00d7 0D       		.uleb128 0xd
 2228 00d8 05       		.uleb128 0x5
 2229 00d9 00       		.byte	0
 2230 00da 03       		.uleb128 0x3
 2231 00db 0E       		.uleb128 0xe
 2232 00dc 3A       		.uleb128 0x3a
 2233 00dd 0B       		.uleb128 0xb
 2234 00de 3B       		.uleb128 0x3b
 2235 00df 05       		.uleb128 0x5
 2236 00e0 49       		.uleb128 0x49
 2237 00e1 13       		.uleb128 0x13
 2238 00e2 02       		.uleb128 0x2
 2239 00e3 18       		.uleb128 0x18
 2240 00e4 00       		.byte	0
 2241 00e5 00       		.byte	0
 2242 00e6 0E       		.uleb128 0xe
 2243 00e7 2E       		.uleb128 0x2e
 2244 00e8 01       		.byte	0x1
 2245 00e9 3F       		.uleb128 0x3f
 2246 00ea 19       		.uleb128 0x19
 2247 00eb 03       		.uleb128 0x3
 2248 00ec 0E       		.uleb128 0xe
 2249 00ed 3A       		.uleb128 0x3a
 2250 00ee 0B       		.uleb128 0xb
 2251 00ef 3B       		.uleb128 0x3b
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 69


 2252 00f0 05       		.uleb128 0x5
 2253 00f1 27       		.uleb128 0x27
 2254 00f2 19       		.uleb128 0x19
 2255 00f3 49       		.uleb128 0x49
 2256 00f4 13       		.uleb128 0x13
 2257 00f5 11       		.uleb128 0x11
 2258 00f6 01       		.uleb128 0x1
 2259 00f7 12       		.uleb128 0x12
 2260 00f8 06       		.uleb128 0x6
 2261 00f9 40       		.uleb128 0x40
 2262 00fa 18       		.uleb128 0x18
 2263 00fb 9742     		.uleb128 0x2117
 2264 00fd 19       		.uleb128 0x19
 2265 00fe 01       		.uleb128 0x1
 2266 00ff 13       		.uleb128 0x13
 2267 0100 00       		.byte	0
 2268 0101 00       		.byte	0
 2269 0102 0F       		.uleb128 0xf
 2270 0103 34       		.uleb128 0x34
 2271 0104 00       		.byte	0
 2272 0105 03       		.uleb128 0x3
 2273 0106 0E       		.uleb128 0xe
 2274 0107 3A       		.uleb128 0x3a
 2275 0108 0B       		.uleb128 0xb
 2276 0109 3B       		.uleb128 0x3b
 2277 010a 05       		.uleb128 0x5
 2278 010b 49       		.uleb128 0x49
 2279 010c 13       		.uleb128 0x13
 2280 010d 02       		.uleb128 0x2
 2281 010e 18       		.uleb128 0x18
 2282 010f 00       		.byte	0
 2283 0110 00       		.byte	0
 2284 0111 10       		.uleb128 0x10
 2285 0112 2E       		.uleb128 0x2e
 2286 0113 00       		.byte	0
 2287 0114 3F       		.uleb128 0x3f
 2288 0115 19       		.uleb128 0x19
 2289 0116 03       		.uleb128 0x3
 2290 0117 0E       		.uleb128 0xe
 2291 0118 3A       		.uleb128 0x3a
 2292 0119 0B       		.uleb128 0xb
 2293 011a 3B       		.uleb128 0x3b
 2294 011b 05       		.uleb128 0x5
 2295 011c 27       		.uleb128 0x27
 2296 011d 19       		.uleb128 0x19
 2297 011e 49       		.uleb128 0x49
 2298 011f 13       		.uleb128 0x13
 2299 0120 11       		.uleb128 0x11
 2300 0121 01       		.uleb128 0x1
 2301 0122 12       		.uleb128 0x12
 2302 0123 06       		.uleb128 0x6
 2303 0124 40       		.uleb128 0x40
 2304 0125 18       		.uleb128 0x18
 2305 0126 9642     		.uleb128 0x2116
 2306 0128 19       		.uleb128 0x19
 2307 0129 00       		.byte	0
 2308 012a 00       		.byte	0
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 70


 2309 012b 11       		.uleb128 0x11
 2310 012c 2E       		.uleb128 0x2e
 2311 012d 01       		.byte	0x1
 2312 012e 3F       		.uleb128 0x3f
 2313 012f 19       		.uleb128 0x19
 2314 0130 03       		.uleb128 0x3
 2315 0131 0E       		.uleb128 0xe
 2316 0132 3A       		.uleb128 0x3a
 2317 0133 0B       		.uleb128 0xb
 2318 0134 3B       		.uleb128 0x3b
 2319 0135 05       		.uleb128 0x5
 2320 0136 27       		.uleb128 0x27
 2321 0137 19       		.uleb128 0x19
 2322 0138 11       		.uleb128 0x11
 2323 0139 01       		.uleb128 0x1
 2324 013a 12       		.uleb128 0x12
 2325 013b 06       		.uleb128 0x6
 2326 013c 40       		.uleb128 0x40
 2327 013d 18       		.uleb128 0x18
 2328 013e 9642     		.uleb128 0x2116
 2329 0140 19       		.uleb128 0x19
 2330 0141 01       		.uleb128 0x1
 2331 0142 13       		.uleb128 0x13
 2332 0143 00       		.byte	0
 2333 0144 00       		.byte	0
 2334 0145 12       		.uleb128 0x12
 2335 0146 0F       		.uleb128 0xf
 2336 0147 00       		.byte	0
 2337 0148 0B       		.uleb128 0xb
 2338 0149 0B       		.uleb128 0xb
 2339 014a 49       		.uleb128 0x49
 2340 014b 13       		.uleb128 0x13
 2341 014c 00       		.byte	0
 2342 014d 00       		.byte	0
 2343 014e 13       		.uleb128 0x13
 2344 014f 26       		.uleb128 0x26
 2345 0150 00       		.byte	0
 2346 0151 49       		.uleb128 0x49
 2347 0152 13       		.uleb128 0x13
 2348 0153 00       		.byte	0
 2349 0154 00       		.byte	0
 2350 0155 14       		.uleb128 0x14
 2351 0156 0B       		.uleb128 0xb
 2352 0157 01       		.byte	0x1
 2353 0158 11       		.uleb128 0x11
 2354 0159 01       		.uleb128 0x1
 2355 015a 12       		.uleb128 0x12
 2356 015b 06       		.uleb128 0x6
 2357 015c 00       		.byte	0
 2358 015d 00       		.byte	0
 2359 015e 15       		.uleb128 0x15
 2360 015f 34       		.uleb128 0x34
 2361 0160 00       		.byte	0
 2362 0161 03       		.uleb128 0x3
 2363 0162 0E       		.uleb128 0xe
 2364 0163 3A       		.uleb128 0x3a
 2365 0164 0B       		.uleb128 0xb
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 71


 2366 0165 3B       		.uleb128 0x3b
 2367 0166 0B       		.uleb128 0xb
 2368 0167 49       		.uleb128 0x49
 2369 0168 13       		.uleb128 0x13
 2370 0169 3F       		.uleb128 0x3f
 2371 016a 19       		.uleb128 0x19
 2372 016b 02       		.uleb128 0x2
 2373 016c 18       		.uleb128 0x18
 2374 016d 00       		.byte	0
 2375 016e 00       		.byte	0
 2376 016f 00       		.byte	0
 2377              		.section	.debug_aranges,"",%progbits
 2378 0000 EC000000 		.4byte	0xec
 2379 0004 0200     		.2byte	0x2
 2380 0006 00000000 		.4byte	.Ldebug_info0
 2381 000a 04       		.byte	0x4
 2382 000b 00       		.byte	0
 2383 000c 0000     		.2byte	0
 2384 000e 0000     		.2byte	0
 2385 0010 00000000 		.4byte	.LFB0
 2386 0014 24000000 		.4byte	.LFE0-.LFB0
 2387 0018 00000000 		.4byte	.LFB1
 2388 001c 3C000000 		.4byte	.LFE1-.LFB1
 2389 0020 00000000 		.4byte	.LFB2
 2390 0024 60000000 		.4byte	.LFE2-.LFB2
 2391 0028 00000000 		.4byte	.LFB3
 2392 002c 60000000 		.4byte	.LFE3-.LFB3
 2393 0030 00000000 		.4byte	.LFB4
 2394 0034 0C000000 		.4byte	.LFE4-.LFB4
 2395 0038 00000000 		.4byte	.LFB5
 2396 003c 12000000 		.4byte	.LFE5-.LFB5
 2397 0040 00000000 		.4byte	.LFB6
 2398 0044 20000000 		.4byte	.LFE6-.LFB6
 2399 0048 00000000 		.4byte	.LFB7
 2400 004c 20000000 		.4byte	.LFE7-.LFB7
 2401 0050 00000000 		.4byte	.LFB8
 2402 0054 24000000 		.4byte	.LFE8-.LFB8
 2403 0058 00000000 		.4byte	.LFB9
 2404 005c 4C000000 		.4byte	.LFE9-.LFB9
 2405 0060 00000000 		.4byte	.LFB10
 2406 0064 22000000 		.4byte	.LFE10-.LFB10
 2407 0068 00000000 		.4byte	.LFB11
 2408 006c 30000000 		.4byte	.LFE11-.LFB11
 2409 0070 00000000 		.4byte	.LFB12
 2410 0074 44000000 		.4byte	.LFE12-.LFB12
 2411 0078 00000000 		.4byte	.LFB13
 2412 007c 12000000 		.4byte	.LFE13-.LFB13
 2413 0080 00000000 		.4byte	.LFB14
 2414 0084 20000000 		.4byte	.LFE14-.LFB14
 2415 0088 00000000 		.4byte	.LFB15
 2416 008c 20000000 		.4byte	.LFE15-.LFB15
 2417 0090 00000000 		.4byte	.LFB16
 2418 0094 20000000 		.4byte	.LFE16-.LFB16
 2419 0098 00000000 		.4byte	.LFB17
 2420 009c 2C000000 		.4byte	.LFE17-.LFB17
 2421 00a0 00000000 		.4byte	.LFB18
 2422 00a4 14000000 		.4byte	.LFE18-.LFB18
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 72


 2423 00a8 00000000 		.4byte	.LFB19
 2424 00ac 34000000 		.4byte	.LFE19-.LFB19
 2425 00b0 00000000 		.4byte	.LFB20
 2426 00b4 54000000 		.4byte	.LFE20-.LFB20
 2427 00b8 00000000 		.4byte	.LFB21
 2428 00bc 58000000 		.4byte	.LFE21-.LFB21
 2429 00c0 00000000 		.4byte	.LFB22
 2430 00c4 34000000 		.4byte	.LFE22-.LFB22
 2431 00c8 00000000 		.4byte	.LFB23
 2432 00cc 48000000 		.4byte	.LFE23-.LFB23
 2433 00d0 00000000 		.4byte	.LFB24
 2434 00d4 44000000 		.4byte	.LFE24-.LFB24
 2435 00d8 00000000 		.4byte	.LFB25
 2436 00dc B8000000 		.4byte	.LFE25-.LFB25
 2437 00e0 00000000 		.4byte	.LFB26
 2438 00e4 12000000 		.4byte	.LFE26-.LFB26
 2439 00e8 00000000 		.4byte	0
 2440 00ec 00000000 		.4byte	0
 2441              		.section	.debug_ranges,"",%progbits
 2442              	.Ldebug_ranges0:
 2443 0000 00000000 		.4byte	.LFB0
 2444 0004 24000000 		.4byte	.LFE0
 2445 0008 00000000 		.4byte	.LFB1
 2446 000c 3C000000 		.4byte	.LFE1
 2447 0010 00000000 		.4byte	.LFB2
 2448 0014 60000000 		.4byte	.LFE2
 2449 0018 00000000 		.4byte	.LFB3
 2450 001c 60000000 		.4byte	.LFE3
 2451 0020 00000000 		.4byte	.LFB4
 2452 0024 0C000000 		.4byte	.LFE4
 2453 0028 00000000 		.4byte	.LFB5
 2454 002c 12000000 		.4byte	.LFE5
 2455 0030 00000000 		.4byte	.LFB6
 2456 0034 20000000 		.4byte	.LFE6
 2457 0038 00000000 		.4byte	.LFB7
 2458 003c 20000000 		.4byte	.LFE7
 2459 0040 00000000 		.4byte	.LFB8
 2460 0044 24000000 		.4byte	.LFE8
 2461 0048 00000000 		.4byte	.LFB9
 2462 004c 4C000000 		.4byte	.LFE9
 2463 0050 00000000 		.4byte	.LFB10
 2464 0054 22000000 		.4byte	.LFE10
 2465 0058 00000000 		.4byte	.LFB11
 2466 005c 30000000 		.4byte	.LFE11
 2467 0060 00000000 		.4byte	.LFB12
 2468 0064 44000000 		.4byte	.LFE12
 2469 0068 00000000 		.4byte	.LFB13
 2470 006c 12000000 		.4byte	.LFE13
 2471 0070 00000000 		.4byte	.LFB14
 2472 0074 20000000 		.4byte	.LFE14
 2473 0078 00000000 		.4byte	.LFB15
 2474 007c 20000000 		.4byte	.LFE15
 2475 0080 00000000 		.4byte	.LFB16
 2476 0084 20000000 		.4byte	.LFE16
 2477 0088 00000000 		.4byte	.LFB17
 2478 008c 2C000000 		.4byte	.LFE17
 2479 0090 00000000 		.4byte	.LFB18
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 73


 2480 0094 14000000 		.4byte	.LFE18
 2481 0098 00000000 		.4byte	.LFB19
 2482 009c 34000000 		.4byte	.LFE19
 2483 00a0 00000000 		.4byte	.LFB20
 2484 00a4 54000000 		.4byte	.LFE20
 2485 00a8 00000000 		.4byte	.LFB21
 2486 00ac 58000000 		.4byte	.LFE21
 2487 00b0 00000000 		.4byte	.LFB22
 2488 00b4 34000000 		.4byte	.LFE22
 2489 00b8 00000000 		.4byte	.LFB23
 2490 00bc 48000000 		.4byte	.LFE23
 2491 00c0 00000000 		.4byte	.LFB24
 2492 00c4 44000000 		.4byte	.LFE24
 2493 00c8 00000000 		.4byte	.LFB25
 2494 00cc B8000000 		.4byte	.LFE25
 2495 00d0 00000000 		.4byte	.LFB26
 2496 00d4 12000000 		.4byte	.LFE26
 2497 00d8 00000000 		.4byte	0
 2498 00dc 00000000 		.4byte	0
 2499              		.section	.debug_line,"",%progbits
 2500              	.Ldebug_line0:
 2501 0000 ED020000 		.section	.debug_str,"MS",%progbits,1
 2501      02004500 
 2501      00000201 
 2501      FB0E0D00 
 2501      01010101 
 2502              	.LASF10:
 2503 0000 75696E74 		.ascii	"uint16\000"
 2503      313600
 2504              	.LASF54:
 2505 0007 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 2505      5F315F43 
 2505      6C656172 
 2505      54784275 
 2505      66666572 
 2506              	.LASF44:
 2507 001c 74784461 		.ascii	"txDataByte\000"
 2507      74614279 
 2507      746500
 2508              	.LASF46:
 2509 0027 55415254 		.ascii	"UART_1_PutChar\000"
 2509      5F315F50 
 2509      75744368 
 2509      617200
 2510              	.LASF48:
 2511 0036 73747269 		.ascii	"string\000"
 2511      6E6700
 2512              	.LASF55:
 2513 003d 55415254 		.ascii	"UART_1_SendBreak\000"
 2513      5F315F53 
 2513      656E6442 
 2513      7265616B 
 2513      00
 2514              	.LASF27:
 2515 004e 55415254 		.ascii	"UART_1_ReadRxData\000"
 2515      5F315F52 
 2515      65616452 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 74


 2515      78446174 
 2515      6100
 2516              	.LASF7:
 2517 0060 6C6F6E67 		.ascii	"long long unsigned int\000"
 2517      206C6F6E 
 2517      6720756E 
 2517      7369676E 
 2517      65642069 
 2518              	.LASF53:
 2519 0077 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 2519      5F315F47 
 2519      65745478 
 2519      42756666 
 2519      65725369 
 2520              	.LASF6:
 2521 008e 6C6F6E67 		.ascii	"long long int\000"
 2521      206C6F6E 
 2521      6720696E 
 2521      7400
 2522              	.LASF0:
 2523 009c 7369676E 		.ascii	"signed char\000"
 2523      65642063 
 2523      68617200 
 2524              	.LASF52:
 2525 00a8 55415254 		.ascii	"UART_1_PutCRLF\000"
 2525      5F315F50 
 2525      75744352 
 2525      4C4600
 2526              	.LASF4:
 2527 00b7 6C6F6E67 		.ascii	"long int\000"
 2527      20696E74 
 2527      00
 2528              	.LASF17:
 2529 00c0 55415254 		.ascii	"UART_1_Start\000"
 2529      5F315F53 
 2529      74617274 
 2529      00
 2530              	.LASF9:
 2531 00cd 75696E74 		.ascii	"uint8\000"
 2531      3800
 2532              	.LASF12:
 2533 00d3 646F7562 		.ascii	"double\000"
 2533      6C6500
 2534              	.LASF38:
 2535 00da 61646472 		.ascii	"addressMode\000"
 2535      6573734D 
 2535      6F646500 
 2536              	.LASF61:
 2537 00e6 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART_1.c\000"
 2537      6E657261 
 2537      7465645F 
 2537      536F7572 
 2537      63655C50 
 2538              	.LASF24:
 2539 0108 636F6E74 		.ascii	"control\000"
 2539      726F6C00 
 2540              	.LASF23:
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 75


 2541 0110 55415254 		.ascii	"UART_1_SetRxInterruptMode\000"
 2541      5F315F53 
 2541      65745278 
 2541      496E7465 
 2541      72727570 
 2542              	.LASF56:
 2543 012a 7265744D 		.ascii	"retMode\000"
 2543      6F646500 
 2544              	.LASF8:
 2545 0132 756E7369 		.ascii	"unsigned int\000"
 2545      676E6564 
 2545      20696E74 
 2545      00
 2546              	.LASF45:
 2547 013f 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 2547      5F315F52 
 2547      65616454 
 2547      78537461 
 2547      74757300 
 2548              	.LASF5:
 2549 0153 6C6F6E67 		.ascii	"long unsigned int\000"
 2549      20756E73 
 2549      69676E65 
 2549      6420696E 
 2549      7400
 2550              	.LASF35:
 2551 0165 73697A65 		.ascii	"size\000"
 2551      00
 2552              	.LASF3:
 2553 016a 73686F72 		.ascii	"short unsigned int\000"
 2553      7420756E 
 2553      7369676E 
 2553      65642069 
 2553      6E7400
 2554              	.LASF19:
 2555 017d 55415254 		.ascii	"UART_1_Enable\000"
 2555      5F315F45 
 2555      6E61626C 
 2555      6500
 2556              	.LASF59:
 2557 018b 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 2557      5F315F53 
 2557      65745478 
 2557      41646472 
 2557      6573734D 
 2558              	.LASF58:
 2559 01a3 74785F70 		.ascii	"tx_period\000"
 2559      6572696F 
 2559      6400
 2560              	.LASF25:
 2561 01ad 696E7453 		.ascii	"intSrc\000"
 2561      726300
 2562              	.LASF32:
 2563 01b4 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 2563      5F315F52 
 2563      65616443 
 2563      6F6E7472 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 76


 2563      6F6C5265 
 2564              	.LASF20:
 2565 01cf 55415254 		.ascii	"UART_1_Stop\000"
 2565      5F315F53 
 2565      746F7000 
 2566              	.LASF33:
 2567 01db 55415254 		.ascii	"UART_1_GetByte\000"
 2567      5F315F47 
 2567      65744279 
 2567      746500
 2568              	.LASF47:
 2569 01ea 55415254 		.ascii	"UART_1_PutString\000"
 2569      5F315F50 
 2569      75745374 
 2569      72696E67 
 2569      00
 2570              	.LASF43:
 2571 01fb 55415254 		.ascii	"UART_1_WriteTxData\000"
 2571      5F315F57 
 2571      72697465 
 2571      54784461 
 2571      746100
 2572              	.LASF57:
 2573 020e 746D7053 		.ascii	"tmpStat\000"
 2573      74617400 
 2574              	.LASF16:
 2575 0216 73697A65 		.ascii	"sizetype\000"
 2575      74797065 
 2575      00
 2576              	.LASF62:
 2577 021f 433A5C55 		.ascii	"C:\\Users\\Christina\\Documents\\GitHub\\Shifting\\"
 2577      73657273 
 2577      5C436872 
 2577      69737469 
 2577      6E615C44 
 2578 024c 53686966 		.ascii	"Shifting\\Shifting.cydsn\000"
 2578      74696E67 
 2578      5C536869 
 2578      6674696E 
 2578      672E6379 
 2579              	.LASF41:
 2580 0264 55415254 		.ascii	"UART_1_SetRxAddress2\000"
 2580      5F315F53 
 2580      65745278 
 2580      41646472 
 2580      65737332 
 2581              	.LASF40:
 2582 0279 61646472 		.ascii	"address\000"
 2582      65737300 
 2583              	.LASF39:
 2584 0281 55415254 		.ascii	"UART_1_SetRxAddress1\000"
 2584      5F315F53 
 2584      65745278 
 2584      41646472 
 2584      65737331 
 2585              	.LASF31:
 2586 0296 72785374 		.ascii	"rxStatus\000"
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 77


 2586      61747573 
 2586      00
 2587              	.LASF42:
 2588 029f 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 2588      5F315F53 
 2588      65745478 
 2588      496E7465 
 2588      72727570 
 2589              	.LASF11:
 2590 02b9 666C6F61 		.ascii	"float\000"
 2590      7400
 2591              	.LASF60:
 2592 02bf 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 2592      4320342E 
 2592      382E3420 
 2592      32303134 
 2592      30353236 
 2593 02f2 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m0 -mthumb -g -O"
 2593      20726576 
 2593      6973696F 
 2593      6E203231 
 2593      31333538 
 2594 0325 30202D66 		.ascii	"0 -ffunction-sections\000"
 2594      66756E63 
 2594      74696F6E 
 2594      2D736563 
 2594      74696F6E 
 2595              	.LASF36:
 2596 033b 55415254 		.ascii	"UART_1_ClearRxBuffer\000"
 2596      5F315F43 
 2596      6C656172 
 2596      52784275 
 2596      66666572 
 2597              	.LASF37:
 2598 0350 55415254 		.ascii	"UART_1_SetRxAddressMode\000"
 2598      5F315F53 
 2598      65745278 
 2598      41646472 
 2598      6573734D 
 2599              	.LASF15:
 2600 0368 72656738 		.ascii	"reg8\000"
 2600      00
 2601              	.LASF1:
 2602 036d 756E7369 		.ascii	"unsigned char\000"
 2602      676E6564 
 2602      20636861 
 2602      7200
 2603              	.LASF2:
 2604 037b 73686F72 		.ascii	"short int\000"
 2604      7420696E 
 2604      7400
 2605              	.LASF22:
 2606 0385 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 2606      5F315F57 
 2606      72697465 
 2606      436F6E74 
 2606      726F6C52 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 78


 2607              	.LASF63:
 2608 03a1 55415254 		.ascii	"UART_1_initVar\000"
 2608      5F315F69 
 2608      6E697456 
 2608      617200
 2609              	.LASF51:
 2610 03b0 62797465 		.ascii	"byteCount\000"
 2610      436F756E 
 2610      7400
 2611              	.LASF34:
 2612 03ba 55415254 		.ascii	"UART_1_GetRxBufferSize\000"
 2612      5F315F47 
 2612      65745278 
 2612      42756666 
 2612      65725369 
 2613              	.LASF26:
 2614 03d1 72784461 		.ascii	"rxData\000"
 2614      746100
 2615              	.LASF14:
 2616 03d8 63686172 		.ascii	"char\000"
 2616      00
 2617              	.LASF13:
 2618 03dd 63686172 		.ascii	"char8\000"
 2618      3800
 2619              	.LASF18:
 2620 03e3 55415254 		.ascii	"UART_1_Init\000"
 2620      5F315F49 
 2620      6E697400 
 2621              	.LASF21:
 2622 03ef 656E6162 		.ascii	"enableInterrupts\000"
 2622      6C65496E 
 2622      74657272 
 2622      75707473 
 2622      00
 2623              	.LASF29:
 2624 0400 73746174 		.ascii	"status\000"
 2624      757300
 2625              	.LASF28:
 2626 0407 55415254 		.ascii	"UART_1_ReadRxStatus\000"
 2626      5F315F52 
 2626      65616452 
 2626      78537461 
 2626      74757300 
 2627              	.LASF30:
 2628 041b 55415254 		.ascii	"UART_1_GetChar\000"
 2628      5F315F47 
 2628      65744368 
 2628      617200
 2629              	.LASF49:
 2630 042a 6275665F 		.ascii	"buf_index\000"
 2630      696E6465 
 2630      7800
 2631              	.LASF50:
 2632 0434 55415254 		.ascii	"UART_1_PutArray\000"
 2632      5F315F50 
 2632      75744172 
 2632      72617900 
ARM GAS  C:\Users\CHRIST~1\AppData\Local\Temp\ccoSejAz.s 			page 79


 2633              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
