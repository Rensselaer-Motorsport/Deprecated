C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBUART_1
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\USBUART_1.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBUART_1.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051_Keil_951\Debug\USBUART_1.lst) CD DB NOIP O
                    -T(2,SIZE) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051_Keil_951\Debug\USBUART_1.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: USBUART_1.c
   3          * Version 2.70
   4          *
   5          * Description:
   6          *  API for USBFS Component.
   7          *
   8          * Note:
   9          *  Many of the functions use endpoint number.  RAM arrays are sized with 9
  10          *  elements so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * Copyright 2008-2013, Cypress Semiconductor Corporation.  All rights reserved.
  15          * You may use this file only in accordance with the license, terms, conditions,
  16          * disclaimers, and limitations in the end user license agreement accompanying
  17          * the software package with which this file was provided.
  18          *******************************************************************************/
  19          
  20          #include <CyDmac.h>
  21          #include "USBUART_1.h"
  22          #include "USBUART_1_pvt.h"
  23          #include "USBUART_1_hid.h"
  24          #if(USBUART_1_DMA1_REMOVE == 0u)
                  #include "USBUART_1_ep1_dma.h"
              #endif   /*  USBUART_1_DMA1_REMOVE */
  27          #if(USBUART_1_DMA2_REMOVE == 0u)
                  #include "USBUART_1_ep2_dma.h"
              #endif   /*  USBUART_1_DMA2_REMOVE */
  30          #if(USBUART_1_DMA3_REMOVE == 0u)
                  #include "USBUART_1_ep3_dma.h"
              #endif   /*  USBUART_1_DMA3_REMOVE */
  33          #if(USBUART_1_DMA4_REMOVE == 0u)
                  #include "USBUART_1_ep4_dma.h"
              #endif   /*  USBUART_1_DMA4_REMOVE */
  36          #if(USBUART_1_DMA5_REMOVE == 0u)
                  #include "USBUART_1_ep5_dma.h"
              #endif   /*  USBUART_1_DMA5_REMOVE */
  39          #if(USBUART_1_DMA6_REMOVE == 0u)
                  #include "USBUART_1_ep6_dma.h"
              #endif   /*  USBUART_1_DMA6_REMOVE */
  42          #if(USBUART_1_DMA7_REMOVE == 0u)
                  #include "USBUART_1_ep7_dma.h"
              #endif   /*  USBUART_1_DMA7_REMOVE */
  45          #if(USBUART_1_DMA8_REMOVE == 0u)
                  #include "USBUART_1_ep8_dma.h"
              #endif   /*  USBUART_1_DMA8_REMOVE */
  48          #if((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u))
                  #include "USBUART_1_EP_DMA_Done_isr.h"
                  #include "USBUART_1_EP8_DMA_Done_SR.h"
                  #include "USBUART_1_EP17_DMA_Done_SR.h"
              #endif /* ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u)) */
  53          
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 2   

  54          
  55          /***************************************
  56          * Global data allocation
  57          ***************************************/
  58          
  59          uint8 USBUART_1_initVar = 0u;
  60          #if(USBUART_1_EP_MM != USBUART_1__EP_MANUAL)
                  uint8 USBUART_1_DmaChan[USBUART_1_MAX_EP];
                  uint8 USBUART_1_DmaTd[USBUART_1_MAX_EP];
              #endif /*  USBUART_1_EP_MM */
  64          #if((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u))
                  static uint8 clearInDataRdyStatus = USBUART_1_ARB_EPX_CFG_DEFAULT;
                  uint8 USBUART_1_DmaNextTd[USBUART_1_MAX_EP];
                  const uint8 USBUART_1_epX_TD_TERMOUT_EN[USBUART_1_MAX_EP] =
                  {   0u,
                      USBUART_1_ep1_TD_TERMOUT_EN,
                      USBUART_1_ep2_TD_TERMOUT_EN,
                      USBUART_1_ep3_TD_TERMOUT_EN,
                      USBUART_1_ep4_TD_TERMOUT_EN,
                      USBUART_1_ep5_TD_TERMOUT_EN,
                      USBUART_1_ep6_TD_TERMOUT_EN,
                      USBUART_1_ep7_TD_TERMOUT_EN,
                      USBUART_1_ep8_TD_TERMOUT_EN
                  };
                  volatile uint16 USBUART_1_inLength[USBUART_1_MAX_EP];
                  const uint8 *USBUART_1_inDataPointer[USBUART_1_MAX_EP];
                  volatile uint8 USBUART_1_inBufFull[USBUART_1_MAX_EP];
              #endif /* ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u)) */
  82          
  83          
  84          /*******************************************************************************
  85          * Function Name: USBUART_1_Start
  86          ********************************************************************************
  87          *
  88          * Summary:
  89          *  This function initialize the USB SIE, arbiter and the
  90          *  endpoint APIs, including setting the D+ Pullup
  91          *
  92          * Parameters:
  93          *  device: Contains the device number of the desired device descriptor.
  94          *          The device number can be found in the Device Descriptor Tab of
  95          *          "Configure" dialog, under the settings of desired Device Descriptor,
  96          *          in the "Device Number" field.
  97          *  mode: The operating voltage. This determines whether the voltage regulator
  98          *        is enabled for 5V operation or if pass through mode is used for 3.3V
  99          *        operation. Symbolic names and their associated values are given in the
 100          *        following table.
 101          *       USBUART_1_3V_OPERATION - Disable voltage regulator and pass-thru
 102          *                                       Vcc for pull-up
 103          *       USBUART_1_5V_OPERATION - Enable voltage regulator and use
 104          *                                       regulator for pull-up
 105          *       USBUART_1_DWR_VDDD_OPERATION - Enable or Disable voltage
 106          *                         regulator depend on Vddd Voltage configuration in DWR.
 107          *
 108          * Return:
 109          *   None.
 110          *
 111          * Global variables:
 112          *  The USBUART_1_intiVar variable is used to indicate initial
 113          *  configuration of this component. The variable is initialized to zero (0u)
 114          *  and set to one (1u) the first time USBUART_1_Start() is called.
 115          *  This allows for component Re-Start without unnecessary re-initialization
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 3   

 116          *  in all subsequent calls to the USBUART_1_Start() routine.
 117          *  If re-initialization of the component is required the variable should be set
 118          *  to zero before call of UART_Start() routine, or the user may call
 119          *  USBUART_1_Init() and USBUART_1_InitComponent() as done
 120          *  in the USBUART_1_Start() routine.
 121          *
 122          * Side Effects:
 123          *   This function will reset all communication states to default.
 124          *
 125          * Reentrant:
 126          *  No.
 127          *
 128          *******************************************************************************/
 129          void USBUART_1_Start(uint8 device, uint8 mode) 
 130          {
 131   1          /* If not Initialized then initialize all required hardware and software */
 132   1          if(USBUART_1_initVar == 0u)
 133   1          {
 134   2              USBUART_1_Init();
 135   2              USBUART_1_initVar = 1u;
 136   2          }
 137   1          USBUART_1_InitComponent(device, mode);
 138   1      }
 139          
 140          
 141          /*******************************************************************************
 142          * Function Name: USBUART_1_Init
 143          ********************************************************************************
 144          *
 145          * Summary:
 146          *  Initialize component's hardware. Usually called in USBUART_1_Start().
 147          *
 148          * Parameters:
 149          *  None.
 150          *
 151          * Return:
 152          *  None.
 153          *
 154          * Reentrant:
 155          *  No.
 156          *
 157          *******************************************************************************/
 158          void USBUART_1_Init(void) 
 159          {
 160   1          uint8 enableInterrupts;
 161   1          #if(USBUART_1_EP_MM != USBUART_1__EP_MANUAL)
                      uint16 i;
                  #endif   /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 164   1      
 165   1          enableInterrupts = CyEnterCriticalSection();
 166   1      
 167   1          /* Enable USB block  */
 168   1          USBUART_1_PM_ACT_CFG_REG |= USBUART_1_PM_ACT_EN_FSUSB;
 169   1          /* Enable USB block for Standby Power Mode */
 170   1          USBUART_1_PM_STBY_CFG_REG |= USBUART_1_PM_STBY_EN_FSUSB;
 171   1      
 172   1          /* Enable core clock */
 173   1          USBUART_1_USB_CLK_EN_REG = USBUART_1_USB_CLK_ENABLE;
 174   1      
 175   1          USBUART_1_CR1_REG = USBUART_1_CR1_ENABLE_LOCK;
 176   1      
 177   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE */
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 4   

 178   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled */
 179   1          USBUART_1_USBIO_CR0_REG &= ((uint8)(~USBUART_1_USBIO_CR0_TEN));
 180   1          CyDelayUs(0u);  /*~50ns delay */
 181   1          /* Disable the USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted)
 182   1          *  high. This will have been set low by the power manger out of reset.
 183   1          *  Also confirm USBIO pull-up disabled
 184   1          */
 185   1          USBUART_1_PM_USB_CR0_REG &= ((uint8)(~(USBUART_1_PM_USB_CR0_PD_N |
 186   1                                                        USBUART_1_PM_USB_CR0_PD_PULLUP_N)));
 187   1      
 188   1          /* Select iomode to USB mode*/
 189   1          USBUART_1_USBIO_CR1_REG &= ((uint8)(~USBUART_1_USBIO_CR1_IOMODE));
 190   1      
 191   1          /* Enable the USBIO reference by setting PM.USB_CR0.fsusbio_ref_en.*/
 192   1          USBUART_1_PM_USB_CR0_REG |= USBUART_1_PM_USB_CR0_REF_EN;
 193   1          /* The reference will be available 1 us after the regulator is enabled */
 194   1          CyDelayUs(1u);
 195   1          /* OR 40us after power restored */
 196   1          CyDelayUs(40u);
 197   1          /* Ensure the single ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 198   1          USBUART_1_DM_INP_DIS_REG &= ((uint8)(~USBUART_1_DM_MASK));
 199   1          USBUART_1_DP_INP_DIS_REG &= ((uint8)(~USBUART_1_DP_MASK));
 200   1      
 201   1          /* Enable USBIO */
 202   1          USBUART_1_PM_USB_CR0_REG |= USBUART_1_PM_USB_CR0_PD_N;
 203   1          CyDelayUs(2u);
 204   1          /* Set the USBIO pull-up enable */
 205   1          USBUART_1_PM_USB_CR0_REG |= USBUART_1_PM_USB_CR0_PD_PULLUP_N;
 206   1      
 207   1          /* Write WAx */
 208   1          CY_SET_REG8(USBUART_1_ARB_RW1_WA_PTR,     0u);
 209   1          CY_SET_REG8(USBUART_1_ARB_RW1_WA_MSB_PTR, 0u);
 210   1      
 211   1          #if(USBUART_1_EP_MM != USBUART_1__EP_MANUAL)
                      /* Init transfer descriptor. This will be used to detect the DMA state - initialized or not. */
                      for (i = 0u; i < USBUART_1_MAX_EP; i++)
                      {
                          USBUART_1_DmaTd[i] = DMA_INVALID_TD;
                          #if ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u))
                              USBUART_1_DmaNextTd[i] = DMA_INVALID_TD;
                          #endif /* ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  #endif   /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      
 224   1      
 225   1          /* Set the bus reset Interrupt. */
 226   1          (void) CyIntSetVector(USBUART_1_BUS_RESET_VECT_NUM,   &USBUART_1_BUS_RESET_ISR);
 227   1          CyIntSetPriority(USBUART_1_BUS_RESET_VECT_NUM, USBUART_1_BUS_RESET_PRIOR);
 228   1      
 229   1          /* Set the SOF Interrupt. */
 230   1          #if(USBUART_1_SOF_ISR_REMOVE == 0u)
 231   1              (void) CyIntSetVector(USBUART_1_SOF_VECT_NUM,   &USBUART_1_SOF_ISR);
 232   1              CyIntSetPriority(USBUART_1_SOF_VECT_NUM, USBUART_1_SOF_PRIOR);
 233   1          #endif   /*  USBUART_1_SOF_ISR_REMOVE */
 234   1      
 235   1          /* Set the Control Endpoint Interrupt. */
 236   1          (void) CyIntSetVector(USBUART_1_EP_0_VECT_NUM,   &USBUART_1_EP_0_ISR);
 237   1          CyIntSetPriority(USBUART_1_EP_0_VECT_NUM, USBUART_1_EP_0_PRIOR);
 238   1      
 239   1          /* Set the Data Endpoint 1 Interrupt. */
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 5   

 240   1          #if(USBUART_1_EP1_ISR_REMOVE == 0u)
 241   1              (void) CyIntSetVector(USBUART_1_EP_1_VECT_NUM,   &USBUART_1_EP_1_ISR);
 242   1              CyIntSetPriority(USBUART_1_EP_1_VECT_NUM, USBUART_1_EP_1_PRIOR);
 243   1          #endif   /*  USBUART_1_EP1_ISR_REMOVE */
 244   1      
 245   1          /* Set the Data Endpoint 2 Interrupt. */
 246   1          #if(USBUART_1_EP2_ISR_REMOVE == 0u)
 247   1              (void) CyIntSetVector(USBUART_1_EP_2_VECT_NUM,   &USBUART_1_EP_2_ISR);
 248   1              CyIntSetPriority(USBUART_1_EP_2_VECT_NUM, USBUART_1_EP_2_PRIOR);
 249   1          #endif   /*  USBUART_1_EP2_ISR_REMOVE */
 250   1      
 251   1          /* Set the Data Endpoint 3 Interrupt. */
 252   1          #if(USBUART_1_EP3_ISR_REMOVE == 0u)
 253   1              (void) CyIntSetVector(USBUART_1_EP_3_VECT_NUM,   &USBUART_1_EP_3_ISR);
 254   1              CyIntSetPriority(USBUART_1_EP_3_VECT_NUM, USBUART_1_EP_3_PRIOR);
 255   1          #endif   /*  USBUART_1_EP3_ISR_REMOVE */
 256   1      
 257   1          /* Set the Data Endpoint 4 Interrupt. */
 258   1          #if(USBUART_1_EP4_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBUART_1_EP_4_VECT_NUM,   &USBUART_1_EP_4_ISR);
                      CyIntSetPriority(USBUART_1_EP_4_VECT_NUM, USBUART_1_EP_4_PRIOR);
                  #endif   /*  USBUART_1_EP4_ISR_REMOVE */
 262   1      
 263   1          /* Set the Data Endpoint 5 Interrupt. */
 264   1          #if(USBUART_1_EP5_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBUART_1_EP_5_VECT_NUM,   &USBUART_1_EP_5_ISR);
                      CyIntSetPriority(USBUART_1_EP_5_VECT_NUM, USBUART_1_EP_5_PRIOR);
                  #endif   /*  USBUART_1_EP5_ISR_REMOVE */
 268   1      
 269   1          /* Set the Data Endpoint 6 Interrupt. */
 270   1          #if(USBUART_1_EP6_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBUART_1_EP_6_VECT_NUM,   &USBUART_1_EP_6_ISR);
                      CyIntSetPriority(USBUART_1_EP_6_VECT_NUM, USBUART_1_EP_6_PRIOR);
                  #endif   /*  USBUART_1_EP6_ISR_REMOVE */
 274   1      
 275   1           /* Set the Data Endpoint 7 Interrupt. */
 276   1          #if(USBUART_1_EP7_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBUART_1_EP_7_VECT_NUM,   &USBUART_1_EP_7_ISR);
                      CyIntSetPriority(USBUART_1_EP_7_VECT_NUM, USBUART_1_EP_7_PRIOR);
                  #endif   /*  USBUART_1_EP7_ISR_REMOVE */
 280   1      
 281   1          /* Set the Data Endpoint 8 Interrupt. */
 282   1          #if(USBUART_1_EP8_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBUART_1_EP_8_VECT_NUM,   &USBUART_1_EP_8_ISR);
                      CyIntSetPriority(USBUART_1_EP_8_VECT_NUM, USBUART_1_EP_8_PRIOR);
                  #endif   /*  USBUART_1_EP8_ISR_REMOVE */
 286   1      
 287   1          #if((USBUART_1_EP_MM != USBUART_1__EP_MANUAL) && (USBUART_1_ARB_ISR_REMOVE == 0u))
                      /* Set the ARB Interrupt. */
                      (void) CyIntSetVector(USBUART_1_ARB_VECT_NUM,   &USBUART_1_ARB_ISR);
                      CyIntSetPriority(USBUART_1_ARB_VECT_NUM, USBUART_1_ARB_PRIOR);
                  #endif   /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 292   1      
 293   1      }
 294          
 295          
 296          /*******************************************************************************
 297          * Function Name: USBUART_1_InitComponent
 298          ********************************************************************************
 299          *
 300          * Summary:
 301          *  Initialize the component, except for the HW which is done one time in
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 6   

 302          *  the Start function.  This function pulls up D+.
 303          *
 304          * Parameters:
 305          *  device: Contains the device number of the desired device descriptor.
 306          *          The device number can be found in the Device Descriptor Tab of
 307          *          "Configure" dialog, under the settings of desired Device Descriptor,
 308          *          in the "Device Number" field.
 309          *  mode: The operating voltage. This determines whether the voltage regulator
 310          *        is enabled for 5V operation or if pass through mode is used for 3.3V
 311          *        operation. Symbolic names and their associated values are given in the
 312          *        following table.
 313          *       USBUART_1_3V_OPERATION - Disable voltage regulator and pass-thru
 314          *                                       Vcc for pull-up
 315          *       USBUART_1_5V_OPERATION - Enable voltage regulator and use
 316          *                                       regulator for pull-up
 317          *       USBUART_1_DWR_VDDD_OPERATION - Enable or Disable voltage
 318          *                         regulator depend on Vddd Voltage configuration in DWR.
 319          *
 320          * Return:
 321          *   None.
 322          *
 323          * Global variables:
 324          *   USBUART_1_device: Contains the device number of the desired device
 325          *       descriptor. The device number can be found in the Device Descriptor Tab
 326          *       of "Configure" dialog, under the settings of desired Device Descriptor,
 327          *       in the "Device Number" field.
 328          *   USBUART_1_transferState: This variable used by the communication
 329          *       functions to handle current transfer state. Initialized to
 330          *       TRANS_STATE_IDLE in this API.
 331          *   USBUART_1_configuration: Contains current configuration number
 332          *       which is set by the Host using SET_CONFIGURATION request.
 333          *       Initialized to zero in this API.
 334          *   USBUART_1_deviceAddress: Contains current device address. This
 335          *       variable is initialized to zero in this API. Host starts to communicate
 336          *      to device with address 0 and then set it to whatever value using
 337          *      SET_ADDRESS request.
 338          *   USBUART_1_deviceStatus: initialized to 0.
 339          *       This is two bit variable which contain power status in first bit
 340          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 341          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 342          *   USBUART_1_lastPacketSize initialized to 0;
 343          *
 344          * Reentrant:
 345          *  No.
 346          *
 347          *******************************************************************************/
 348          void USBUART_1_InitComponent(uint8 device, uint8 mode) 
 349          {
 350   1          /* Initialize _hidProtocol variable to comply with
 351   1          *  HID 7.2.6 Set_Protocol Request:
 352   1          *  "When initialized, all devices default to report protocol."
 353   1          */
 354   1          #if defined(USBUART_1_ENABLE_HID_CLASS)
 355   1              uint8 i;
 356   1      
 357   1              for (i = 0u; i < USBUART_1_MAX_INTERFACES_NUMBER; i++)
 358   1              {
 359   2                  USBUART_1_hidProtocol[i] = USBUART_1_PROTOCOL_REPORT;
 360   2              }
 361   1          #endif /* USBUART_1_ENABLE_HID_CLASS */
 362   1      
 363   1          /* Enable Interrupts. */
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 7   

 364   1          CyIntEnable(USBUART_1_BUS_RESET_VECT_NUM);
 365   1          CyIntEnable(USBUART_1_EP_0_VECT_NUM);
 366   1          #if(USBUART_1_EP1_ISR_REMOVE == 0u)
 367   1              CyIntEnable(USBUART_1_EP_1_VECT_NUM);
 368   1          #endif   /*  USBUART_1_EP1_ISR_REMOVE */
 369   1          #if(USBUART_1_EP2_ISR_REMOVE == 0u)
 370   1              CyIntEnable(USBUART_1_EP_2_VECT_NUM);
 371   1          #endif   /*  USBUART_1_EP2_ISR_REMOVE */
 372   1          #if(USBUART_1_EP3_ISR_REMOVE == 0u)
 373   1              CyIntEnable(USBUART_1_EP_3_VECT_NUM);
 374   1          #endif   /*  USBUART_1_EP3_ISR_REMOVE */
 375   1          #if(USBUART_1_EP4_ISR_REMOVE == 0u)
                      CyIntEnable(USBUART_1_EP_4_VECT_NUM);
                  #endif   /*  USBUART_1_EP4_ISR_REMOVE */
 378   1          #if(USBUART_1_EP5_ISR_REMOVE == 0u)
                      CyIntEnable(USBUART_1_EP_5_VECT_NUM);
                  #endif   /*  USBUART_1_EP5_ISR_REMOVE */
 381   1          #if(USBUART_1_EP6_ISR_REMOVE == 0u)
                      CyIntEnable(USBUART_1_EP_6_VECT_NUM);
                  #endif   /*  USBUART_1_EP6_ISR_REMOVE */
 384   1          #if(USBUART_1_EP7_ISR_REMOVE == 0u)
                      CyIntEnable(USBUART_1_EP_7_VECT_NUM);
                  #endif   /*  USBUART_1_EP7_ISR_REMOVE */
 387   1          #if(USBUART_1_EP8_ISR_REMOVE == 0u)
                      CyIntEnable(USBUART_1_EP_8_VECT_NUM);
                  #endif   /*  USBUART_1_EP8_ISR_REMOVE */
 390   1          #if((USBUART_1_EP_MM != USBUART_1__EP_MANUAL) && (USBUART_1_ARB_ISR_REMOVE == 0u))
                      /* usb arb interrupt enable */
                      USBUART_1_ARB_INT_EN_REG = USBUART_1_ARB_INT_MASK;
                      CyIntEnable(USBUART_1_ARB_VECT_NUM);
                  #endif   /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 395   1      
 396   1          /* Arbiter configuration for DMA transfers */
 397   1          #if(USBUART_1_EP_MM != USBUART_1__EP_MANUAL)
                      #if(USBUART_1_EP_MM == USBUART_1__EP_DMAMANUAL)
                          USBUART_1_ARB_CFG_REG = USBUART_1_ARB_CFG_MANUAL_DMA;
                      #endif   /*  USBUART_1_EP_MM == USBUART_1__EP_DMAMANUAL */
                      #if(USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO)
                          /*Set cfg cmplt this rises DMA request when the full configuration is done */
                          USBUART_1_ARB_CFG_REG = USBUART_1_ARB_CFG_AUTO_DMA | USBUART_1_ARB_CFG_AUTO_MEM;
                          #if(USBUART_1_EP_DMA_AUTO_OPT == 0u)
                              /* Init interrupt which handles verification of the successful DMA transaction */
                              USBUART_1_EP_DMA_Done_isr_StartEx(USBUART_1_EP_DMA_DONE_ISR);
                              USBUART_1_EP17_DMA_Done_SR_InterruptEnable();
                              USBUART_1_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* USBUART_1_EP_DMA_AUTO_OPT == 0u */
                      #endif   /*  USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO */
                  #endif   /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 412   1      
 413   1          USBUART_1_transferState = USBUART_1_TRANS_STATE_IDLE;
 414   1      
 415   1          /* USB Locking: Enabled, VRegulator: depend on mode or DWR Voltage configuration*/
 416   1          switch(mode)
 417   1          {
 418   2              case USBUART_1_3V_OPERATION:
 419   2                  USBUART_1_CR1_REG = USBUART_1_CR1_ENABLE_LOCK;
 420   2                  break;
 421   2              case USBUART_1_5V_OPERATION:
 422   2                  USBUART_1_CR1_REG = USBUART_1_CR1_ENABLE_LOCK | USBUART_1_CR1_REG_ENABLE;
 423   2                  break;
 424   2              default:   /*USBUART_1_DWR_VDDD_OPERATION */
 425   2                  #if(USBUART_1_VDDD_MV < USBUART_1_3500MV)
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 8   

 426   2                      USBUART_1_CR1_REG = USBUART_1_CR1_ENABLE_LOCK;
 427   2                  #else
                              USBUART_1_CR1_REG = USBUART_1_CR1_ENABLE_LOCK | USBUART_1_CR1_REG_ENABLE;
                          #endif /*  USBUART_1_VDDD_MV < USBUART_1_3500MV */
 430   2                  break;
 431   2          }
 432   1      
 433   1          /* Record the descriptor selection */
 434   1          USBUART_1_device = device;
 435   1      
 436   1          /* Clear all of the component data */
 437   1          USBUART_1_configuration = 0u;
 438   1          USBUART_1_interfaceNumber = 0u;
 439   1          USBUART_1_configurationChanged = 0u;
 440   1          USBUART_1_deviceAddress  = 0u;
 441   1          USBUART_1_deviceStatus = 0u;
 442   1      
 443   1          USBUART_1_lastPacketSize = 0u;
 444   1      
 445   1          /*  ACK Setup, Stall IN/OUT */
 446   1          CY_SET_REG8(USBUART_1_EP0_CR_PTR, USBUART_1_MODE_STALL_IN_OUT);
 447   1      
 448   1          /* Enable the SIE with an address 0 */
 449   1          CY_SET_REG8(USBUART_1_CR0_PTR, USBUART_1_CR0_ENABLE);
 450   1      
 451   1          /* Workaround for PSOC5LP */
 452   1          CyDelayCycles(1u);
 453   1      
 454   1          /* Finally, Enable d+ pullup and select iomode to USB mode*/
 455   1          CY_SET_REG8(USBUART_1_USBIO_CR1_PTR, USBUART_1_USBIO_CR1_USBPUEN);
 456   1      }
 457          
 458          
 459          /*******************************************************************************
 460          * Function Name: USBUART_1_ReInitComponent
 461          ********************************************************************************
 462          *
 463          * Summary:
 464          *  This function reinitialize the component configuration and is
 465          *  intend to be called from the Reset interrupt.
 466          *
 467          * Parameters:
 468          *  None.
 469          *
 470          * Return:
 471          *   None.
 472          *
 473          * Global variables:
 474          *   USBUART_1_device: Contains the device number of the desired device
 475          *        descriptor. The device number can be found in the Device Descriptor Tab
 476          *       of "Configure" dialog, under the settings of desired Device Descriptor,
 477          *       in the "Device Number" field.
 478          *   USBUART_1_transferState: This variable used by the communication
 479          *       functions to handle current transfer state. Initialized to
 480          *       TRANS_STATE_IDLE in this API.
 481          *   USBUART_1_configuration: Contains current configuration number
 482          *       which is set by the Host using SET_CONFIGURATION request.
 483          *       Initialized to zero in this API.
 484          *   USBUART_1_deviceAddress: Contains current device address. This
 485          *       variable is initialized to zero in this API. Host starts to communicate
 486          *      to device with address 0 and then set it to whatever value using
 487          *      SET_ADDRESS request.
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 9   

 488          *   USBUART_1_deviceStatus: initialized to 0.
 489          *       This is two bit variable which contain power status in first bit
 490          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 491          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 492          *   USBUART_1_lastPacketSize initialized to 0;
 493          *
 494          * Reentrant:
 495          *  No.
 496          *
 497          *******************************************************************************/
 498          void USBUART_1_ReInitComponent(void) 
 499          {
 500   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
 501   1          *  Request: "When initialized, all devices default to report protocol."
 502   1          */
 503   1          #if defined(USBUART_1_ENABLE_HID_CLASS)
 504   1              uint8 i;
 505   1      
 506   1              for (i = 0u; i < USBUART_1_MAX_INTERFACES_NUMBER; i++)
 507   1              {
 508   2                  USBUART_1_hidProtocol[i] = USBUART_1_PROTOCOL_REPORT;
 509   2              }
 510   1          #endif /* USBUART_1_ENABLE_HID_CLASS */
 511   1      
 512   1          USBUART_1_transferState = USBUART_1_TRANS_STATE_IDLE;
 513   1      
 514   1          /* Clear all of the component data */
 515   1          USBUART_1_configuration = 0u;
 516   1          USBUART_1_interfaceNumber = 0u;
 517   1          USBUART_1_configurationChanged = 0u;
 518   1          USBUART_1_deviceAddress  = 0u;
 519   1          USBUART_1_deviceStatus = 0u;
 520   1      
 521   1          USBUART_1_lastPacketSize = 0u;
 522   1      
 523   1      
 524   1          /*  ACK Setup, Stall IN/OUT */
 525   1          CY_SET_REG8(USBUART_1_EP0_CR_PTR, USBUART_1_MODE_STALL_IN_OUT);
 526   1      
 527   1          /* Enable the SIE with an address 0 */
 528   1          CY_SET_REG8(USBUART_1_CR0_PTR, USBUART_1_CR0_ENABLE);
 529   1      
 530   1      }
 531          
 532          
 533          /*******************************************************************************
 534          * Function Name: USBUART_1_Stop
 535          ********************************************************************************
 536          *
 537          * Summary:
 538          *  This function shuts down the USB function including to release
 539          *  the D+ Pullup and disabling the SIE.
 540          *
 541          * Parameters:
 542          *  None.
 543          *
 544          * Return:
 545          *  None.
 546          *
 547          * Global variables:
 548          *   USBUART_1_configuration: Contains current configuration number
 549          *       which is set by the Host using SET_CONFIGURATION request.
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 10  

 550          *       Initialized to zero in this API.
 551          *   USBUART_1_deviceAddress: Contains current device address. This
 552          *       variable is initialized to zero in this API. Host starts to communicate
 553          *      to device with address 0 and then set it to whatever value using
 554          *      SET_ADDRESS request.
 555          *   USBUART_1_deviceStatus: initialized to 0.
 556          *       This is two bit variable which contain power status in first bit
 557          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 558          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 559          *   USBUART_1_configurationChanged: This variable is set to one after
 560          *       SET_CONFIGURATION request and cleared in this function.
 561          *   USBUART_1_intiVar variable is set to zero
 562          *
 563          *******************************************************************************/
 564          void USBUART_1_Stop(void) 
 565          {
 566   1      
 567   1          #if(USBUART_1_EP_MM != USBUART_1__EP_MANUAL)
                      USBUART_1_Stop_DMA(USBUART_1_MAX_EP);     /* Stop all DMAs */
                  #endif   /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 570   1      
 571   1          /* Disable the SIE */
 572   1          USBUART_1_CR0_REG &= (uint8)(~USBUART_1_CR0_ENABLE);
 573   1          /* Disable the d+ pullup */
 574   1          USBUART_1_USBIO_CR1_REG &= (uint8)(~USBUART_1_USBIO_CR1_USBPUEN);
 575   1          /* Disable USB in ACT PM */
 576   1          USBUART_1_PM_ACT_CFG_REG &= (uint8)(~USBUART_1_PM_ACT_EN_FSUSB);
 577   1          /* Disable USB block for Standby Power Mode */
 578   1          USBUART_1_PM_STBY_CFG_REG &= (uint8)(~USBUART_1_PM_STBY_EN_FSUSB);
 579   1      
 580   1          /* Disable the reset and EP interrupts */
 581   1          CyIntDisable(USBUART_1_BUS_RESET_VECT_NUM);
 582   1          CyIntDisable(USBUART_1_EP_0_VECT_NUM);
 583   1          #if(USBUART_1_EP1_ISR_REMOVE == 0u)
 584   1              CyIntDisable(USBUART_1_EP_1_VECT_NUM);
 585   1          #endif   /*  USBUART_1_EP1_ISR_REMOVE */
 586   1          #if(USBUART_1_EP2_ISR_REMOVE == 0u)
 587   1              CyIntDisable(USBUART_1_EP_2_VECT_NUM);
 588   1          #endif   /*  USBUART_1_EP2_ISR_REMOVE */
 589   1          #if(USBUART_1_EP3_ISR_REMOVE == 0u)
 590   1              CyIntDisable(USBUART_1_EP_3_VECT_NUM);
 591   1          #endif   /*  USBUART_1_EP3_ISR_REMOVE */
 592   1          #if(USBUART_1_EP4_ISR_REMOVE == 0u)
                      CyIntDisable(USBUART_1_EP_4_VECT_NUM);
                  #endif   /*  USBUART_1_EP4_ISR_REMOVE */
 595   1          #if(USBUART_1_EP5_ISR_REMOVE == 0u)
                      CyIntDisable(USBUART_1_EP_5_VECT_NUM);
                  #endif   /*  USBUART_1_EP5_ISR_REMOVE */
 598   1          #if(USBUART_1_EP6_ISR_REMOVE == 0u)
                      CyIntDisable(USBUART_1_EP_6_VECT_NUM);
                  #endif   /*  USBUART_1_EP6_ISR_REMOVE */
 601   1          #if(USBUART_1_EP7_ISR_REMOVE == 0u)
                      CyIntDisable(USBUART_1_EP_7_VECT_NUM);
                  #endif   /*  USBUART_1_EP7_ISR_REMOVE */
 604   1          #if(USBUART_1_EP8_ISR_REMOVE == 0u)
                      CyIntDisable(USBUART_1_EP_8_VECT_NUM);
                  #endif   /*  USBUART_1_EP8_ISR_REMOVE */
 607   1      
 608   1          /* Clear all of the component data */
 609   1          USBUART_1_configuration = 0u;
 610   1          USBUART_1_interfaceNumber = 0u;
 611   1          USBUART_1_configurationChanged = 0u;
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 11  

 612   1          USBUART_1_deviceAddress  = 0u;
 613   1          USBUART_1_deviceStatus = 0u;
 614   1          USBUART_1_initVar = 0u;
 615   1      
 616   1      }
 617          
 618          
 619          /*******************************************************************************
 620          * Function Name: USBUART_1_CheckActivity
 621          ********************************************************************************
 622          *
 623          * Summary:
 624          *  Returns the activity status of the bus.  Clears the status hardware to
 625          *  provide fresh activity status on the next call of this routine.
 626          *
 627          * Parameters:
 628          *  None.
 629          *
 630          * Return:
 631          *  1 - If bus activity was detected since the last call to this function
 632          *  0 - If bus activity not was detected since the last call to this function
 633          *
 634          *******************************************************************************/
 635          uint8 USBUART_1_CheckActivity(void) 
 636          {
 637   1          uint8 r;
 638   1      
 639   1          r = CY_GET_REG8(USBUART_1_CR1_PTR);
 640   1          CY_SET_REG8(USBUART_1_CR1_PTR, (r & ((uint8)(~USBUART_1_CR1_BUS_ACTIVITY))));
 641   1      
 642   1          return((r & USBUART_1_CR1_BUS_ACTIVITY) >> USBUART_1_CR1_BUS_ACTIVITY_SHIFT);
 643   1      }
 644          
 645          
 646          /*******************************************************************************
 647          * Function Name: USBUART_1_GetConfiguration
 648          ********************************************************************************
 649          *
 650          * Summary:
 651          *  Returns the current configuration setting
 652          *
 653          * Parameters:
 654          *  None.
 655          *
 656          * Return:
 657          *  configuration.
 658          *
 659          *******************************************************************************/
 660          uint8 USBUART_1_GetConfiguration(void) 
 661          {
 662   1          return(USBUART_1_configuration);
 663   1      }
 664          
 665          
 666          /*******************************************************************************
 667          * Function Name: USBUART_1_IsConfigurationChanged
 668          ********************************************************************************
 669          *
 670          * Summary:
 671          *  Returns the clear on read configuration state. It is usefull when PC send
 672          *  double SET_CONFIGURATION request with same configuration number.
 673          *
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 12  

 674          * Parameters:
 675          *  None.
 676          *
 677          * Return:
 678          *  Not zero value when new configuration has been changed, otherwise zero is
 679          *  returned.
 680          *
 681          * Global variables:
 682          *   USBUART_1_configurationChanged: This variable is set to one after
 683          *       SET_CONFIGURATION request and cleared in this function.
 684          *
 685          *******************************************************************************/
 686          uint8 USBUART_1_IsConfigurationChanged(void) 
 687          {
 688   1          uint8 res = 0u;
 689   1      
 690   1          if(USBUART_1_configurationChanged != 0u)
 691   1          {
 692   2              res = USBUART_1_configurationChanged;
 693   2              USBUART_1_configurationChanged = 0u;
 694   2          }
 695   1      
 696   1          return(res);
 697   1      }
 698          
 699          
 700          /*******************************************************************************
 701          * Function Name: USBUART_1_GetInterfaceSetting
 702          ********************************************************************************
 703          *
 704          * Summary:
 705          *  Returns the alternate setting from current interface
 706          *
 707          * Parameters:
 708          *  uint8 interfaceNumber, interface number
 709          *
 710          * Return:
 711          *  Alternate setting.
 712          *
 713          *******************************************************************************/
 714          uint8  USBUART_1_GetInterfaceSetting(uint8 interfaceNumber)
 715                                                              
 716          {
 717   1          return(USBUART_1_interfaceSetting[interfaceNumber]);
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: USBUART_1_GetEPState
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Returned the state of the requested endpoint.
 727          *
 728          * Parameters:
 729          *  epNumber: Endpoint Number
 730          *
 731          * Return:
 732          *  State of the requested endpoint.
 733          *
 734          *******************************************************************************/
 735          uint8 USBUART_1_GetEPState(uint8 epNumber) 
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 13  

 736          {
 737   1          return(USBUART_1_EP[epNumber].apiEpState);
 738   1      }
 739          
 740          
 741          /*******************************************************************************
 742          * Function Name: USBUART_1_GetEPCount
 743          ********************************************************************************
 744          *
 745          * Summary:
 746          *  This function supports Data Endpoints only(EP1-EP8).
 747          *  Returns the transfer count for the requested endpoint.  The value from
 748          *  the count registers includes 2 counts for the two byte checksum of the
 749          *  packet.  This function subtracts the two counts.
 750          *
 751          * Parameters:
 752          *  epNumber: Data Endpoint Number.
 753          *            Valid values are between 1 and 8.
 754          *
 755          * Return:
 756          *  Returns the current byte count from the specified endpoint or 0 for an
 757          *  invalid endpoint.
 758          *
 759          *******************************************************************************/
 760          uint16 USBUART_1_GetEPCount(uint8 epNumber) 
 761          {
 762   1          uint8 ri;
 763   1          uint16 result = 0u;
 764   1      
 765   1          if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP))
 766   1          {
 767   2              ri = ((epNumber - USBUART_1_EP1) << USBUART_1_EPX_CNTX_ADDR_SHIFT);
 768   2      
 769   2              result = (uint8)(CY_GET_REG8((reg8 *)(USBUART_1_SIE_EP1_CNT0_IND + ri)) &
 770   2                                USBUART_1_EPX_CNT0_MASK);
 771   2              result = (result << 8u) | CY_GET_REG8((reg8 *)(USBUART_1_SIE_EP1_CNT1_IND + ri));
 772   2              result -= USBUART_1_EPX_CNTX_CRC_COUNT;
 773   2          }
 774   1          return(result);
 775   1      }
 776          
 777          
 778          #if(USBUART_1_EP_MM != USBUART_1__EP_MANUAL)
              
              
                  /*******************************************************************************
                  * Function Name: USBUART_1_InitEP_DMA
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USBUART_1_LoadInEP() or USBUART_1_ReadOutEP() APIs for data
                  *  transfer.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  *pData: Pointer to a data array that is related to the EP transfers.
                  *
                  * Return:
                  *  None.
                  *
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 14  

                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void USBUART_1_InitEP_DMA(uint8 epNumber, const uint8* pData)
                                                                                  
                  {
                      uint16 src;
                      uint16 dst;
                      #if (CY_PSOC3)                  /* PSoC 3 */
                          src = HI16(CYDEV_SRAM_BASE);
                          dst = HI16(CYDEV_PERIPH_BASE);
                          pData = pData;
                      #else                           /* PSoC 5 */
                          if((USBUART_1_EP[epNumber].addr & USBUART_1_DIR_IN) != 0u )
                          {   /* for the IN EP source is the SRAM memory buffer */
                              src = HI16(pData);
                              dst = HI16(CYDEV_PERIPH_BASE);
                          }
                          else
                          {   /* for the OUT EP source is the SIE register */
                              src = HI16(CYDEV_PERIPH_BASE);
                              dst = HI16(pData);
                          }
                      #endif  /*  C51 */
                      switch(epNumber)
                      {
                          case USBUART_1_EP1:
                              #if(USBUART_1_DMA1_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep1_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA1_REMOVE */
                              break;
                          case USBUART_1_EP2:
                              #if(USBUART_1_DMA2_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep2_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA2_REMOVE */
                              break;
                          case USBUART_1_EP3:
                              #if(USBUART_1_DMA3_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep3_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA3_REMOVE */
                              break;
                          case USBUART_1_EP4:
                              #if(USBUART_1_DMA4_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep4_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA4_REMOVE */
                              break;
                          case USBUART_1_EP5:
                              #if(USBUART_1_DMA5_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep5_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA5_REMOVE */
                              break;
                          case USBUART_1_EP6:
                              #if(USBUART_1_DMA6_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep6_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA6_REMOVE */
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 15  

                              break;
                          case USBUART_1_EP7:
                              #if(USBUART_1_DMA7_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep7_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA7_REMOVE */
                              break;
                          case USBUART_1_EP8:
                              #if(USBUART_1_DMA8_REMOVE == 0u)
                                  USBUART_1_DmaChan[epNumber] = USBUART_1_ep8_DmaInitialize(
                                      USBUART_1_DMA_BYTES_PER_BURST, USBUART_1_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBUART_1_DMA8_REMOVE */
                              break;
                          default:
                              /* Do not support EP0 DMA transfers */
                              break;
                      }
                      if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP))
                      {
                          USBUART_1_DmaTd[epNumber] = CyDmaTdAllocate();
                          #if ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u))
                              USBUART_1_DmaNextTd[epNumber] = CyDmaTdAllocate();
                          #endif /*  ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u)) *
             -/
              
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: USBUART_1_Stop_DMA
                  ********************************************************************************
                  *
                  * Summary: Stops and free DMA
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number or
                  *           USBUART_1_MAX_EP to stop all DMAs
                  *
                  * Return:
                  *  None.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void USBUART_1_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
                      i = (epNumber < USBUART_1_MAX_EP) ? epNumber : USBUART_1_EP1;
                      do
                      {
                          if(USBUART_1_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USBUART_1_DmaChan[i]);
                              CyDmaTdFree(USBUART_1_DmaTd[i]);
                              USBUART_1_DmaTd[i] = DMA_INVALID_TD;
                          }
                          #if ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u))
                              if(USBUART_1_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USBUART_1_DmaNextTd[i]);
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 16  

                                  USBUART_1_DmaNextTd[i] = DMA_INVALID_TD;
                              }
                          #endif /* ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u)) */
                          i++;
                      }while((i < USBUART_1_MAX_EP) && (epNumber == USBUART_1_MAX_EP));
                  }
              
              #endif /*  USBUART_1_EP_MM != USBUART_1__EP_MANUAL */
 929          
 930          
 931          #if ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u))
              
              
                  /*******************************************************************************
                  * Function Name: USBUART_1_LoadNextInEP
                  ********************************************************************************
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void USBUART_1_LoadNextInEP(uint8 epNumber, uint8 mode) 
                  {
                      reg16 *convert;
              
                      if(mode == 0u)
                      {
                          /* Configure DMA to send the the rest of data */
                          /* CyDmaTdSetConfiguration API is optimised to change only transfer length and configure TD */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_1_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length */
                          CY_SET_REG16(convert, USBUART_1_inLength[epNumber] - USBUART_1_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change only source address */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_1_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USBUART_1_inDataPointer[epNumber] +
                                                          USBUART_1_DMA_BYTES_PER_BURST));
                          USBUART_1_inBufFull[epNumber] = 1u;
                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimised to change only transfer length and configure TD */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_1_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length */
                          CY_SET_REG16(convert, USBUART_1_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change only source address */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBUART_1_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USBUART_1_inDataPointer[epNumber] +
                                                 USBUART_1_DMA_BYTES_PER_BURST - USBUART_1_DMA_BYTES_REPEAT));
                      }
              
                      /* CyDmaChSetInitialTd API is optimised to init TD */
                      CY_DMA_CH_STRUCT_PTR[USBUART_1_DmaChan[epNumber]].basic_status[1u] = USBUART_1_DmaTd[epNumber];
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 17  

                  }
              #endif /* ((USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO) && (USBUART_1_EP_DMA_AUTO_OPT == 0u)) */
 985          
 986          
 987          /*******************************************************************************
 988          * Function Name: USBUART_1_LoadInEP
 989          ********************************************************************************
 990          *
 991          * Summary:
 992          *  Loads and enables the specified USB data endpoint for an IN transfer.
 993          *
 994          * Parameters:
 995          *  epNumber: Contains the data endpoint number.
 996          *            Valid values are between 1 and 8.
 997          *  *pData: A pointer to a data array from which the data for the endpoint space
 998          *          is loaded.
 999          *  length: The number of bytes to transfer from the array and then send as a
1000          *          result of an IN request. Valid values are between 0 and 512.
1001          *
1002          * Return:
1003          *  None.
1004          *
1005          * Reentrant:
1006          *  No.
1007          *
1008          *******************************************************************************/
1009          void USBUART_1_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1010                                                                                  
1011          {
1012   1          uint8 ri;
1013   1          reg8 *p;
1014   1          #if(USBUART_1_EP_MM == USBUART_1__EP_MANUAL)
1015   1              uint16 i;
1016   1          #endif /*  USBUART_1_EP_MM == USBUART_1__EP_MANUAL */
1017   1      
1018   1          if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP))
1019   1          {
1020   2              ri = ((epNumber - USBUART_1_EP1) << USBUART_1_EPX_CNTX_ADDR_SHIFT);
1021   2              p = (reg8 *)(USBUART_1_ARB_RW1_DR_IND + ri);
1022   2      
1023   2              #if(USBUART_1_EP_MM != USBUART_1__EP_DMAAUTO)
1024   2                  /* Limits length to available buffer space, auto MM could send packets up to 1024 bytes */
1025   2                  if(length > (USBUART_1_EPX_DATA_BUF_MAX - USBUART_1_EP[epNumber].buffOffset))
1026   2                  {
1027   3                      length = USBUART_1_EPX_DATA_BUF_MAX - USBUART_1_EP[epNumber].buffOffset;
1028   3                  }
1029   2              #endif /*  USBUART_1_EP_MM != USBUART_1__EP_DMAAUTO */
1030   2      
1031   2              /* Set the count and data toggle */
1032   2              CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CNT0_IND + ri),
1033   2                                  (length >> 8u) | (USBUART_1_EP[epNumber].epToggle));
1034   2              CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CNT1_IND + ri),  length & 0xFFu);
1035   2      
1036   2              #if(USBUART_1_EP_MM == USBUART_1__EP_MANUAL)
1037   2                  if(pData != NULL)
1038   2                  {
1039   3                      /* Copy the data using the arbiter data register */
1040   3                      for (i = 0u; i < length; i++)
1041   3                      {
1042   4                          CY_SET_REG8(p, pData[i]);
1043   4                      }
1044   3                  }
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 18  

1045   2                  USBUART_1_EP[epNumber].apiEpState = USBUART_1_NO_EVENT_PENDING;
1046   2                  /* Write the Mode register */
1047   2                  CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CR0_IND + ri), USBUART_1_EP[epNumber].epMode);
1048   2              #else
                          /* Init DMA if it was not initialized */
                          if (USBUART_1_DmaTd[epNumber] == DMA_INVALID_TD)
                          {
                              USBUART_1_InitEP_DMA(epNumber, pData);
                          }
                      #endif /*  USBUART_1_EP_MM == USBUART_1__EP_MANUAL */
1055   2      
1056   2              #if(USBUART_1_EP_MM == USBUART_1__EP_DMAMANUAL)
                          USBUART_1_EP[epNumber].apiEpState = USBUART_1_NO_EVENT_PENDING;
                          if ((pData != NULL) && (length > 0u))
                          {
                              /* Enable DMA in mode2 for transferring data */
                              (void) CyDmaChDisable(USBUART_1_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USBUART_1_DmaTd[epNumber], length, CY_DMA_DISABLE_TD,
                                                                                               TD_TERMIN_EN | TD_INC_SRC
             -_ADR);
                              (void) CyDmaTdSetAddress(USBUART_1_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p))
             -;
                              /* Enable the DMA */
                              (void) CyDmaChSetInitialTd(USBUART_1_DmaChan[epNumber], USBUART_1_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBUART_1_DmaChan[epNumber], 1u);
                              /* Generate DMA request */
                              * (reg8 *)(USBUART_1_ARB_EP1_CFG_IND + ri) |= USBUART_1_ARB_EPX_CFG_DMA_REQ;
                              * (reg8 *)(USBUART_1_ARB_EP1_CFG_IND + ri) &= ((uint8)(~USBUART_1_ARB_EPX_CFG_DMA_REQ));
                              /* Mode register will be written in arb ISR after DMA transfer complete */
                          }
                          else
                          {
                              /* When zero-length packet - write the Mode register directly */
                              CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CR0_IND + ri), USBUART_1_EP[epNumber].epMode);
                          }
                      #endif /*  USBUART_1_EP_MM == USBUART_1__EP_DMAMANUAL */
1079   2      
1080   2              #if(USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO)
                          if (pData != NULL)
                          {
                              /* Enable DMA in mode3 for transferring data */
                              (void) CyDmaChDisable(USBUART_1_DmaChan[epNumber]);
                          #if (USBUART_1_EP_DMA_AUTO_OPT == 0u)
                              USBUART_1_inLength[epNumber] = length;
                              USBUART_1_inDataPointer[epNumber] = pData;
                              /* Configure DMA to send the data only for the first burst */
                              (void) CyDmaTdSetConfiguration(USBUART_1_DmaTd[epNumber],
                                  (length > USBUART_1_DMA_BYTES_PER_BURST) ? USBUART_1_DMA_BYTES_PER_BURST : length,
                                  USBUART_1_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USBUART_1_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p))
             -;
                              /* The second TD will be executed only when the first one fails.
                              *  The intention of this TD is to generate NRQ interrupt
                              *  and repeat 2 last bytes of the first burst.
                              */
                              (void) CyDmaTdSetConfiguration(USBUART_1_DmaNextTd[epNumber], 1u,
                                                             USBUART_1_DmaNextTd[epNumber],
                                                             USBUART_1_epX_TD_TERMOUT_EN[epNumber]);
                              /* Configure DmaNextTd to clear Data ready status */
                              (void) CyDmaTdSetAddress(USBUART_1_DmaNextTd[epNumber],  LO16((uint32)&clearInDataRdyStatu
             -s),
                                                                              LO16((uint32)(USBUART_1_ARB_EP1_CFG_IND + 
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 19  

             -ri)));
                          #else /* Configure DMA to send all data*/
                              (void) CyDmaTdSetConfiguration(USBUART_1_DmaTd[epNumber], length,
                                                             USBUART_1_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USBUART_1_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p))
             -;
                          #endif /* USBUART_1_EP_DMA_AUTO_OPT == 0u */    
              
                              /* Clear Any potential pending DMA requests before starting the DMA channel to transfer da
             -ta */
                              (void) CyDmaClearPendingDrq(USBUART_1_DmaChan[epNumber]);
                              /* Enable the DMA */
                              (void) CyDmaChSetInitialTd(USBUART_1_DmaChan[epNumber], USBUART_1_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBUART_1_DmaChan[epNumber], 1u);
                          }
                          else
                          {
                              USBUART_1_EP[epNumber].apiEpState = USBUART_1_NO_EVENT_PENDING;
                              if(length > 0u)
                              {
                              #if (USBUART_1_EP_DMA_AUTO_OPT == 0u)
                                  USBUART_1_inLength[epNumber] = length;
                                  USBUART_1_inBufFull[epNumber] = 0u;
                                  (void) CyDmaChDisable(USBUART_1_DmaChan[epNumber]);
                                  /* Configure DMA to send the data only for the first burst */
                                  (void) CyDmaTdSetConfiguration(
                                      USBUART_1_DmaTd[epNumber], (length > USBUART_1_DMA_BYTES_PER_BURST) ?
                                      USBUART_1_DMA_BYTES_PER_BURST : length,
                                      USBUART_1_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USBUART_1_DmaTd[epNumber],
                                                           LO16((uint32)USBUART_1_inDataPointer[epNumber]), LO16((uint32
             -)p));
                                  /* Clear Any potential pending DMA requests before starting the DMA channel to transfe
             -r data */
                                  (void) CyDmaClearPendingDrq(USBUART_1_DmaChan[epNumber]);
                                  /* Enable the DMA */
                                  (void) CyDmaChSetInitialTd(USBUART_1_DmaChan[epNumber], USBUART_1_DmaTd[epNumber]);
                                  (void) CyDmaChEnable(USBUART_1_DmaChan[epNumber], 1u);
                              #endif /* (USBUART_1_EP_DMA_AUTO_OPT == 0u) */
              
                                  /* Set Data ready status, This will generate DMA request */
                                  #ifndef USBUART_1_MANUAL_IN_EP_ARM
                                      * (reg8 *)(USBUART_1_ARB_EP1_CFG_IND + ri) |= USBUART_1_ARB_EPX_CFG_IN_DATA_RDY;
                                  #endif  /* USBUART_1_MANUAL_IN_EP_ARM */
                                  /* Mode register will be written in arb ISR(In Buffer Full) after first DMA transfer c
             -omplete */
                              }
                              else
                              {
                                  /* When zero-length packet - write the Mode register directly */
                                  CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CR0_IND + ri), USBUART_1_EP[epNumber].epMode);
                              }
                          }
                      #endif /*  USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO */
1151   2          }
1152   1      }
1153          
1154          
1155          /*******************************************************************************
1156          * Function Name: USBUART_1_ReadOutEP
1157          ********************************************************************************
1158          *
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 20  

1159          * Summary:
1160          *  Read data from an endpoint.  The application must call
1161          *  USBUART_1_GetEPState to see if an event is pending.
1162          *
1163          * Parameters:
1164          *  epNumber: Contains the data endpoint number.
1165          *            Valid values are between 1 and 8.
1166          *  pData: A pointer to a data array from which the data for the endpoint space
1167          *         is loaded.
1168          *  length: The number of bytes to transfer from the USB Out endpoint and loads
1169          *          it into data array. Valid values are between 0 and 1023. The function
1170          *          moves fewer than the requested number of bytes if the host sends
1171          *          fewer bytes than requested.
1172          *
1173          * Returns:
1174          *  Number of bytes received, 0 for an invalid endpoint.
1175          *
1176          * Reentrant:
1177          *  No.
1178          *
1179          *******************************************************************************/
1180          uint16 USBUART_1_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1181                                                                                  
1182          {
1183   1          uint8 ri;
1184   1          reg8 *p;
1185   1          #if(USBUART_1_EP_MM == USBUART_1__EP_MANUAL)
1186   1              uint16 i;
1187   1          #endif /*  USBUART_1_EP_MM == USBUART_1__EP_MANUAL */
1188   1          #if(USBUART_1_EP_MM != USBUART_1__EP_DMAAUTO)
1189   1              uint16 xferCount;
1190   1          #endif /*  USBUART_1_EP_MM != USBUART_1__EP_DMAAUTO */
1191   1      
1192   1          if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP) && (pData != NULL))
1193   1          {
1194   2              ri = ((epNumber - USBUART_1_EP1) << USBUART_1_EPX_CNTX_ADDR_SHIFT);
1195   2              p = (reg8 *)(USBUART_1_ARB_RW1_DR_IND + ri);
1196   2      
1197   2              #if(USBUART_1_EP_MM != USBUART_1__EP_DMAAUTO)
1198   2                  /* Determine which is smaller the requested data or the available data */
1199   2                  xferCount = USBUART_1_GetEPCount(epNumber);
1200   2                  if (length > xferCount)
1201   2                  {
1202   3                      length = xferCount;
1203   3                  }
1204   2              #endif /*  USBUART_1_EP_MM != USBUART_1__EP_DMAAUTO */
1205   2      
1206   2              #if(USBUART_1_EP_MM == USBUART_1__EP_MANUAL)
1207   2                  /* Copy the data using the arbiter data register */
1208   2                  for (i = 0u; i < length; i++)
1209   2                  {
1210   3                      pData[i] = CY_GET_REG8(p);
1211   3                  }
1212   2      
1213   2                  /* (re)arming of OUT endpoint */
1214   2                  USBUART_1_EnableOutEP(epNumber);
1215   2              #else
                          /*Init DMA if it was not initialized */
                          if(USBUART_1_DmaTd[epNumber] == DMA_INVALID_TD)
                          {
                              USBUART_1_InitEP_DMA(epNumber, pData);
                          }
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 21  

              
                      #endif /*  USBUART_1_EP_MM == USBUART_1__EP_MANUAL */
1223   2      
1224   2              #if(USBUART_1_EP_MM == USBUART_1__EP_DMAMANUAL)
                          /* Enable DMA in mode2 for transferring data */
                          (void) CyDmaChDisable(USBUART_1_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBUART_1_DmaTd[epNumber], length, CY_DMA_DISABLE_TD,
                                                                                              TD_TERMIN_EN | TD_INC_DST_
             -ADR);
                          (void) CyDmaTdSetAddress(USBUART_1_DmaTd[epNumber],  LO16((uint32)p), LO16((uint32)pData));
                          /* Enable the DMA */
                          (void) CyDmaChSetInitialTd(USBUART_1_DmaChan[epNumber], USBUART_1_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBUART_1_DmaChan[epNumber], 1u);
              
                          /* Generate DMA request */
                          * (reg8 *)(USBUART_1_ARB_EP1_CFG_IND + ri) |= USBUART_1_ARB_EPX_CFG_DMA_REQ;
                          * (reg8 *)(USBUART_1_ARB_EP1_CFG_IND + ri) &= ((uint8)(~USBUART_1_ARB_EPX_CFG_DMA_REQ));
                          /* Out EP will be (re)armed in arb ISR after transfer complete */
                      #endif /*  USBUART_1_EP_MM == USBUART_1__EP_DMAMANUAL */
1239   2      
1240   2              #if(USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO)
                          /* Enable DMA in mode3 for transferring data */
                          (void) CyDmaChDisable(USBUART_1_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBUART_1_DmaTd[epNumber], length, USBUART_1_DmaTd[epNumber],
                                                                                              TD_TERMIN_EN | TD_INC_DST_
             -ADR);
                          (void) CyDmaTdSetAddress(USBUART_1_DmaTd[epNumber],  LO16((uint32)p), LO16((uint32)pData));
              
                          /* Clear Any potential pending DMA requests before starting the DMA channel to transfer data *
             -/
                          (void) CyDmaClearPendingDrq(USBUART_1_DmaChan[epNumber]);
                          /* Enable the DMA */
                          (void) CyDmaChSetInitialTd(USBUART_1_DmaChan[epNumber], USBUART_1_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBUART_1_DmaChan[epNumber], 1u);
                          /* Out EP will be (re)armed in arb ISR after transfer complete */
                      #endif /*  USBUART_1_EP_MM == USBUART_1__EP_DMAAUTO */
1254   2      
1255   2          }
1256   1          else
1257   1          {
1258   2              length = 0u;
1259   2          }
1260   1      
1261   1          return(length);
1262   1      }
1263          
1264          
1265          /*******************************************************************************
1266          * Function Name: USBUART_1_EnableOutEP
1267          ********************************************************************************
1268          *
1269          * Summary:
1270          *  This function enables an OUT endpoint.  It should not be
1271          *  called for an IN endpoint.
1272          *
1273          * Parameters:
1274          *  epNumber: Endpoint Number
1275          *            Valid values are between 1 and 8.
1276          *
1277          * Return:
1278          *   None.
1279          *
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 22  

1280          * Global variables:
1281          *  USBUART_1_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
1282          *
1283          * Reentrant:
1284          *  No.
1285          *
1286          *******************************************************************************/
1287          void USBUART_1_EnableOutEP(uint8 epNumber) 
1288          {
1289   1          uint8 ri;
1290   1      
1291   1          if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP))
1292   1          {
1293   2              ri = ((epNumber - USBUART_1_EP1) << USBUART_1_EPX_CNTX_ADDR_SHIFT);
1294   2              USBUART_1_EP[epNumber].apiEpState = USBUART_1_NO_EVENT_PENDING;
1295   2              /* Write the Mode register */
1296   2              CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CR0_IND + ri), USBUART_1_EP[epNumber].epMode);
1297   2          }
1298   1      }
1299          
1300          
1301          /*******************************************************************************
1302          * Function Name: USBUART_1_DisableOutEP
1303          ********************************************************************************
1304          *
1305          * Summary:
1306          *  This function disables an OUT endpoint.  It should not be
1307          *  called for an IN endpoint.
1308          *
1309          * Parameters:
1310          *  epNumber: Endpoint Number
1311          *            Valid values are between 1 and 8.
1312          *
1313          * Return:
1314          *  None.
1315          *
1316          *******************************************************************************/
1317          void USBUART_1_DisableOutEP(uint8 epNumber) 
1318          {
1319   1          uint8 ri ;
1320   1      
1321   1          if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP))
1322   1          {
1323   2              ri = ((epNumber - USBUART_1_EP1) << USBUART_1_EPX_CNTX_ADDR_SHIFT);
1324   2              /* Write the Mode register */
1325   2              CY_SET_REG8((reg8 *)(USBUART_1_SIE_EP1_CR0_IND + ri), USBUART_1_MODE_NAK_OUT);
1326   2          }
1327   1      }
1328          
1329          
1330          /*******************************************************************************
1331          * Function Name: USBUART_1_Force
1332          ********************************************************************************
1333          *
1334          * Summary:
1335          *  Forces the bus state
1336          *
1337          * Parameters:
1338          *  bState
1339          *    USBUART_1_FORCE_J
1340          *    USBUART_1_FORCE_K
1341          *    USBUART_1_FORCE_SE0
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 23  

1342          *    USBUART_1_FORCE_NONE
1343          *
1344          * Return:
1345          *  None.
1346          *
1347          *******************************************************************************/
1348          void USBUART_1_Force(uint8 bState) 
1349          {
1350   1          CY_SET_REG8(USBUART_1_USBIO_CR0_PTR, bState);
1351   1      }
1352          
1353          
1354          /*******************************************************************************
1355          * Function Name: USBUART_1_GetEPAckState
1356          ********************************************************************************
1357          *
1358          * Summary:
1359          *  Returns the ACK of the CR0 Register (ACKD)
1360          *
1361          * Parameters:
1362          *  epNumber: Endpoint Number
1363          *            Valid values are between 1 and 8.
1364          *
1365          * Returns
1366          *  0 if nothing has been ACKD, non-=zero something has been ACKD
1367          *
1368          *******************************************************************************/
1369          uint8 USBUART_1_GetEPAckState(uint8 epNumber) 
1370          {
1371   1          uint8 ri;
1372   1          uint8 cr = 0u;
1373   1      
1374   1          if((epNumber > USBUART_1_EP0) && (epNumber < USBUART_1_MAX_EP))
1375   1          {
1376   2              ri = ((epNumber - USBUART_1_EP1) << USBUART_1_EPX_CNTX_ADDR_SHIFT);
1377   2              cr = CY_GET_REG8((reg8 *)(USBUART_1_SIE_EP1_CR0_IND + ri)) & USBUART_1_MODE_ACKD;
1378   2          }
1379   1      
1380   1          return(cr);
1381   1      }
1382          
1383          
1384          /*******************************************************************************
1385          * Function Name: USBUART_1_SetPowerStatus
1386          ********************************************************************************
1387          *
1388          * Summary:
1389          *  Sets the device power status for reporting in the Get Device Status
1390          *  request
1391          *
1392          * Parameters:
1393          *  powerStatus: USBUART_1_DEVICE_STATUS_BUS_POWERED(0) - Bus Powered,
1394          *               USBUART_1_DEVICE_STATUS_SELF_POWERED(1) - Self Powered
1395          *
1396          * Return:
1397          *   None.
1398          *
1399          * Global variables:
1400          *  USBUART_1_deviceStatus - set power status
1401          *
1402          * Reentrant:
1403          *  No.
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 24  

1404          *
1405          *******************************************************************************/
1406          void USBUART_1_SetPowerStatus(uint8 powerStatus) 
1407          {
1408   1          if (powerStatus != USBUART_1_DEVICE_STATUS_BUS_POWERED)
1409   1          {
1410   2              USBUART_1_deviceStatus |=  USBUART_1_DEVICE_STATUS_SELF_POWERED;
1411   2          }
1412   1          else
1413   1          {
1414   2              USBUART_1_deviceStatus &=  ((uint8)(~USBUART_1_DEVICE_STATUS_SELF_POWERED));
1415   2          }
1416   1      }
1417          
1418          
1419          #if (USBUART_1_MON_VBUS == 1u)
              
                  /*******************************************************************************
                  * Function Name: USBUART_1_VBusPresent
                  ********************************************************************************
                  *
                  * Summary:
                  *  Determines VBUS presence for Self Powered Devices.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  1 if VBUS is present, otherwise 0.
                  *
                  *******************************************************************************/
                  uint8 USBUART_1_VBusPresent(void) 
                  {
                      return((0u != (CY_GET_REG8(USBUART_1_VBUS_PS_PTR) & USBUART_1_VBUS_MASK)) ? 1u : 0u);
                  }
              
              #endif /* USBUART_1_MON_VBUS */
1441          
1442          
1443          /*******************************************************************************
1444          * Function Name: USBUART_1_RWUEnabled
1445          ********************************************************************************
1446          *
1447          * Summary:
1448          *  Returns TRUE if Remote Wake Up is enabled, otherwise FALSE
1449          *
1450          * Parameters:
1451          *   None.
1452          *
1453          * Return:
1454          *  TRUE -  Remote Wake Up Enabled
1455          *  FALSE - Remote Wake Up Disabled
1456          *
1457          * Global variables:
1458          *  USBUART_1_deviceStatus - checked to determine remote status
1459          *
1460          *******************************************************************************/
1461          uint8 USBUART_1_RWUEnabled(void) 
1462          {
1463   1          uint8 result = USBUART_1_FALSE;
1464   1          if((USBUART_1_deviceStatus & USBUART_1_DEVICE_STATUS_REMOTE_WAKEUP) != 0u)
1465   1          {
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 25  

1466   2              result = USBUART_1_TRUE;
1467   2          }
1468   1      
1469   1          return(result);
1470   1      }
1471          
1472          
1473          /* [] END OF FILE */
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 26  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USBUART_1_Start (BEGIN)
                                           ; SOURCE LINE # 129
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 132
000A 900000      R     MOV     DPTR,#USBUART_1_initVar
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
0012 120000      R     LCALL   USBUART_1_Init
                                           ; SOURCE LINE # 135
0015 900000      R     MOV     DPTR,#USBUART_1_initVar
0018 7401              MOV     A,#01H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
001B         ?C0001:
                                           ; SOURCE LINE # 137
001B 900000      R     MOV     DPTR,#device
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 900000      R     MOV     DPTR,#mode
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 120000      R     LCALL   _USBUART_1_InitComponent
                                           ; SOURCE LINE # 138
0028 22                RET     
             ; FUNCTION _USBUART_1_Start (END)

             ; FUNCTION USBUART_1_Init (BEGIN)
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 165
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 168
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 170
0013 9043B5            MOV     DPTR,#043B5H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4401              ORL     A,#01H
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 27  

001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 173
001E 90609D            MOV     DPTR,#0609DH
0021 7401              MOV     A,#01H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 175
0024 906009            MOV     DPTR,#06009H
0027 7402              MOV     A,#02H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
002A 906010            MOV     DPTR,#06010H
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 547F              ANL     A,#07FH
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
0035 7F00              MOV     R7,#00H
0037 7E00              MOV     R6,#00H
0039 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 185
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 EF                MOV     A,R7
0042 54F9              ANL     A,#0F9H
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 189
0047 906012            MOV     DPTR,#06012H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 54DF              ANL     A,#0DFH
004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
0052 904394            MOV     DPTR,#04394H
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 4401              ORL     A,#01H
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 194
005D 7F01              MOV     R7,#01H
005F 7E00              MOV     R6,#00H
0061 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 196
0064 7F28              MOV     R7,#028H
0066 7E00              MOV     R6,#00H
0068 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 198
006B 9051F8            MOV     DPTR,#051F8H
006E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 28  

006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 547F              ANL     A,#07FH
0073 FF                MOV     R7,A
0074 EF                MOV     A,R7
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0076 9051F8            MOV     DPTR,#051F8H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 54BF              ANL     A,#0BFH
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
0081 904394            MOV     DPTR,#04394H
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 4402              ORL     A,#02H
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 203
008C 7F02              MOV     R7,#02H
008E 7E00              MOV     R6,#00H
0090 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 205
0093 904394            MOV     DPTR,#04394H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 4404              ORL     A,#04H
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
009E 906084            MOV     DPTR,#06084H
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
00A3 906085            MOV     DPTR,#06085H
00A6 E4                CLR     A
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 222
00A8 900000      R     MOV     DPTR,#enableInterrupts
00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 226
00B0 7C00        E     MOV     R4,#HIGH USBUART_1_BUS_RESET_ISR
00B2 7D00        E     MOV     R5,#LOW USBUART_1_BUS_RESET_ISR
00B4 7F17              MOV     R7,#017H
00B6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 227
00B9 7D07              MOV     R5,#07H
00BB 7F17              MOV     R7,#017H
00BD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 231
00C0 7C00        E     MOV     R4,#HIGH USBUART_1_SOF_ISR
00C2 7D00        E     MOV     R5,#LOW USBUART_1_SOF_ISR
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 29  

00C4 7F15              MOV     R7,#015H
00C6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 232
00C9 7D07              MOV     R5,#07H
00CB 7F15              MOV     R7,#015H
00CD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 236
00D0 7C00        E     MOV     R4,#HIGH USBUART_1_EP_0_ISR
00D2 7D00        E     MOV     R5,#LOW USBUART_1_EP_0_ISR
00D4 7F18              MOV     R7,#018H
00D6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 237
00D9 7D07              MOV     R5,#07H
00DB 7F18              MOV     R7,#018H
00DD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 241
00E0 7C00        E     MOV     R4,#HIGH USBUART_1_EP_1_ISR
00E2 7D00        E     MOV     R5,#LOW USBUART_1_EP_1_ISR
00E4 7F00              MOV     R7,#00H
00E6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 242
00E9 7D07              MOV     R5,#07H
00EB 7F00              MOV     R7,#00H
00ED 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 247
00F0 7C00        E     MOV     R4,#HIGH USBUART_1_EP_2_ISR
00F2 7D00        E     MOV     R5,#LOW USBUART_1_EP_2_ISR
00F4 7F01              MOV     R7,#01H
00F6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 248
00F9 7D07              MOV     R5,#07H
00FB 7F01              MOV     R7,#01H
00FD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 253
0100 7C00        E     MOV     R4,#HIGH USBUART_1_EP_3_ISR
0102 7D00        E     MOV     R5,#LOW USBUART_1_EP_3_ISR
0104 7F02              MOV     R7,#02H
0106 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 254
0109 7D07              MOV     R5,#07H
010B 7F02              MOV     R7,#02H
010D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 293
0110 22                RET     
             ; FUNCTION USBUART_1_Init (END)

             ; FUNCTION _USBUART_1_InitComponent (BEGIN)
                                           ; SOURCE LINE # 348
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 349
                                           ; SOURCE LINE # 357
000A 900000      R     MOV     DPTR,#i
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
000F         ?C0004:
000F 900000      R     MOV     DPTR,#i
0012 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 30  

0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 C3                CLR     C
0016 9402              SUBB    A,#02H
0018 501A              JNC     ?C0005
                                           ; SOURCE LINE # 358
                                           ; SOURCE LINE # 359
001A 900000      R     MOV     DPTR,#i
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F 7400        E     MOV     A,#LOW USBUART_1_hidProtocol
0021 2F                ADD     A,R7
0022 F582              MOV     DPL,A
0024 E4                CLR     A
0025 3400        E     ADDC    A,#HIGH USBUART_1_hidProtocol
0027 F583              MOV     DPH,A
0029 7401              MOV     A,#01H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 360
002C 900000      R     MOV     DPTR,#i
002F E0                MOVX    A,@DPTR
0030 04                INC     A
0031 F0                MOVX    @DPTR,A
0032 80DB              SJMP    ?C0004
0034         ?C0005:
                                           ; SOURCE LINE # 364
0034 9044C2            MOV     DPTR,#044C2H
0037 7480              MOV     A,#080H
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
003A 9044C3            MOV     DPTR,#044C3H
003D 7401              MOV     A,#01H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 367
0040 9044C0            MOV     DPTR,#044C0H
0043 7401              MOV     A,#01H
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 370
0046 9044C0            MOV     DPTR,#044C0H
0049 7402              MOV     A,#02H
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 373
004C 9044C0            MOV     DPTR,#044C0H
004F 7404              MOV     A,#04H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
0052 900000      E     MOV     DPTR,#USBUART_1_transferState
0055 E4                CLR     A
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 416
0057 900000      R     MOV     DPTR,#mode
005A E0                MOVX    A,@DPTR
005B FF                MOV     R7,A
005C EF                MOV     A,R7
005D 120000      E     LCALL   ?C?CCASE
0060 0000        R     DW      ?C0008
0062 00                DB      00H
0063 0000        R     DW      ?C0009
0065 01                DB      01H
0066 0000              DW      00H
0068 0000        R     DW      ?C0010
                                           ; SOURCE LINE # 417
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 31  

                                           ; SOURCE LINE # 418
006A         ?C0008:
                                           ; SOURCE LINE # 419
006A 906009            MOV     DPTR,#06009H
006D 7402              MOV     A,#02H
006F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 420
0070 800E              SJMP    ?C0007
                                           ; SOURCE LINE # 421
0072         ?C0009:
                                           ; SOURCE LINE # 422
0072 906009            MOV     DPTR,#06009H
0075 7403              MOV     A,#03H
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 423
0078 8006              SJMP    ?C0007
                                           ; SOURCE LINE # 424
007A         ?C0010:
                                           ; SOURCE LINE # 426
007A 906009            MOV     DPTR,#06009H
007D 7402              MOV     A,#02H
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
0080         ?C0007:
                                           ; SOURCE LINE # 434
0080 900000      R     MOV     DPTR,#device
0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 900000      E     MOV     DPTR,#USBUART_1_device
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
008A 900000      E     MOV     DPTR,#USBUART_1_configuration
008D E4                CLR     A
008E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
008F 900000      E     MOV     DPTR,#USBUART_1_interfaceNumber
0092 E4                CLR     A
0093 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
0094 900000      E     MOV     DPTR,#USBUART_1_configurationChanged
0097 E4                CLR     A
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
0099 900000      E     MOV     DPTR,#USBUART_1_deviceAddress
009C E4                CLR     A
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 441
009E 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 443
00A3 900000      E     MOV     DPTR,#USBUART_1_lastPacketSize
00A6 E4                CLR     A
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 446
00A8 906028            MOV     DPTR,#06028H
00AB 7403              MOV     A,#03H
00AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
00AE 906008            MOV     DPTR,#06008H
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 32  

00B1 7480              MOV     A,#080H
00B3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
00B4 7F01              MOV     R7,#01H
00B6 7E00              MOV     R6,#00H
00B8 7D00              MOV     R5,#00H
00BA 7C00              MOV     R4,#00H
00BC 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 455
00BF 906012            MOV     DPTR,#06012H
00C2 7404              MOV     A,#04H
00C4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 456
00C5 22                RET     
             ; FUNCTION _USBUART_1_InitComponent (END)

             ; FUNCTION USBUART_1_ReInitComponent (BEGIN)
                                           ; SOURCE LINE # 498
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 506
0000 900000      R     MOV     DPTR,#i
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005         ?C0012:
0005 900000      R     MOV     DPTR,#i
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B C3                CLR     C
000C 9402              SUBB    A,#02H
000E 501A              JNC     ?C0013
                                           ; SOURCE LINE # 507
                                           ; SOURCE LINE # 508
0010 900000      R     MOV     DPTR,#i
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 7400        E     MOV     A,#LOW USBUART_1_hidProtocol
0017 2F                ADD     A,R7
0018 F582              MOV     DPL,A
001A E4                CLR     A
001B 3400        E     ADDC    A,#HIGH USBUART_1_hidProtocol
001D F583              MOV     DPH,A
001F 7401              MOV     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 509
0022 900000      R     MOV     DPTR,#i
0025 E0                MOVX    A,@DPTR
0026 04                INC     A
0027 F0                MOVX    @DPTR,A
0028 80DB              SJMP    ?C0012
002A         ?C0013:
                                           ; SOURCE LINE # 512
002A 900000      E     MOV     DPTR,#USBUART_1_transferState
002D E4                CLR     A
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
002F 900000      E     MOV     DPTR,#USBUART_1_configuration
0032 E4                CLR     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 516
0034 900000      E     MOV     DPTR,#USBUART_1_interfaceNumber
0037 E4                CLR     A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 33  

0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
0039 900000      E     MOV     DPTR,#USBUART_1_configurationChanged
003C E4                CLR     A
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
003E 900000      E     MOV     DPTR,#USBUART_1_deviceAddress
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
0043 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 521
0048 900000      E     MOV     DPTR,#USBUART_1_lastPacketSize
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 525
004D 906028            MOV     DPTR,#06028H
0050 7403              MOV     A,#03H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 528
0053 906008            MOV     DPTR,#06008H
0056 7480              MOV     A,#080H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 530
0059 22                RET     
             ; FUNCTION USBUART_1_ReInitComponent (END)

             ; FUNCTION USBUART_1_Stop (BEGIN)
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 572
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 574
000B 906012            MOV     DPTR,#06012H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 54FB              ANL     A,#0FBH
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
0016 9043A5            MOV     DPTR,#043A5H
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 54FE              ANL     A,#0FEH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
0021 9043B5            MOV     DPTR,#043B5H
0024 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 34  

0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 54FE              ANL     A,#0FEH
0029 FF                MOV     R7,A
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 581
002C 9044CA            MOV     DPTR,#044CAH
002F 7480              MOV     A,#080H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 582
0032 9044CB            MOV     DPTR,#044CBH
0035 7401              MOV     A,#01H
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 584
0038 9044C8            MOV     DPTR,#044C8H
003B 7401              MOV     A,#01H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 587
003E 9044C8            MOV     DPTR,#044C8H
0041 7402              MOV     A,#02H
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 590
0044 9044C8            MOV     DPTR,#044C8H
0047 7404              MOV     A,#04H
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 609
004A 900000      E     MOV     DPTR,#USBUART_1_configuration
004D E4                CLR     A
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 610
004F 900000      E     MOV     DPTR,#USBUART_1_interfaceNumber
0052 E4                CLR     A
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 611
0054 900000      E     MOV     DPTR,#USBUART_1_configurationChanged
0057 E4                CLR     A
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 612
0059 900000      E     MOV     DPTR,#USBUART_1_deviceAddress
005C E4                CLR     A
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
005E 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
0061 E4                CLR     A
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 614
0063 900000      R     MOV     DPTR,#USBUART_1_initVar
0066 E4                CLR     A
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 616
0068 22                RET     
             ; FUNCTION USBUART_1_Stop (END)

             ; FUNCTION USBUART_1_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 636
                                           ; SOURCE LINE # 639
0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#r
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 35  

0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 640
000A 900000      R     MOV     DPTR,#r
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 54FB              ANL     A,#0FBH
0012 FF                MOV     R7,A
0013 906009            MOV     DPTR,#06009H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 642
0018 900000      R     MOV     DPTR,#r
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 5404              ANL     A,#04H
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 13                RRC     A
0023 13                RRC     A
0024 543F              ANL     A,#03FH
0026 FF                MOV     R7,A
                                           ; SOURCE LINE # 643
0027         ?C0017:
0027 22                RET     
             ; FUNCTION USBUART_1_CheckActivity (END)

             ; FUNCTION USBUART_1_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
                                           ; SOURCE LINE # 662
0000 900000      E     MOV     DPTR,#USBUART_1_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 663
0005         ?C0018:
0005 22                RET     
             ; FUNCTION USBUART_1_GetConfiguration (END)

             ; FUNCTION USBUART_1_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 687
                                           ; SOURCE LINE # 688
0000 900000      R     MOV     DPTR,#res
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0005 900000      E     MOV     DPTR,#USBUART_1_configurationChanged
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0019
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
000D 900000      E     MOV     DPTR,#USBUART_1_configurationChanged
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 900000      R     MOV     DPTR,#res
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 36  

                                           ; SOURCE LINE # 693
0017 900000      E     MOV     DPTR,#USBUART_1_configurationChanged
001A E4                CLR     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 694
001C         ?C0019:
                                           ; SOURCE LINE # 696
001C 900000      R     MOV     DPTR,#res
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
                                           ; SOURCE LINE # 697
0021         ?C0020:
0021 22                RET     
             ; FUNCTION USBUART_1_IsConfigurationChanged (END)

             ; FUNCTION _USBUART_1_GetInterfaceSetting (BEGIN)
                                           ; SOURCE LINE # 714
0000 900000      R     MOV     DPTR,#interfaceNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
0005 900000      R     MOV     DPTR,#interfaceNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 7400        E     MOV     A,#LOW USBUART_1_interfaceSetting
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F E4                CLR     A
0010 3400        E     ADDC    A,#HIGH USBUART_1_interfaceSetting
0012 F583              MOV     DPH,A
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
                                           ; SOURCE LINE # 718
0016         ?C0021:
0016 22                RET     
             ; FUNCTION _USBUART_1_GetInterfaceSetting (END)

             ; FUNCTION _USBUART_1_GetEPState (BEGIN)
                                           ; SOURCE LINE # 735
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 736
                                           ; SOURCE LINE # 737
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 75F00B            MOV     B,#0BH
000E A4                MUL     AB
000F 2400        E     ADD     A,#LOW USBUART_1_EP+01H
0011 F582              MOV     DPL,A
0013 E4                CLR     A
0014 3400        E     ADDC    A,#HIGH USBUART_1_EP+01H
0016 F583              MOV     DPH,A
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
                                           ; SOURCE LINE # 738
001A         ?C0022:
001A 22                RET     
             ; FUNCTION _USBUART_1_GetEPState (END)
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 37  


             ; FUNCTION _USBUART_1_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 760
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
                                           ; SOURCE LINE # 763
0005 900000      R     MOV     DPTR,#result
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B E4                CLR     A
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
000D 900000      R     MOV     DPTR,#epNumber
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 D3                SETB    C
0014 9400              SUBB    A,#00H
0016 5003              JNC     $ + 5H
0018 020000      R     LJMP    ?C0023
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 C3                CLR     C
0022 9409              SUBB    A,#09H
0024 4003              JC      $ + 5H
0026 020000      R     LJMP    ?C0023
                                           ; SOURCE LINE # 766
                                           ; SOURCE LINE # 767
0029 900000      R     MOV     DPTR,#epNumber
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 7E00              MOV     R6,#00H
0030 EF                MOV     A,R7
0031 24FF              ADD     A,#0FFH
0033 FF                MOV     R7,A
0034 EE                MOV     A,R6
0035 34FF              ADDC    A,#0FFH
0037 FE                MOV     R6,A
0038 EF                MOV     A,R7
0039 C4                SWAP    A
003A F8                MOV     R0,A
003B 540F              ANL     A,#0FH
003D C8                XCH     A,R0
003E 68                XRL     A,R0
003F FF                MOV     R7,A
0040 EE                MOV     A,R6
0041 C4                SWAP    A
0042 54F0              ANL     A,#0F0H
0044 48                ORL     A,R0
0045 FE                MOV     R6,A
0046 900000      R     MOV     DPTR,#ri
0049 EF                MOV     A,R7
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 769
004B 900000      R     MOV     DPTR,#ri
004E E0                MOVX    A,@DPTR
004F FF                MOV     R7,A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 38  

0050 7E00              MOV     R6,#00H
0052 EF                MOV     A,R7
0053 240C              ADD     A,#0CH
0055 FF                MOV     R7,A
0056 EE                MOV     A,R6
0057 3460              ADDC    A,#060H
0059 FE                MOV     R6,A
005A 8F82              MOV     DPL,R7
005C 8E83              MOV     DPH,R6
005E E0                MOVX    A,@DPTR
005F FF                MOV     R7,A
0060 EF                MOV     A,R7
0061 540F              ANL     A,#0FH
0063 FF                MOV     R7,A
0064 7E00              MOV     R6,#00H
0066 900000      R     MOV     DPTR,#result
0069 EE                MOV     A,R6
006A F0                MOVX    @DPTR,A
006B A3                INC     DPTR
006C EF                MOV     A,R7
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 771
006E 900000      R     MOV     DPTR,#ri
0071 E0                MOVX    A,@DPTR
0072 FF                MOV     R7,A
0073 7E00              MOV     R6,#00H
0075 EF                MOV     A,R7
0076 240D              ADD     A,#0DH
0078 FF                MOV     R7,A
0079 EE                MOV     A,R6
007A 3460              ADDC    A,#060H
007C FE                MOV     R6,A
007D 8F82              MOV     DPL,R7
007F 8E83              MOV     DPH,R6
0081 E0                MOVX    A,@DPTR
0082 FF                MOV     R7,A
0083 EF                MOV     A,R7
0084 FD                MOV     R5,A
0085 7C00              MOV     R4,#00H
0087 900000      R     MOV     DPTR,#result
008A E0                MOVX    A,@DPTR
008B FE                MOV     R6,A
008C A3                INC     DPTR
008D E0                MOVX    A,@DPTR
008E FF                MOV     R7,A
008F EF                MOV     A,R7
0090 7F00              MOV     R7,#00H
0092 FE                MOV     R6,A
0093 EE                MOV     A,R6
0094 4C                ORL     A,R4
0095 FE                MOV     R6,A
0096 EF                MOV     A,R7
0097 4D                ORL     A,R5
0098 FF                MOV     R7,A
0099 900000      R     MOV     DPTR,#result
009C EE                MOV     A,R6
009D F0                MOVX    @DPTR,A
009E A3                INC     DPTR
009F EF                MOV     A,R7
00A0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 772
00A1 900000      R     MOV     DPTR,#result
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 39  

00A4 74FF              MOV     A,#0FFH
00A6 75F0FE            MOV     B,#0FEH
00A9 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 773
00AC         ?C0023:
                                           ; SOURCE LINE # 774
00AC 900000      R     MOV     DPTR,#result
00AF E0                MOVX    A,@DPTR
00B0 FE                MOV     R6,A
00B1 A3                INC     DPTR
00B2 E0                MOVX    A,@DPTR
00B3 FF                MOV     R7,A
                                           ; SOURCE LINE # 775
00B4         ?C0024:
00B4 22                RET     
             ; FUNCTION _USBUART_1_GetEPCount (END)

             ; FUNCTION _USBUART_1_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1009
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1011
                                           ; SOURCE LINE # 1018
000B 900000      R     MOV     DPTR,#epNumber
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
0014 5003              JNC     $ + 5H
0016 020000      R     LJMP    ?C0031
0019 900000      R     MOV     DPTR,#epNumber
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F C3                CLR     C
0020 9409              SUBB    A,#09H
0022 4003              JC      $ + 5H
0024 020000      R     LJMP    ?C0031
                                           ; SOURCE LINE # 1019
                                           ; SOURCE LINE # 1020
0027 900000      R     MOV     DPTR,#epNumber
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 7E00              MOV     R6,#00H
002E EF                MOV     A,R7
002F 24FF              ADD     A,#0FFH
0031 FF                MOV     R7,A
0032 EE                MOV     A,R6
0033 34FF              ADDC    A,#0FFH
0035 FE                MOV     R6,A
0036 EF                MOV     A,R7
0037 C4                SWAP    A
0038 F8                MOV     R0,A
0039 540F              ANL     A,#0FH
003B C8                XCH     A,R0
003C 68                XRL     A,R0
003D FF                MOV     R7,A
003E EE                MOV     A,R6
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 40  

003F C4                SWAP    A
0040 54F0              ANL     A,#0F0H
0042 48                ORL     A,R0
0043 FE                MOV     R6,A
0044 900000      R     MOV     DPTR,#ri
0047 EF                MOV     A,R7
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1021
0049 900000      R     MOV     DPTR,#ri
004C E0                MOVX    A,@DPTR
004D FF                MOV     R7,A
004E 7E00              MOV     R6,#00H
0050 EF                MOV     A,R7
0051 2488              ADD     A,#088H
0053 FF                MOV     R7,A
0054 EE                MOV     A,R6
0055 3460              ADDC    A,#060H
0057 FE                MOV     R6,A
0058 900000      R     MOV     DPTR,#p
005B EE                MOV     A,R6
005C F0                MOVX    @DPTR,A
005D A3                INC     DPTR
005E EF                MOV     A,R7
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1025
0060 900000      R     MOV     DPTR,#epNumber
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
0065 EF                MOV     A,R7
0066 75F00B            MOV     B,#0BH
0069 A4                MUL     AB
006A 2400        E     ADD     A,#LOW USBUART_1_EP+06H
006C F582              MOV     DPL,A
006E E4                CLR     A
006F 3400        E     ADDC    A,#HIGH USBUART_1_EP+06H
0071 F583              MOV     DPH,A
0073 E0                MOVX    A,@DPTR
0074 FE                MOV     R6,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 C3                CLR     C
0079 E4                CLR     A
007A 9F                SUBB    A,R7
007B FF                MOV     R7,A
007C 7402              MOV     A,#02H
007E 9E                SUBB    A,R6
007F FE                MOV     R6,A
0080 900000      R     MOV     DPTR,#length
0083 E0                MOVX    A,@DPTR
0084 FC                MOV     R4,A
0085 A3                INC     DPTR
0086 E0                MOVX    A,@DPTR
0087 FD                MOV     R5,A
0088 D3                SETB    C
0089 ED                MOV     A,R5
008A 9F                SUBB    A,R7
008B EC                MOV     A,R4
008C 9E                SUBB    A,R6
008D 4028              JC      ?C0026
                                           ; SOURCE LINE # 1026
                                           ; SOURCE LINE # 1027
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 41  

008F 900000      R     MOV     DPTR,#epNumber
0092 E0                MOVX    A,@DPTR
0093 FF                MOV     R7,A
0094 EF                MOV     A,R7
0095 75F00B            MOV     B,#0BH
0098 A4                MUL     AB
0099 2400        E     ADD     A,#LOW USBUART_1_EP+06H
009B F582              MOV     DPL,A
009D E4                CLR     A
009E 3400        E     ADDC    A,#HIGH USBUART_1_EP+06H
00A0 F583              MOV     DPH,A
00A2 E0                MOVX    A,@DPTR
00A3 FE                MOV     R6,A
00A4 A3                INC     DPTR
00A5 E0                MOVX    A,@DPTR
00A6 FF                MOV     R7,A
00A7 C3                CLR     C
00A8 E4                CLR     A
00A9 9F                SUBB    A,R7
00AA FF                MOV     R7,A
00AB 7402              MOV     A,#02H
00AD 9E                SUBB    A,R6
00AE FE                MOV     R6,A
00AF 900000      R     MOV     DPTR,#length
00B2 EE                MOV     A,R6
00B3 F0                MOVX    @DPTR,A
00B4 A3                INC     DPTR
00B5 EF                MOV     A,R7
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1028
00B7         ?C0026:
                                           ; SOURCE LINE # 1033
00B7 900000      R     MOV     DPTR,#length
00BA E0                MOVX    A,@DPTR
00BB FE                MOV     R6,A
00BC A3                INC     DPTR
00BD E0                MOVX    A,@DPTR
00BE FF                MOV     R7,A
00BF EE                MOV     A,R6
00C0 FF                MOV     R7,A
00C1 7E00              MOV     R6,#00H
00C3 900000      R     MOV     DPTR,#epNumber
00C6 E0                MOVX    A,@DPTR
00C7 FE                MOV     R6,A
00C8 EE                MOV     A,R6
00C9 75F00B            MOV     B,#0BH
00CC A4                MUL     AB
00CD 2400        E     ADD     A,#LOW USBUART_1_EP+03H
00CF F582              MOV     DPL,A
00D1 E4                CLR     A
00D2 3400        E     ADDC    A,#HIGH USBUART_1_EP+03H
00D4 F583              MOV     DPH,A
00D6 E0                MOVX    A,@DPTR
00D7 FE                MOV     R6,A
00D8 EF                MOV     A,R7
00D9 4E                ORL     A,R6
00DA FF                MOV     R7,A
00DB 900000      R     MOV     DPTR,#ri
00DE E0                MOVX    A,@DPTR
00DF FE                MOV     R6,A
00E0 EE                MOV     A,R6
00E1 FD                MOV     R5,A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 42  

00E2 7C00              MOV     R4,#00H
00E4 ED                MOV     A,R5
00E5 240C              ADD     A,#0CH
00E7 FD                MOV     R5,A
00E8 EC                MOV     A,R4
00E9 3460              ADDC    A,#060H
00EB FC                MOV     R4,A
00EC 8D82              MOV     DPL,R5
00EE 8C83              MOV     DPH,R4
00F0 EF                MOV     A,R7
00F1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1034
00F2 900000      R     MOV     DPTR,#length
00F5 E0                MOVX    A,@DPTR
00F6 FE                MOV     R6,A
00F7 A3                INC     DPTR
00F8 E0                MOVX    A,@DPTR
00F9 FF                MOV     R7,A
00FA EF                MOV     A,R7
00FB 54FF              ANL     A,#0FFH
00FD FF                MOV     R7,A
00FE 900000      R     MOV     DPTR,#ri
0101 E0                MOVX    A,@DPTR
0102 FE                MOV     R6,A
0103 EE                MOV     A,R6
0104 FD                MOV     R5,A
0105 7C00              MOV     R4,#00H
0107 ED                MOV     A,R5
0108 240D              ADD     A,#0DH
010A FD                MOV     R5,A
010B EC                MOV     A,R4
010C 3460              ADDC    A,#060H
010E FC                MOV     R4,A
010F 8D82              MOV     DPL,R5
0111 8C83              MOV     DPH,R4
0113 EF                MOV     A,R7
0114 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1037
0115 7B00              MOV     R3,#00H
0117 7A00              MOV     R2,#00H
0119 7900              MOV     R1,#00H
011B C003              PUSH    AR3
011D C002              PUSH    AR2
011F C001              PUSH    AR1
0121 900000      R     MOV     DPTR,#pData
0124 120000      E     LCALL   ?C?PLDXDATA
0127 D082              POP     DPL
0129 D083              POP     DPH
012B D0E0              POP     ACC
012D 6B                XRL     A,R3
012E 7008              JNZ     ?C0051
0130 E9                MOV     A,R1
0131 6582              XRL     A,DPL
0133 7003              JNZ     ?C0051
0135 EA                MOV     A,R2
0136 6583              XRL     A,DPH
0138         ?C0051:
0138 6051              JZ      ?C0027
                                           ; SOURCE LINE # 1038
                                           ; SOURCE LINE # 1040
013A 900000      R     MOV     DPTR,#i
013D E4                CLR     A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 43  

013E F0                MOVX    @DPTR,A
013F A3                INC     DPTR
0140 E4                CLR     A
0141 F0                MOVX    @DPTR,A
0142         ?C0028:
0142 900000      R     MOV     DPTR,#length
0145 E0                MOVX    A,@DPTR
0146 FE                MOV     R6,A
0147 A3                INC     DPTR
0148 E0                MOVX    A,@DPTR
0149 FF                MOV     R7,A
014A 900000      R     MOV     DPTR,#i
014D E0                MOVX    A,@DPTR
014E FC                MOV     R4,A
014F A3                INC     DPTR
0150 E0                MOVX    A,@DPTR
0151 FD                MOV     R5,A
0152 C3                CLR     C
0153 ED                MOV     A,R5
0154 9F                SUBB    A,R7
0155 EC                MOV     A,R4
0156 9E                SUBB    A,R6
0157 5032              JNC     ?C0027
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1042
0159 900000      R     MOV     DPTR,#pData
015C 120000      E     LCALL   ?C?PLDXDATA
015F 900000      R     MOV     DPTR,#i
0162 E0                MOVX    A,@DPTR
0163 FE                MOV     R6,A
0164 A3                INC     DPTR
0165 E0                MOVX    A,@DPTR
0166 FF                MOV     R7,A
0167 E9                MOV     A,R1
0168 2F                ADD     A,R7
0169 F9                MOV     R1,A
016A EA                MOV     A,R2
016B 3E                ADDC    A,R6
016C FA                MOV     R2,A
016D 120000      E     LCALL   ?C?CLDPTR
0170 FF                MOV     R7,A
0171 900000      R     MOV     DPTR,#p
0174 E0                MOVX    A,@DPTR
0175 FC                MOV     R4,A
0176 A3                INC     DPTR
0177 E0                MOVX    A,@DPTR
0178 FD                MOV     R5,A
0179 8D82              MOV     DPL,R5
017B 8C83              MOV     DPH,R4
017D EF                MOV     A,R7
017E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1043
017F 900000      R     MOV     DPTR,#i
0182 E4                CLR     A
0183 75F001            MOV     B,#01H
0186 120000      E     LCALL   ?C?IILDX
0189 80B7              SJMP    ?C0028
                                           ; SOURCE LINE # 1044
018B         ?C0027:
                                           ; SOURCE LINE # 1045
018B 900000      R     MOV     DPTR,#epNumber
018E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 44  

018F FF                MOV     R7,A
0190 EF                MOV     A,R7
0191 75F00B            MOV     B,#0BH
0194 A4                MUL     AB
0195 2400        E     ADD     A,#LOW USBUART_1_EP+01H
0197 F582              MOV     DPL,A
0199 E4                CLR     A
019A 3400        E     ADDC    A,#HIGH USBUART_1_EP+01H
019C F583              MOV     DPH,A
019E E4                CLR     A
019F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1047
01A0 900000      R     MOV     DPTR,#epNumber
01A3 E0                MOVX    A,@DPTR
01A4 FF                MOV     R7,A
01A5 EF                MOV     A,R7
01A6 75F00B            MOV     B,#0BH
01A9 A4                MUL     AB
01AA 2400        E     ADD     A,#LOW USBUART_1_EP+05H
01AC F582              MOV     DPL,A
01AE E4                CLR     A
01AF 3400        E     ADDC    A,#HIGH USBUART_1_EP+05H
01B1 F583              MOV     DPH,A
01B3 E0                MOVX    A,@DPTR
01B4 FF                MOV     R7,A
01B5 900000      R     MOV     DPTR,#ri
01B8 E0                MOVX    A,@DPTR
01B9 FE                MOV     R6,A
01BA EE                MOV     A,R6
01BB FD                MOV     R5,A
01BC 7C00              MOV     R4,#00H
01BE ED                MOV     A,R5
01BF 240E              ADD     A,#0EH
01C1 FD                MOV     R5,A
01C2 EC                MOV     A,R4
01C3 3460              ADDC    A,#060H
01C5 FC                MOV     R4,A
01C6 8D82              MOV     DPL,R5
01C8 8C83              MOV     DPH,R4
01CA EF                MOV     A,R7
01CB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1151
                                           ; SOURCE LINE # 1152
01CC         ?C0031:
01CC 22                RET     
             ; FUNCTION _USBUART_1_LoadInEP (END)

             ; FUNCTION _USBUART_1_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1180
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1182
                                           ; SOURCE LINE # 1192
000B 900000      R     MOV     DPTR,#epNumber
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 45  

0014 5003              JNC     $ + 5H
0016 020000      R     LJMP    ?C0032
0019 900000      R     MOV     DPTR,#epNumber
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F C3                CLR     C
0020 9409              SUBB    A,#09H
0022 4003              JC      $ + 5H
0024 020000      R     LJMP    ?C0032
0027 7B00              MOV     R3,#00H
0029 7A00              MOV     R2,#00H
002B 7900              MOV     R1,#00H
002D C003              PUSH    AR3
002F C002              PUSH    AR2
0031 C001              PUSH    AR1
0033 900000      R     MOV     DPTR,#pData
0036 120000      E     LCALL   ?C?PLDXDATA
0039 D082              POP     DPL
003B D083              POP     DPH
003D D0E0              POP     ACC
003F 6B                XRL     A,R3
0040 7008              JNZ     ?C0052
0042 E9                MOV     A,R1
0043 6582              XRL     A,DPL
0045 7003              JNZ     ?C0052
0047 EA                MOV     A,R2
0048 6583              XRL     A,DPH
004A         ?C0052:
004A 7003              JNZ     $ + 5H
004C 020000      R     LJMP    ?C0032
                                           ; SOURCE LINE # 1193
                                           ; SOURCE LINE # 1194
004F 900000      R     MOV     DPTR,#epNumber
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 7E00              MOV     R6,#00H
0056 EF                MOV     A,R7
0057 24FF              ADD     A,#0FFH
0059 FF                MOV     R7,A
005A EE                MOV     A,R6
005B 34FF              ADDC    A,#0FFH
005D FE                MOV     R6,A
005E EF                MOV     A,R7
005F C4                SWAP    A
0060 F8                MOV     R0,A
0061 540F              ANL     A,#0FH
0063 C8                XCH     A,R0
0064 68                XRL     A,R0
0065 FF                MOV     R7,A
0066 EE                MOV     A,R6
0067 C4                SWAP    A
0068 54F0              ANL     A,#0F0H
006A 48                ORL     A,R0
006B FE                MOV     R6,A
006C 900000      R     MOV     DPTR,#ri
006F EF                MOV     A,R7
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1195
0071 900000      R     MOV     DPTR,#ri
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 46  

0076 7E00              MOV     R6,#00H
0078 EF                MOV     A,R7
0079 2488              ADD     A,#088H
007B FF                MOV     R7,A
007C EE                MOV     A,R6
007D 3460              ADDC    A,#060H
007F FE                MOV     R6,A
0080 900000      R     MOV     DPTR,#p
0083 EE                MOV     A,R6
0084 F0                MOVX    @DPTR,A
0085 A3                INC     DPTR
0086 EF                MOV     A,R7
0087 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1199
0088 900000      R     MOV     DPTR,#epNumber
008B E0                MOVX    A,@DPTR
008C FF                MOV     R7,A
008D 120000      R     LCALL   _USBUART_1_GetEPCount
0090 900000      R     MOV     DPTR,#xferCount
0093 EE                MOV     A,R6
0094 F0                MOVX    @DPTR,A
0095 A3                INC     DPTR
0096 EF                MOV     A,R7
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1200
0098 900000      R     MOV     DPTR,#xferCount
009B E0                MOVX    A,@DPTR
009C FE                MOV     R6,A
009D A3                INC     DPTR
009E E0                MOVX    A,@DPTR
009F FF                MOV     R7,A
00A0 900000      R     MOV     DPTR,#length
00A3 E0                MOVX    A,@DPTR
00A4 FC                MOV     R4,A
00A5 A3                INC     DPTR
00A6 E0                MOVX    A,@DPTR
00A7 FD                MOV     R5,A
00A8 D3                SETB    C
00A9 ED                MOV     A,R5
00AA 9F                SUBB    A,R7
00AB EC                MOV     A,R4
00AC 9E                SUBB    A,R6
00AD 4010              JC      ?C0033
                                           ; SOURCE LINE # 1201
                                           ; SOURCE LINE # 1202
00AF 900000      R     MOV     DPTR,#xferCount
00B2 E0                MOVX    A,@DPTR
00B3 FE                MOV     R6,A
00B4 A3                INC     DPTR
00B5 E0                MOVX    A,@DPTR
00B6 FF                MOV     R7,A
00B7 900000      R     MOV     DPTR,#length
00BA EE                MOV     A,R6
00BB F0                MOVX    @DPTR,A
00BC A3                INC     DPTR
00BD EF                MOV     A,R7
00BE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1203
00BF         ?C0033:
                                           ; SOURCE LINE # 1208
00BF 900000      R     MOV     DPTR,#i
00C2 E4                CLR     A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 47  

00C3 F0                MOVX    @DPTR,A
00C4 A3                INC     DPTR
00C5 E4                CLR     A
00C6 F0                MOVX    @DPTR,A
00C7         ?C0034:
00C7 900000      R     MOV     DPTR,#length
00CA E0                MOVX    A,@DPTR
00CB FE                MOV     R6,A
00CC A3                INC     DPTR
00CD E0                MOVX    A,@DPTR
00CE FF                MOV     R7,A
00CF 900000      R     MOV     DPTR,#i
00D2 E0                MOVX    A,@DPTR
00D3 FC                MOV     R4,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 FD                MOV     R5,A
00D7 C3                CLR     C
00D8 ED                MOV     A,R5
00D9 9F                SUBB    A,R7
00DA EC                MOV     A,R4
00DB 9E                SUBB    A,R6
00DC 5032              JNC     ?C0035
                                           ; SOURCE LINE # 1209
                                           ; SOURCE LINE # 1210
00DE 900000      R     MOV     DPTR,#p
00E1 E0                MOVX    A,@DPTR
00E2 FE                MOV     R6,A
00E3 A3                INC     DPTR
00E4 E0                MOVX    A,@DPTR
00E5 FF                MOV     R7,A
00E6 8F82              MOV     DPL,R7
00E8 8E83              MOV     DPH,R6
00EA E0                MOVX    A,@DPTR
00EB FF                MOV     R7,A
00EC 900000      R     MOV     DPTR,#pData
00EF 120000      E     LCALL   ?C?PLDXDATA
00F2 900000      R     MOV     DPTR,#i
00F5 E0                MOVX    A,@DPTR
00F6 FC                MOV     R4,A
00F7 A3                INC     DPTR
00F8 E0                MOVX    A,@DPTR
00F9 FD                MOV     R5,A
00FA E9                MOV     A,R1
00FB 2D                ADD     A,R5
00FC F9                MOV     R1,A
00FD EA                MOV     A,R2
00FE 3C                ADDC    A,R4
00FF FA                MOV     R2,A
0100 EF                MOV     A,R7
0101 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1211
0104 900000      R     MOV     DPTR,#i
0107 E4                CLR     A
0108 75F001            MOV     B,#01H
010B 120000      E     LCALL   ?C?IILDX
010E 80B7              SJMP    ?C0034
0110         ?C0035:
                                           ; SOURCE LINE # 1214
0110 900000      R     MOV     DPTR,#epNumber
0113 E0                MOVX    A,@DPTR
0114 FF                MOV     R7,A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 48  

0115 120000      R     LCALL   _USBUART_1_EnableOutEP
                                           ; SOURCE LINE # 1255
0118 8008              SJMP    ?C0037
011A         ?C0032:
                                           ; SOURCE LINE # 1257
                                           ; SOURCE LINE # 1258
011A 900000      R     MOV     DPTR,#length
011D E4                CLR     A
011E F0                MOVX    @DPTR,A
011F A3                INC     DPTR
0120 E4                CLR     A
0121 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1259
0122         ?C0037:
                                           ; SOURCE LINE # 1261
0122 900000      R     MOV     DPTR,#length
0125 E0                MOVX    A,@DPTR
0126 FE                MOV     R6,A
0127 A3                INC     DPTR
0128 E0                MOVX    A,@DPTR
0129 FF                MOV     R7,A
                                           ; SOURCE LINE # 1262
012A         ?C0038:
012A 22                RET     
             ; FUNCTION _USBUART_1_ReadOutEP (END)

             ; FUNCTION _USBUART_1_EnableOutEP (BEGIN)
                                           ; SOURCE LINE # 1287
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1288
                                           ; SOURCE LINE # 1291
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 406E              JC      ?C0040
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 5063              JNC     ?C0040
                                           ; SOURCE LINE # 1292
                                           ; SOURCE LINE # 1293
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 7E00              MOV     R6,#00H
0022 EF                MOV     A,R7
0023 24FF              ADD     A,#0FFH
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 34FF              ADDC    A,#0FFH
0029 FE                MOV     R6,A
002A EF                MOV     A,R7
002B C4                SWAP    A
002C F8                MOV     R0,A
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 49  

002D 540F              ANL     A,#0FH
002F C8                XCH     A,R0
0030 68                XRL     A,R0
0031 FF                MOV     R7,A
0032 EE                MOV     A,R6
0033 C4                SWAP    A
0034 54F0              ANL     A,#0F0H
0036 48                ORL     A,R0
0037 FE                MOV     R6,A
0038 900000      R     MOV     DPTR,#ri
003B EF                MOV     A,R7
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1294
003D 900000      R     MOV     DPTR,#epNumber
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 EF                MOV     A,R7
0043 75F00B            MOV     B,#0BH
0046 A4                MUL     AB
0047 2400        E     ADD     A,#LOW USBUART_1_EP+01H
0049 F582              MOV     DPL,A
004B E4                CLR     A
004C 3400        E     ADDC    A,#HIGH USBUART_1_EP+01H
004E F583              MOV     DPH,A
0050 E4                CLR     A
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1296
0052 900000      R     MOV     DPTR,#epNumber
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 75F00B            MOV     B,#0BH
005B A4                MUL     AB
005C 2400        E     ADD     A,#LOW USBUART_1_EP+05H
005E F582              MOV     DPL,A
0060 E4                CLR     A
0061 3400        E     ADDC    A,#HIGH USBUART_1_EP+05H
0063 F583              MOV     DPH,A
0065 E0                MOVX    A,@DPTR
0066 FF                MOV     R7,A
0067 900000      R     MOV     DPTR,#ri
006A E0                MOVX    A,@DPTR
006B FE                MOV     R6,A
006C EE                MOV     A,R6
006D FD                MOV     R5,A
006E 7C00              MOV     R4,#00H
0070 ED                MOV     A,R5
0071 240E              ADD     A,#0EH
0073 FD                MOV     R5,A
0074 EC                MOV     A,R4
0075 3460              ADDC    A,#060H
0077 FC                MOV     R4,A
0078 8D82              MOV     DPL,R5
007A 8C83              MOV     DPH,R4
007C EF                MOV     A,R7
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1297
                                           ; SOURCE LINE # 1298
007E         ?C0040:
007E 22                RET     
             ; FUNCTION _USBUART_1_EnableOutEP (END)

C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 50  

             ; FUNCTION _USBUART_1_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 1317
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1318
                                           ; SOURCE LINE # 1321
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 4043              JC      ?C0042
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 5038              JNC     ?C0042
                                           ; SOURCE LINE # 1322
                                           ; SOURCE LINE # 1323
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 7E00              MOV     R6,#00H
0022 EF                MOV     A,R7
0023 24FF              ADD     A,#0FFH
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 34FF              ADDC    A,#0FFH
0029 FE                MOV     R6,A
002A EF                MOV     A,R7
002B C4                SWAP    A
002C F8                MOV     R0,A
002D 540F              ANL     A,#0FH
002F C8                XCH     A,R0
0030 68                XRL     A,R0
0031 FF                MOV     R7,A
0032 EE                MOV     A,R6
0033 C4                SWAP    A
0034 54F0              ANL     A,#0F0H
0036 48                ORL     A,R0
0037 FE                MOV     R6,A
0038 900000      R     MOV     DPTR,#ri
003B EF                MOV     A,R7
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1325
003D 900000      R     MOV     DPTR,#ri
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 7E00              MOV     R6,#00H
0044 EF                MOV     A,R7
0045 240E              ADD     A,#0EH
0047 FF                MOV     R7,A
0048 EE                MOV     A,R6
0049 3460              ADDC    A,#060H
004B FE                MOV     R6,A
004C 8F82              MOV     DPL,R7
004E 8E83              MOV     DPH,R6
0050 7408              MOV     A,#08H
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 51  

0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1326
                                           ; SOURCE LINE # 1327
0053         ?C0042:
0053 22                RET     
             ; FUNCTION _USBUART_1_DisableOutEP (END)

             ; FUNCTION _USBUART_1_Force (BEGIN)
                                           ; SOURCE LINE # 1348
0000 900000      R     MOV     DPTR,#bState
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1349
                                           ; SOURCE LINE # 1350
0005 900000      R     MOV     DPTR,#bState
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906010            MOV     DPTR,#06010H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1351
000F 22                RET     
             ; FUNCTION _USBUART_1_Force (END)

             ; FUNCTION _USBUART_1_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 1369
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1370
                                           ; SOURCE LINE # 1372
0005 900000      R     MOV     DPTR,#cr
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1374
000A 900000      R     MOV     DPTR,#epNumber
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 404B              JC      ?C0044
0015 900000      R     MOV     DPTR,#epNumber
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B C3                CLR     C
001C 9409              SUBB    A,#09H
001E 5040              JNC     ?C0044
                                           ; SOURCE LINE # 1375
                                           ; SOURCE LINE # 1376
0020 900000      R     MOV     DPTR,#epNumber
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 7E00              MOV     R6,#00H
0027 EF                MOV     A,R7
0028 24FF              ADD     A,#0FFH
002A FF                MOV     R7,A
002B EE                MOV     A,R6
002C 34FF              ADDC    A,#0FFH
002E FE                MOV     R6,A
002F EF                MOV     A,R7
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 52  

0030 C4                SWAP    A
0031 F8                MOV     R0,A
0032 540F              ANL     A,#0FH
0034 C8                XCH     A,R0
0035 68                XRL     A,R0
0036 FF                MOV     R7,A
0037 EE                MOV     A,R6
0038 C4                SWAP    A
0039 54F0              ANL     A,#0F0H
003B 48                ORL     A,R0
003C FE                MOV     R6,A
003D 900000      R     MOV     DPTR,#ri
0040 EF                MOV     A,R7
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1377
0042 900000      R     MOV     DPTR,#ri
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 7E00              MOV     R6,#00H
0049 EF                MOV     A,R7
004A 240E              ADD     A,#0EH
004C FF                MOV     R7,A
004D EE                MOV     A,R6
004E 3460              ADDC    A,#060H
0050 FE                MOV     R6,A
0051 8F82              MOV     DPL,R7
0053 8E83              MOV     DPH,R6
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 5410              ANL     A,#010H
005A FF                MOV     R7,A
005B 900000      R     MOV     DPTR,#cr
005E EF                MOV     A,R7
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1378
0060         ?C0044:
                                           ; SOURCE LINE # 1380
0060 900000      R     MOV     DPTR,#cr
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
                                           ; SOURCE LINE # 1381
0065         ?C0045:
0065 22                RET     
             ; FUNCTION _USBUART_1_GetEPAckState (END)

             ; FUNCTION _USBUART_1_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 1406
0000 900000      R     MOV     DPTR,#powerStatus
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1407
                                           ; SOURCE LINE # 1408
0005 900000      R     MOV     DPTR,#powerStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0046
                                           ; SOURCE LINE # 1409
                                           ; SOURCE LINE # 1410
000D 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
0010 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 53  

0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4401              ORL     A,#01H
0015 FF                MOV     R7,A
0016 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1411
001B 22                RET     
001C         ?C0046:
                                           ; SOURCE LINE # 1413
                                           ; SOURCE LINE # 1414
001C 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 54FE              ANL     A,#0FEH
0024 FF                MOV     R7,A
0025 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1415
                                           ; SOURCE LINE # 1416
002A         ?C0048:
002A 22                RET     
             ; FUNCTION _USBUART_1_SetPowerStatus (END)

             ; FUNCTION USBUART_1_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 1461
                                           ; SOURCE LINE # 1462
                                           ; SOURCE LINE # 1463
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1464
0005 900000      E     MOV     DPTR,#USBUART_1_deviceStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0049
                                           ; SOURCE LINE # 1465
                                           ; SOURCE LINE # 1466
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1467
001A         ?C0049:
                                           ; SOURCE LINE # 1469
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 1470
001F         ?C0050:
001F 22                RET     
             ; FUNCTION USBUART_1_RWUEnabled (END)


C51 COMPILER V9.51   USBUART_1                                                             09/04/2014 17:45:42 PAGE 54  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2182    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      49
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
